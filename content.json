{"meta":{"title":"My Blog","subtitle":"www.awesomeboy.cn","description":"Cai","author":"Cai","url":"http://awesomeboy.cn","root":"/"},"pages":[{"title":"","date":"2023-03-06T14:13:46.635Z","updated":"2023-03-06T14:13:46.635Z","comments":true,"path":"about/index.html","permalink":"http://awesomeboy.cn/about/index.html","excerpt":"","text":""},{"title":"","date":"2023-03-06T08:22:44.010Z","updated":"2023-03-06T08:22:44.010Z","comments":true,"path":"archives/index.html","permalink":"http://awesomeboy.cn/archives/index.html","excerpt":"","text":""},{"title":"","date":"2023-03-08T08:17:58.570Z","updated":"2023-03-08T08:17:58.570Z","comments":true,"path":"css/custom.css","permalink":"http://awesomeboy.cn/css/custom.css","excerpt":"","text":"#RightDownBtn { position: fixed; left: 1.875rem; bottom: 1.875rem; padding: 0.3125rem 0.625rem; background: #fff; border-radius: 0.1875rem; transition: 0.3s ease all; z-index: 1; align-items: flex-end; flex-direction: column; display: -moz-flex; display: flex; float: right; } #RightDownBtn>a, #RightDownBtn>label { width: 1.5em; height: 1.5em; margin: 0.3125rem 0; transition: .2s cubic-bezier(.25, .46, .45, .94); } /* font color */ .DarkMode #page, .DarkMode #colophon, .DarkMode #vcomments .vbtn, .DarkMode .art-content #archives .al_mon_list .al_mon, .DarkMode .art-content #archives .al_mon_list span, .DarkMode body, .DarkMode .art-content #archives .al_mon_list .al_mon, .DarkMode .art-content #archives .al_mon_list span, .DarkMode button, .DarkMode .art .art-content #archives a, .DarkMode textarea, .DarkMode strong, .DarkMode a, .DarkMode p, .DarkMode li, .DarkMode .label { color: rgba(255, 255, 255, .6); } .DarkMode #page, .DarkMode body, .DarkMode #colophon, .DarkMode #main-container, .DarkMode #page .yya, .DarkMode #content, .DarkMode #contentss, .DarkMode #footer { background-color: #292a2d; } .DarkMode strong, .DarkMode img { filter: brightness(.7); } /* sun and noon */ .Cuteen_DarkSky, .Cuteen_DarkSky:before { content: \"\"; position: fixed; left: 0; right: 0; top: 0; bottom: 0; z-index: 88888888 } .Cuteen_DarkSky { background: linear-gradient(#feb8b0, #fef9db) } .Cuteen_DarkSky:before { transition: 2s ease all; opacity: 0; background: linear-gradient(#4c3f6d, #6c62bb, #93b1ed) } .DarkMode .Cuteen_DarkSky:before { opacity: 1 } .Cuteen_DarkPlanet { z-index: 99999999; position: fixed; left: -50%; top: -50%; width: 200%; height: 200%; -webkit-animation: CuteenPlanetMove 2s cubic-bezier(.7, 0, 0, 1); animation: CuteenPlanetMove 2s cubic-bezier(.7, 0, 0, 1); transform-origin: center bottom } @-webkit-keyframes CuteenPlanetMove { 0% { transform: rotate(0) } to { transform: rotate(360deg) } } @keyframes CuteenPlanetMove { 0% { transform: rotate(0) } to { transform: rotate(360deg) } } .Cuteen_DarkPlanet:after { position: absolute; left: 35%; top: 40%; width: 9.375rem; height: 9.375rem; border-radius: 50%; content: \"\"; background: linear-gradient(#fefefe, #fffbe8) }"},{"title":"所有分类","date":"2023-03-06T08:34:53.432Z","updated":"2023-03-06T08:34:53.432Z","comments":true,"path":"categories/index.html","permalink":"http://awesomeboy.cn/categories/index.html","excerpt":"","text":""},{"title":"","date":"2023-08-31T01:20:52.752Z","updated":"2023-08-31T01:20:52.752Z","comments":true,"path":"friends/index.html","permalink":"http://awesomeboy.cn/friends/index.html","excerpt":"","text":"友 情 链 接 西安邮电大学-大数据与人工智能实验室 OceanHAurora 安卓真神 海鸥丸拉面"},{"title":"","date":"2023-03-15T14:12:24.570Z","updated":"2023-03-15T14:12:24.570Z","comments":true,"path":"js/FunnyTitle.js","permalink":"http://awesomeboy.cn/js/FunnyTitle.js","excerpt":"","text":"// 浏览器搞笑标题 var OriginTitle = document.title; var titleTime; document.addEventListener('visibilitychange', function () { if (document.hidden) { $('[rel=\"icon\"]').attr('href', \"/funny.ico\"); document.title = '╭(°A°`)╮ 页面崩溃啦 ~'; clearTimeout(titleTime); } else { $('[rel=\"icon\"]').attr('href', \"/favicon.ico\"); document.title = '(ฅ>ω"},{"title":"","date":"2023-08-09T02:59:48.417Z","updated":"2023-08-09T02:59:48.417Z","comments":true,"path":"history/index.html","permalink":"http://awesomeboy.cn/history/index.html","excerpt":"","text":"建站历史 2023-08-09 完善友链界面 2023-08-08 完成右击出现菜单栏功能 2023-03-17 使用 giscus 评论系统 2023-03-14 配置 Typora + PicGo + 阿里云 oss 图床 2023-03-10 使用 Volantis 主题配置相关基础功能 2023-03-06 搭建 hexo 博客网站使用 Vercel 托管博客网站成功发布第一篇博客 Hello World"},{"title":"","date":"2023-03-08T08:28:14.838Z","updated":"2023-03-08T08:28:14.838Z","comments":true,"path":"js/subtitle.js","permalink":"http://awesomeboy.cn/js/subtitle.js","excerpt":"","text":"var binft = function (r) { var isTransparent = true; function getRandomColor() { if(isTransparent){ isTransparent = false; //此处修改字体颜色,最后的 0 和 1 不要改 return \"rgba(255,255,255,0)\" }else{ isTransparent = true; return \"rgba(255,255,255,1)\" } } function n(r) { for (var n = document.createDocumentFragment(), i = 0; r > i; i++) { var oneword = document.createElement(\"span\"); oneword.textContent = \"_\"; // 此处是末尾字符,如果想用光标样式可以改为\"|\" oneword.style.color = getRandomColor(); n.appendChild(oneword); } return n } function i() { var t = wordList[c.skillI]; c.step ? c.step-- : (c.step = refreshDelayTime, c.prefixP < l.length ? (c.prefixP >= 0 && (c.text += l[c.prefixP]), c.prefixP++) : \"forward\" === c.direction ? c.skillP < t.length ? (c.text += t[c.skillP], c.skillP++) : c.delay ? c.delay-- : (c.direction = \"backward\", c.delay = showTotalWordDelayTime) : c.skillP > 0 ? (c.text = c.text.slice(0, -1), c.skillP--) : (c.skillI = (c.skillI + 1) % wordList.length, c.direction = \"forward\")), r.textContent = c.text, r.appendChild(n(c.prefixP < l.length ? Math.min(maxLength, maxLength + c.prefixP) : Math.min(maxLength, t.length - c.skillP))), setTimeout(i, d) } var l = \"\", //此处改成你自己的诗词 wordList = [ \"有花堪折直需折,莫待无花空折枝.\", \"闲居少邻并,草径入荒园.鸟宿池边树,僧敲月下门.\", \"侯门一入深如海,从此萧郎是路人.\", \"才见岭头云似盖,已惊岩下雪如尘.\", \"人间万事消磨尽,只有清香似旧时.\", \"日暮酒醒人已远,满天风雨下西楼.\", \"落灯花,棋未收,叹新丰逆旅淹留.\", \"软风吹过窗纱,心期便隔天涯.\", \"迷惑失故路,薄暮无宿栖.\", \"不见白头相携老,只许与君共天明.\", \"晓迎秋露一枝新,不占园中最上春.\", \"荷尽已无擎雨盖,菊残犹有傲霜枝.\", \"春未绿,鬓先丝.人间别久不成悲.\", \"江东子弟多才俊,卷土重来未可知.\", \"莫听穿林打叶声,何妨吟啸且徐行.\", \"在天愿作比翼鸟,在地愿为连理枝.\", ].map(function (r) { return r + \"\" }), showTotalWordDelayTime = 2, refreshDelayTime = 1, maxLength = 1, d = 75, c = { text: \"\", prefixP: -maxLength, skillI: 0, skillP: 0, direction: \"forward\", delay: showTotalWordDelayTime, step: refreshDelayTime }; i() }; binft(document.getElementById('binft'));"},{"title":"more","date":"2023-03-07T06:35:56.000Z","updated":"2023-03-07T06:35:56.964Z","comments":true,"path":"more/index.html","permalink":"http://awesomeboy.cn/more/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2023-03-06T08:29:01.450Z","updated":"2023-03-06T08:29:01.450Z","comments":true,"path":"tags/index.html","permalink":"http://awesomeboy.cn/tags/index.html","excerpt":"","text":""},{"title":"","date":"2023-03-08T08:17:39.892Z","updated":"2023-03-08T08:17:39.892Z","comments":true,"path":"js/custom.js","permalink":"http://awesomeboy.cn/js/custom.js","excerpt":"","text":"function BackTOP() { $(\"#btn\").hide(); $(function () { $(window).scroll(function () { if ($(window).scrollTop() > 50) { $(\"#btn\").fadeIn(200); } else { $(\"#btn\").fadeOut(200); } }); $(\"#btn\").click(function () { $('body,html').animate({ scrollTop: 0 }, 500); return false; }); }); $(function () { $(\"#say\").click(function () { $('body,html').animate({ scrollTop: $('html, body').get(0).scrollHeight }, 500); return false; }); }) } $('#readmode').click(function () { $('body').toggleClass('read-mode') }) function SiderMenu() { $('#main-container').toggleClass('open'); $('.iconflat').css('width', '50px').css('height', '50px'); $('.openNav').css('height', '50px'); $('#main-container,#mo-nav,.openNav').toggleClass('open') } function switchNightMode() { $('').appendTo($(\"body\")), setTimeout( function () { (volantis.dark.mode == \"dark\") ? ($(\"html\").addClass(\"DarkMode\"), $('#modeicon').attr(\"xlink:href\", \"#icon-sun\")) : ($(\"html\").removeClass(\"DarkMode\"), $('#modeicon').attr(\"xlink:href\", \"#icon-_moon\")), setTimeout(function () { $(\".Cuteen_DarkSky\").fadeOut(1e3, function () { $(this).remove() }) }, 2e3) }), 50 } function checkNightMode() { if ($(\"html\").hasClass(\"n-f\")) { $(\"html\").removeClass(\"day\"); $(\"html\").addClass(\"DarkMode\"); $('#modeicon').attr(\"xlink:href\", \"#icon-sun\") return; } if ($(\"html\").hasClass(\"d-f\")) { $(\"html\").removeClass(\"DarkMode\"); $(\"html\").addClass(\"day\"); $('#modeicon').attr(\"xlink:href\", \"#icon-_moon\") return; } if (volantis.dark.mode == \"dark\") { $(\"html\").addClass(\"DarkMode\"); $('#modeicon').attr(\"xlink:href\", \"#icon-sun\") } else { $(\"html\").removeClass(\"DarkMode\"); $('#modeicon').attr(\"xlink:href\", \"#icon-_moon\") } } BackTOP(); volantis.dark.push(switchNightMode);"}],"posts":[{"title":"LeetCode-912-排序数组","slug":"LeetCode-912-排序数组","date":"2023-09-13T06:42:23.000Z","updated":"2023-09-13T06:55:41.793Z","comments":true,"path":"2023/09/13/LeetCode-912-排序数组/","link":"","permalink":"http://awesomeboy.cn/2023/09/13/LeetCode-912-%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/","excerpt":"","text":"一：题目描述：给你一个整数数组 nums，请你将该数组升序排列。 二：示例与提示示例 1:12输入：nums = [5,2,3,1]输出：[1,2,3,5] 示例 2:12输入：nums = [5,1,1,2,0,0]输出：[0,0,1,1,2,5] 提示： 1 &lt;= nums.length &lt;= 5 * 104 -5 * 104 &lt;= nums[i] &lt;= 5 * 104 三：思路实现快速排序之前大一时候用C语言实现过快速排序 想想当时思路去想这个快排，还是下了很多的功夫 随意列出10个无序的数字，需要用到i，j两个变量，i在这列数的最左边，j在这列数的最右边，在这列数中随意找到一个数设置基准值（这里为了方便将第一个数设置为基准），首先让j向左移动，让i向右移动。j找到一个比基准值小的数2停下来，然后i向右移动找到比基准值大的数6停下来，然后将i，j所指向的数进行交换。交换后，j继续向左移动找到比基准值小的数4停下来，然后i向右移动找到比基准值大的数7停下来，然后将i，j所指向的数进行交换。接下来j继续向左移动找到比基准值小的数3，i向右移动和j碰面，此时i和j在同一个位置上停下来，此时将i和j所指向的数和基准值进行交换，即将3和5进行交换。即基准值归位后，基准值左边的都是小于基准值5的数，在基准值右边的都是大于基准值5的数。 这里需要提一点的是，为什么每次都需要j先移动，因为当最后i和j相碰时，此时所指向的是j寻找到比基准值小的数字，然后和基准值交换能确保基准值左边的都是小于基准值的数字，但是如果i先右边移动的话，最后i和j相碰时，i和j所指向的是i寻找得比基准值大的数，此时和基准值相交换，基准值左边是有一个比基准值大的数，没有达到我们需要的排序效果。之后我们将5左边的拉出来再进行排序，此时选的基准值是3，根据原先的流程再来一遍。 这就是快速排序的逻辑。 最后总结下快排的步骤和注意点： 1.选取基准点2.永远是j先向左移动，i再向右移动3.当i，j碰面时候，将i和j所指向的数和基准值交换4.然后处理左半边和右半边（递归） 四：代码 + 复杂度分析快速排序123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * @param &#123;number[]&#125; nums * @return &#123;number[]&#125; */var sortArray = function(nums) &#123; quickSort(nums, 0, nums.length - 1) return nums&#125;;const quickSort = (nums, left, right) =&gt; &#123; //终止条件 if(left &gt;= right) &#123; return &#125; //单层逻辑 //i, j是需要移动的指针 let i = left let j = right //基准值永远是最左边的元素 let temp = nums[left] while(i &lt; j) &#123; //右边先移动 //两个条件判断 //右边找小于基准值的 while(nums[j] &gt;= temp &amp;&amp; i &lt; j) &#123; j-- &#125; //左边移动 //左边找大于基准值的 while(nums[i] &lt;= temp &amp;&amp; i &lt; j) &#123; i++ &#125; //找到对应要交换的值交换 let t = nums[i] nums[i] = nums[j] nums[j] = t &#125; //将I和j同时指向的元素与基准值交换 nums[left] = nums[i] nums[i] = temp //调用递归 分冶 quickSort(nums, left, i - 1) quickSort(nums, i + 1, right)&#125; 时间复杂度：O(nlogn) 最好情况下的时间复杂度为O(nlogn)。 最坏情况下的时间复杂度为O(n^2)。 在平均情况下，快速排序的时间复杂度为O(nlogn)","categories":[{"name":"算法","slug":"算法","permalink":"http://awesomeboy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://awesomeboy.cn/tags/%E6%95%B0%E7%BB%84/"},{"name":"排序","slug":"排序","permalink":"http://awesomeboy.cn/tags/%E6%8E%92%E5%BA%8F/"}],"author":"awesomeboy"},{"title":"手写call,apply,bind方法","slug":"手写call-apply-bind方法","date":"2023-09-12T12:56:03.000Z","updated":"2023-09-12T14:16:15.443Z","comments":true,"path":"2023/09/12/手写call-apply-bind方法/","link":"","permalink":"http://awesomeboy.cn/2023/09/12/%E6%89%8B%E5%86%99call-apply-bind%E6%96%B9%E6%B3%95/","excerpt":"","text":"一：手写call方法1. call()方法 call方法是用于调用函数的方法，并且可以接收参数 1function.call(thisArg, arg1, arg2, ...) function：要调用的函数 thisArg：可选参数，指定函数执行时的上下文，即内部函数的this的值。如果不传，this的值将为全局对象 agr1, arg2…：可选参数，要传递给函数的参数列表 使用call()方法可以方便地修改函数的执行上下文，使其在不同的对象上执行，以达到灵活性和重用性的目的。 2. es6实现call方法 需要满足call方法的几个条件 所有函数都可以调用myCall方法 调用原函数并且将this绑定到指定的对象 接收不定量的参数，并且返回结果 1234567891011121314151617181920212223//实现代码Function.prototype.myCall = function (thisArg, ...args)&#123; //如果为提供 thisArg绑定到window上 thisArg = thisArg || window //使用symbol const key = Symbol(&#x27;key&#x27;) //thisArg.f是fn函数的引用 thisArg[key] = this //调用该函数 const res = thisArg[key](...args) //删除对象上的f函数 delete thisArg[key] //此时fn的this就指向obj return res&#125;function fn (numberA, numberB, numberC)&#123; return numberA + numberB + numberC&#125;let res = fn.myCall(obj, 2, 4, 6) 通过给函数原型上添加myCall方法实现所有函数能够调用该方法 要改变This的指向，就需要获取原函数的引用和传入的对象 fn.myCall(obj, 2, 4, 6)，我们在调用函数的时候，就隐式绑定了myCall方法的this值为fn函数，所以this的值就是fn函数的引用 通过将该函数的引用添加到需要绑定的对象的属性上，即给thisArg添加原函数的引用，并执行，形如obj.fn()，隐式绑定将fn函数的this值绑定到obj对象上 但由于设定变量来保存原函数的引用，可能会导致设置的变量与原有的对象中的属性命名冲突，缩小了命名空间 利用es6方法中的symbol()构造函数，每次调用返回一个独一无二的值，利用该特性来实现设置的变量不会与原有属性冲突 利用…args剩余参数语法，动态接收不定量的参数，并将它们作为数组存储在args中 最后利用delete关键字再删除绑定对象中的该属性 二：手写apply方法1. apply()方法 apply()方法是调用原函数的同时可以指定原函数this的值，并传递一个参数数组 1function.apply(thisArg, [argsArray]) function: 原函数 thisArg：可选参数，指定函数执行时的上下文，即内部函数的this的值。如果不传，this的值将为全局对象 [argsArrray]：一个数组或类数组对象，包含了要传递给函数的参数。 2. es6实现apply方法 apply方法与call方法区别就是接收参数的形式不同 call方法接收参数是不定参数，接收时候就需要用到es6的剩余参数 apply方法传递的是一个参数数组，只需要在调用原函数的时候，利用展开运算符将数组展开传递参数即可 123456789101112131415161718192021222324252627Function.prototype.myApply = function (thisArg, args)&#123; //如果未传obj，this绑定到window对象上 thisArg = thisArg || window //绑定this并调用原函数 const key = Symbol(&#x27;key&#x27;) thisArg[key] = this //接收返回值 const res = thisArg[key](...args) //删除该属性 delete thisArg[key] //返回结果 return res&#125;//测试const obj = &#123; name: &#x27;xxx&#x27;&#125;function fn (numberA, numberB)&#123; return numberA + numberB&#125;let res = fn.myApply(obj, [2, 4])console.log(&#x27;结果:&#x27; + res); 三：手写bind方法1. bind()方法 bind方法用于创建一个新函数，并给指定对象绑定原函数的this的值，并在调用的时候传递给Bind()方法的参数作为新函数的预置参数 1function.bind(thisArg[, arg1[, arg2[, ...]]]) thisArg：在新函数中被绑定为 this 值的对象。 arg1, arg2, ...：作为新函数的预置参数，可选。 2. es6实现bind方法 创建一个新函数，即返回一个函数 利用call或apply方法绑定this的值 通过展开运算符 ... 将 args1（bind() 方法的第二个及后续参数）和 args2（新函数的参数）合并为一个数组，然后传递给 apply() 方法。 123456789101112131415161718192021222324Function.prototype.myBind = function (thisArg, ...args1)&#123; //返回一个函数 return (...args2) =&gt; &#123; //绑定this //拿到fn函数 -- 箭头函数的This捕获上一级作用域的this值，即myBind函数的This，是fn函数 return this.call(thisArg, ...args1, ...args2) &#125;&#125;//测试const obj = &#123; name: &#x27;xxx&#x27;&#125;function fn (numberA, numberB, numberC, numberD)&#123; return numberA + numberB + numberC + numberD&#125;//绑定但是不调用let tempFn = fn.myBind(obj, 2, 4)let res = tempFn(6, 8)console.log(&#x27;结果:&#x27; + res);","categories":[{"name":"JS","slug":"JS","permalink":"http://awesomeboy.cn/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://awesomeboy.cn/tags/JS/"}],"author":"awesomeboy"},{"title":"LeetCode-15-三数之和","slug":"LeetCode-15-三数之和","date":"2023-09-12T08:07:14.000Z","updated":"2023-09-12T08:22:32.266Z","comments":true,"path":"2023/09/12/LeetCode-15-三数之和/","link":"","permalink":"http://awesomeboy.cn/2023/09/12/LeetCode-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"","text":"一：题目描述：给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请 你返回所有和为 0 且不重复的三元组。 注意：答案中不可以包含重复的三元组。 二：示例与提示示例 1:12345678输入：nums = [-1,0,1,2,-1,-4]输出：[[-1,-1,2],[-1,0,1]]解释：nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。注意，输出的顺序和三元组的顺序并不重要。 示例 2:123输入：nums = [0,1,1]输出：[]解释：唯一可能的三元组和不为 0 。 示例 3:123输入：nums = [0,0,0]输出：[[0,0,0]]解释：唯一可能的三元组和为 0 。 提示： 3 &lt;= nums.length &lt;= 3000 -105 &lt;= nums[i] &lt;= 105 三：思路暴力求解 直接暴力套三层循环，求出所有结果，或者套两个循环，用数组存下a + b的值，找 0 - (a + b)即可 是可以找到满足对应的结果，但是有重复结果 例如：[[-1,-1,2],[-1,0,1] ，[-1, 0, 1]]，重复结果不好去除，只会更加复杂 双指针 尽量在遍历中就将结果去重，不要收集完结果再去去重 想通过三个变量去控制a,b,c 先将nums数组排序，三数之和为0，有序数组更好控制范围的缩减 for循环遍历数组，i控制a元素，left指针定义在i的右边，right指针定义在数组的结尾 当i遍历到一个元素a，就通过不断左右指针，左指针右移元素b，右指针左移元素c缩减范围直到和为0 去重a元素：当排序过后的数组，i左边的元素等于i元素时候进行去除，不能将i 与 i右边的元素进行判断，i右边的元素是left指针指向的元素，i和left指向的元素都需要加入到结果，结果中允许出现相同元素的 去重b，c元素 四：代码 + 复杂度分析双指针12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * @param &#123;number[]&#125; nums * @return &#123;number[][]&#125; */var threeSum = function(nums) &#123; //双指针 const res = [] nums.sort((a, b) =&gt; a - b) //外层遍历 for(let i = 0; i &lt; nums.length; i++) &#123; //指针赋值 //左指针在i右一个 右指针在末尾 let left = i + 1 let right = nums.length - 1 //如果排序后 第一个数都大于0了 就直接返回了 if(nums[i] &gt; 0) return res //去重逻辑 如果左边的数等于现在的数跳过 if(nums[i] === nums[i - 1]) continue //开始移动两个指针 while(left &lt; right) &#123; let sum = nums[i] + nums[left] + nums[right] //和大就要缩小范围 右指针左移 if(sum &gt; 0) right-- else if(sum &lt; 0) left++ else &#123; console.log(nums[i], nums[left], nums[right]) //收集结果 res.push([nums[i], nums[left], nums[right]]) //去重b 和 c，避免下次遍历到一样的三元组 while(left &lt; right &amp;&amp; nums[left] === nums[left + 1])&#123; left++ &#125; while(left &lt; right &amp;&amp; nums[right] === nums[right - 1])&#123; right-- &#125; //移动双指针 left++ right-- &#125; &#125; &#125; return res&#125;; 时间复杂度：O(n log n + n^2) 数组排序 ,调用sort快排：O(n logn) 外层遍历的循环迭代了一次，其时间复杂度为 **O(n)**。 双指针移动遍历，O（n）线性移动 内部的while循环，O（n），指针最多遍历全部数组 总和：O（n log(n) ） + O(n ^ 2) 空间复杂度：O(n^2) 最坏情况下为 **O(n^2)**，因为可能有很多满足条件的三元组","categories":[{"name":"算法","slug":"算法","permalink":"http://awesomeboy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"http://awesomeboy.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"数组","slug":"数组","permalink":"http://awesomeboy.cn/tags/%E6%95%B0%E7%BB%84/"}],"author":"awesomeboy"},{"title":"LeetCode-46-全排列","slug":"LeetCode-46-全排列","date":"2023-09-12T07:47:54.000Z","updated":"2023-09-12T08:06:43.562Z","comments":true,"path":"2023/09/12/LeetCode-46-全排列/","link":"","permalink":"http://awesomeboy.cn/2023/09/12/LeetCode-46-%E5%85%A8%E6%8E%92%E5%88%97/","excerpt":"","text":"一：题目描述：给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。 二：示例与提示示例 1:12输入：nums = [1,2,3]输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] 示例 2:12输入：nums = [0,1]输出：[[0,1],[1,0]] 示例 3:12输入：nums = [1]输出：[[1]] 提示： 1 &lt;= nums.length &lt;= 6 -10 &lt;= nums[i] &lt;= 10 nums 中的所有整数 互不相同 三：思路回溯 + used数组记录 排列与组合的区别 [0, 2]，[2,0]这是一个组合但是是不同的排列 对于原先的组合问题，是为了避免出现上方的这个情况，导致重复使用该元素，才引入startIndex，在每次递归的时候都要+1，避免使用前面使用过的元素 但是对于排列来说，这是一个不同的排列，前面的元素，我们后面可以使用 对于这种组合排列问题，先画出树形结构 横向拓展是for循环遍历nums数组 纵向深度是递归获得排列 但我们要避免同一个元素在一个排列中重复使用，因此使用used数组来记录使用过的元素，true使用过，false未使用 剩下的思路跟之前的组合问题类似了 终止条件：单个path获取到的元素长度跟nums长度一致就添加到res结果集中 单层逻辑：递归 + 回溯 四：代码 + 复杂度分析回溯12345678910111213141516171819202122232425262728293031323334353637383940/** * @param &#123;number[]&#125; nums * @return &#123;number[][]&#125; */var permute = function(nums) &#123; //回溯 //组合问题 //抽象成树形结构 //收集结果的数组 const res = [] //收集单条路径的结果 const path = [] //used数组避免取重复的元素 const used = [] const backtracking = (nums, used) =&gt; &#123; //终止条件 if(path.length === nums.length) &#123; //把path加入到结果 // console.log(path) res.push([...path]) return &#125; //单层逻辑 for(let i = 0; i &lt; nums.length; i++) &#123; //如果used数组中该位置的元素被标记了 说明已经用过了 就跳过 if(used[i] === true) continue //收集 path.push(nums[i]) //标记 used[i] = true //递归 backtracking(nums, used) //回溯 path.pop(nums[i]) used[i] = false &#125; &#125; backtracking(nums, used) return res&#125;; 时间复杂度：O(n!) 在回溯算法中，需要遍历数组的每个元素，并进行递归调用。对于每个元素，都有 n 种选择，因此总共需要进行 n^n 次操作 空间复杂度：O(n!) res 数组用于存储所有排列结果，其空间复杂度为 **O(n!)**，因为最多有 n! 个排列结果。","categories":[{"name":"算法","slug":"算法","permalink":"http://awesomeboy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"回溯","slug":"回溯","permalink":"http://awesomeboy.cn/tags/%E5%9B%9E%E6%BA%AF/"},{"name":"数组","slug":"数组","permalink":"http://awesomeboy.cn/tags/%E6%95%B0%E7%BB%84/"}],"author":"awesomeboy"},{"title":"关于this","slug":"关于this","date":"2023-09-11T12:44:04.000Z","updated":"2023-09-11T13:59:37.926Z","comments":true,"path":"2023/09/11/关于this/","link":"","permalink":"http://awesomeboy.cn/2023/09/11/%E5%85%B3%E4%BA%8Ethis/","excerpt":"","text":"参考阮一峰老师对于this的原理理解 一：this的定义 在严格模式下和非严格模式下，this的在全局中会有差别 来自阮一峰老师对于this的由来的理解 由于函数可以在不同的运行环境中运行，所以需要一种机制，能够在函数的内部获取当前运行环境，因此this就出现来，this的设计目的就是为了在函数的内部，指代函数当前的运行环境 所以在绝大多数的情况下，函数当前的运行环境决定了this的值 例如： 12345678910var obj = &#123; foo: function () &#123; console.log(this.bar) &#125;, bar: 1 &#125;; var foo = obj.foo; var bar = 2; obj.foo() // 1 foo() // 2 对于obj.foo()来说，是通过obj这个对象来找到foo()，所以foo()的运行环境obj对象，因此this的值就是Obj对象 对于foo()来说，foo()函数的运行环境是window，因此this的值就是window 二：绑定规则根据不同的使用场合，this有不同的值，主要分为下面几种情况： 默认绑定 隐式绑定 new绑定 显示绑定 1. 默认绑定 默认绑定的意思就是，当函数独立执行，不作为一个对象的方法调用时，this绑定到全局对象中，但在严格模式下，this会绑定到undefined 123456function foo ()&#123; console.log(this); // 在浏览器中通常指向 window 对象&#125;foo(); 2. 隐式绑定 当函数作为对象的方法调用时，this 绑定到调用该方法的对象 12345678var obj = &#123; foo: function () &#123; console.log(this) &#125;, bar: 1&#125;;var foo = obj.foo;obj.foo() // 1 这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象 123456789101112var obj = &#123; a: &#123; foo: function () &#123; console.log(this) &#125;, &#125;, bar: 1&#125;;var foo = obj.foo;var bar = 2;obj.a.foo() foo执行的环境是a对象，所以this指向a对象 再例如： 1234567891011121314151617var obj = &#123; a: &#123; bar: 1, foo: function () &#123; console.log(this.bar); //2 console.log(this) //window &#125;, &#125;,&#125;;var bar = 2;const fn = obj.a.foo fn() 在该代码中，定义了一个变量fn，被将其赋值为obj.a.foo，这意味着fn现在引用了，obj对象中，a属性的foo方法。 最后调用fn（），执行foo()函数 将obj.a.foo复制给fn，只是将foo函数的引用复制给了fn，但并没有立即执行。所以fn只是函数的引用，它的上下文还是跟obj.a.foo相关 但是当调用fn()时，这才是真正执行foo函数的时候，但由于fn是在全局上下文中调用的，JS将函数上下文this赋值为window 3. 显示绑定 使用 call()、apply() 或 bind() 方法显式地指定函数的 this 值。 12345678910var obj = &#123; foo: function () &#123; console.log(this.bar) &#125;, bar: 1&#125;;var obj2 = &#123; bar: 100&#125;obj.foo.call(obj2) 4. new 绑定 当函数用作构造函数（使用 new 关键字创建对象）时，this 绑定到新创建的对象。 1234567function fn ()&#123; this.bar = 1&#125;var obj = new fn()console.log(obj.bar); 通过new关键字改变了this的执行，指向了obj 当函数返回一个对象 12345678910function fn ()&#123; this.bar = 1 return &#123; bar: 10 &#125;&#125;var obj = new fn()console.log(obj.bar); 当函数返回一个对象时，通过new关键字将this指向改变指向返回的对象，不指向obj 当返回一些简单类型时候 12345678function fn ()&#123; this.bar = 1 return true&#125;var obj = new fn()console.log(obj.bar); this还是指向obj 返回null 12345678function fn ()&#123; this.bar = 1 return null&#125;var obj = new fn()console.log(obj.bar); 虽然null是object类型 但是还是指向obj 三：箭头函数 JS中箭头函数与普通函数在this上有着重要的不同。 箭头函数this的绑定是在箭头函数创建的时候就确定的好的，是静态this绑定，它没有自己的上下文，它会捕获最近的普通函数的this值 普通函数this值取决于，函数是如何被调用的，是根据调用方式动态确定的 在全局上下文中 123456var a = 1const fn = () =&gt;&#123; console.log(this.a);&#125;fn() fn箭头函数会自动捕获最近的最近的普通函数上下文，通常是全局对象window 在对象方法中 123456789var a = 10const obj = &#123; a: 1, fn: () =&gt; &#123; console.log(this.a); &#125;&#125;obj.fn() fn箭头函数的this值不取决于被调用时动态绑定，而是在静态创建时候，与最近最近的普通函数上下文this值一致 fn箭头函数最近最近的普通函数上下文是window全局 因此this指向window 作为事件回调 1&lt;button id=&quot;btn&quot;&gt;点击&lt;/button&gt; 1234567891011const btn = document.getElementById(&#x27;btn&#x27;)var a = 10const obj = &#123; a: 1, fn: () =&gt; &#123; console.log(this.a); // 10 &#125;&#125;btn.addEventListener(&#x27;click&#x27;, obj.fn) 点击按钮输出还是10 箭头函数作为回调函数时，其 this 绑定通常与定义它的上下文相同。 四：优先级1. 隐式绑定 VS 显示绑定12345678910111213141516171819function foo() &#123; console.log( this.a );&#125;var obj1 = &#123; a: 2, foo: foo&#125;;var obj2 = &#123; a: 3, foo: foo&#125;;obj1.foo(); // 2obj2.foo(); // 3obj1.foo.call( obj2 ); // 3obj2.foo.call( obj1 ); // 2 显示绑定优先级要高于隐式绑定 2. new绑定 VS 显示绑定1234567891011function Person(name) &#123; this.name = name;&#125;const alice = new Person(&quot;Alice&quot;);const person = &#123; name: &quot;Bob&quot; &#125;;const boundGreet = greet.bind(person);const aliceWithBinding = new boundGreet(); // 使用 new 绑定，this 绑定到新对象 aliceWithBindingconsole.log(aliceWithBinding.name); // 输出: undefined，因为 new 绑定覆盖了显式绑定 new 绑定的优先级更高。当使用 new 关键字创建对象实例时，它会覆盖之前的显式绑定","categories":[{"name":"JS","slug":"JS","permalink":"http://awesomeboy.cn/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://awesomeboy.cn/tags/JS/"}],"author":"awesomeboy"},{"title":"Validate表单组件的封装","slug":"Validate表单组件的封装","date":"2023-09-09T12:26:26.000Z","updated":"2023-09-09T14:25:53.006Z","comments":true,"path":"2023/09/09/Validate表单组件的封装/","link":"","permalink":"http://awesomeboy.cn/2023/09/09/Validate%E8%A1%A8%E5%8D%95%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B0%81%E8%A3%85/","excerpt":"","text":"之前一直是直接去使用别人现成的组件库，也没有具体去了解人家的组件是怎么封装的，造轮子才会更好地提高自己，所以尝试开始从封装Form表单组件开始 一：组件需求分析 本次封装组件，主要是摸索封装组件的流程，对于具体需要的方法和属性，只会实现其中部分方法和属性，之后一点一点才进行添加 表单项组件，ValidateInput组件的封装 根据传递不同的type类型有着不同的校验规则 支持V-model，对于封装的自定义组件支持v-model双向绑定也是一个很关键的属性 tag根节点的类型 form组件，提交事件 验证整体表单项，是否通过 清空表单项的内容 二：技术栈 Vue3 TS Bootstrap样式库 三：封装Validate-input验证表单项组件思路 1. 明确属性和事件 v-model属性 rules属性：根据不同type不同校验规则 tag根节点类型 ValidateInput组件 12345678910111213&lt;template&gt; &lt;div class=&quot;validate-input-container pb-3&quot;&gt; &lt;input class=&quot;form-control&quot; :class=&quot;&#123; &#x27;is-invalid&#x27;: inputRef.error &#125;&quot; :value=&quot;modelValue&quot; @blur=&quot;validateInput&quot; @input=&quot;updateValue&quot; v-bind=&quot;$attrs&quot; /&gt; &lt;span v-if=&quot;inputRef.error&quot; class=&quot;invalid-feedback&quot;&gt;&#123;&#123; inputRef.message &#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt; 12345678910111213141516171819202122232425262728293031323334&lt;script setup lang=&quot;ts&quot;&gt;//禁用 Attributes 继承defineOptions(&#123; inheritAttrs: false&#125;)//定义传来的一个参数类型interface RangeProp &#123; message: string length: number&#125;interface RuleProp &#123; type: &#x27;required&#x27; | &#x27;email&#x27; | &#x27;range&#x27; message?: string //至少位数 min?: RangeProp max?: RangeProp&#125;//数组类型export type RulesProp = RuleProp[]//接收参数const props = defineProps&lt;&#123; rules?: RulesProp //自定义组件使用v-model需要用modelValue来接收参数 modelValue: string&#125;&gt;()//定义表单的数据const inputRef = reactive(&#123; //如果为空 val: props.modelValue || &#x27;&#x27;, error: false, //表单验证是否通过 message: &#x27;&#x27; //错误信息&#125;)&lt;/script&gt; 禁用Attributes继承：透传 attribute”指的是传递给一个组件，却没有被该组件声明为 props 或 emits 的 attribute 或者 v-on 事件监听器。最常见的例子就是 class、style 和 id。 12&lt;!-- &lt;MyButton&gt; 的模板 --&gt;&lt;button&gt;click me&lt;/button&gt; 当父组件使用该组件，并且传入class: 1&lt;MyButton class=&quot;large&quot; /&gt; 最终会在根元素出现class&#x3D;‘large“，&lt;MyButton&gt; 并没有将 class 声明为一个它所接受的 prop，所以 class 被视作透传 attribute，自动透传到了 &lt;MyButton&gt; 的根元素上。 因此需要禁用Attibutes继承 定义接收参数类型 rules可选参数，接收数组 modelValue：接收字符串即输入的值 2. v-model属性在使用一个自定义组件给其添加v-model属性，其自定义组件内部做了两件事 将内部原生的input元素的值绑定到组件内部Prop属性modelValue 当原生input元素触发时候，触发一个携带了新值的 update:modelValue 自定义事件 12&lt;!-- 自定义组件Validate-input --&gt;&lt;Validate-input v-model=&quot;loginParams.email&quot; :rules=&quot;emailRules&quot; placeholder=&quot;请输入邮箱地址&quot;&gt;&lt;/Validate-input&gt; Validate-input组件 123456//接收参数const props = defineProps&lt;&#123; rules?: RulesProp //自定义组件使用v-model需要用modelValue来接收参数 modelValue: string&#125;&gt;() props接收了，modelValue属性，类型string 12345678&lt;input class=&quot;form-control&quot; :class=&quot;&#123; &#x27;is-invalid&#x27;: inputRef.error &#125;&quot; :value=&quot;modelValue&quot; @blur=&quot;validateInput&quot; @input=&quot;updateValue&quot; v-bind=&quot;$attrs&quot;/&gt; 设置了自定义事件用于更新value 12345678//手动更新valueconst updateValue = (e: Event) =&gt; &#123; //HTMLInputElement输入元素类型 let targetValue = (e.target as HTMLInputElement).value //更新文本框的值 inputRef.val = targetValue emit(&#x27;update:modelValue&#x27;, targetValue)&#125; 因此实现v-model属性 3. rules属性 接收参数 type：校验类型，requied | email | range message min：至少几位 max：至多几位 抽象验证逻辑 validate-input组件 12345678//数组类型export type RulesProp = RuleProp[]//接收参数const props = defineProps&lt;&#123; rules?: RulesProp //自定义组件使用v-model需要用modelValue来接收参数 modelValue: string&#125;&gt;() 参数接收rules是个数组 1234567//定义表单的数据const inputRef = reactive(&#123; //如果为空 val: props.modelValue || &#x27;&#x27;, error: false, //表单验证是否通过 message: &#x27;&#x27; //错误信息&#125;) 定义表单的数据 1234567891011121314151617181920212223242526272829303132333435363738//定义事件const validateInput = () =&gt; &#123; //定义邮箱的正则 let emailReg = /^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]&#123;2,4&#125;$/ //如果传过来的有验证的话 if (props.rules) &#123; //every方法 遍历全部数组只有全部满足条件才会返回true， 只要有一个false停止遍历 let allRulePassed = props.rules.every(rule =&gt; &#123; let passed = true //消息赋值 类型断言 inputRef.message = rule.message as string //switch选择对应type类型错误进行校验 switch (rule.type) &#123; case &#x27;required&#x27;: if (inputRef.val.trim() === &#x27;&#x27;) &#123; passed = false &#125; break case &#x27;email&#x27;: if (!emailReg.test(inputRef.val)) &#123; passed = false &#125; break case &#x27;range&#x27;: passed = validateRange(rule.min, rule.max) break &#125; return passed &#125;) //allRulePassed为false表示通过 //所以Input.error表示错误应该为true inputRef.error = !allRulePassed return allRulePassed &#125; return true&#125; 定义校验事件 满足全部rules校验才可以通过，因此用到es6数组方法，every只有全部项都为true才会遍历全部返回true，只要有一个项结果为false，就会停止遍历 message校验信息赋值给inputRef.message 利用swicth case语句，选择对应的type类型进行校验 需要充分考虑到所有情况，通过passed为true，未通过为fasle range长度校验，由于情况较多，单独封装一个函数去校验 &#96;&#96;&#96;ts&#x2F;&#x2F;校验长度const validateRange &#x3D; (min: RangeProp | undefined, max: RangeProp | undefined) &#x3D;&gt; { let passed &#x3D; true &#x2F;&#x2F;1. 如果min 存在 ,max不存在 if (min &amp;&amp; !max) {inputRef.message &#x3D; min.messagepassed &#x3D; !(inputRef.val.length &lt; min.length) } &#x2F;&#x2F;2. min不在, max在 if (!min &amp;&amp; max) {inputRef.message &#x3D; max.messagepassed &#x3D; !(inputRef.val.length &gt; max.length) } &#x2F;&#x2F;3. min在 max在 if (min &amp;&amp; max) {&#x2F;&#x2F;若小于if (inputRef.val.length &lt; min.length) { passed &#x3D; false inputRef.message &#x3D; min.message}&#x2F;&#x2F;若大于if (inputRef.val.length &gt; max.length) { passed &#x3D; false inputRef.message &#x3D; max.message} } return passed}123456789101112131415161718192021 ![image-20230909212538049](https://awesomeboy.oss-cn-chengdu.aliyuncs.com/img/202309092125082.png)* 模板中，根据passed的值，动态绑定未通过的样式### 4. 默认属性`validate-input组件````html &lt;div class=&quot;validate-input-container pb-3&quot;&gt; &lt;input class=&quot;form-control&quot; :class=&quot;&#123; &#x27;is-invalid&#x27;: inputRef.error &#125;&quot; :value=&quot;modelValue&quot; @blur=&quot;validateInput&quot; @input=&quot;updateValue&quot; v-bind=&quot;$attrs&quot; /&gt; &lt;span v-if=&quot;inputRef.error&quot; class=&quot;invalid-feedback&quot;&gt;&#123;&#123; inputRef.message &#125;&#125;&lt;/span&gt; &lt;/div&gt; 父组件 123456&lt;Validate-input v-model=&quot;loginParams.password&quot; :rules=&quot;passwordRules&quot; type=&quot;password&quot; placeholder=&quot;请输入密码&quot;&gt;&lt;/Validate-input&gt; 通过显示绑定attrs，使得自定义组件可以使用默认属性 在ValidateInput组件中，可以通过$attrs属性将type属性将被传递到组件的根元素上 可以在父组件中灵活地传递任何HTML属性给ValidateInput组件，使它更加通用和可配置 四：封装Validate-Form组件 事件 form-submit：点击提交触发的事件，回调参数result是布尔值，表示该表单是否通过了校验 1. form-submit事件 当点击提交时，要去验证该表单是否通过了校验，就需要一个个将表单项进行校验，只要一个没通过就返回false，只有全部通过返回true 收集全部表单项校验函数 可以通过将所有表单项的校验函数都添加到一个数组中，然后最终通过every方法遍历是否全部通过 收集 安装mitt并使用，监听事件 1npm install mitt --save 全局挂载 main.ts 123import mitt from &#x27;mitt&#x27;//对外暴露全局事件总线实例export const bus = mitt() ValidateForm组件中使用 12345678910111213141516171819202122232425262728293031&lt;script setup lang=&quot;ts&quot;&gt;import &#123; onUnmounted, reactive &#125; from &#x27;vue&#x27;import &#123; bus &#125; from &#x27;@/main&#x27;const emits = defineEmits([&#x27;form-submit&#x27;])//点击事件//定义函数类型type ValidateFunc = () =&gt; boolean//定义类型//定义接收的函数数组const funcArr = reactive&lt;ValidateFunc[]&gt;([])//测试回调const callback = (func: ValidateFunc) =&gt; &#123; //将每个校验函数加入数组 funcArr.push(func)&#125;//订阅事件bus.on(&#x27;form-item-created&#x27;, callback as ValidateFunc)//提交按钮触发事件const submitForm = () =&gt; &#123; const result = funcArr.map(func =&gt; func()).every(result =&gt; result) // 触发提交事件 //遍历funcArr中的每个校验函数 emits(&#x27;form-submit&#x27;, result)&#125;onUnmounted(() =&gt; &#123; // 移除订阅 bus.off(&#x27;form-item-created&#x27;, callback as ValidateFunc)&#125;)&lt;/script&gt; 定义函数类型，返回值为空 利用泛型定义存放每个表单项校验函数存放的数组 订阅事件，在组件卸载的时候再取消订阅 ValidateInput组件中 组件挂载的时候，就直接触发自定义事件，然后将每一项的校验函数传递给ValidateForm组件中 Validate-Form组件 然后接受ValidateInput组件传递过来的校验函数，一个个加入到数组中 在submitForm事件中，遍历数组，不能直接使用every方法，因为只要一个不通过就不进行后面的校验，这是不满足我们的需求的 可以看到下面的错误实例，密码原本也是不通过校验的，但是every方法直接在第一个校验失败结束遍历了 因此先利用map函数，先使得每个校验函数都执行，结束后返回一个新的数组存放校验函数的返回值，再通过every遍历数组 最后触发自定义事件，将结果传递给父组件中 父组件 1&lt;Validate-Form @form-submit=&quot;submitForm&quot; ref=&quot;validateFormRef&quot;&gt; 123const submitForm = (result: boolean) =&gt; &#123; console.log(result)&#125; 提交表单元素后清空表单值具体逻辑跟校验差不多 Validate-Form组件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;script setup lang=&quot;ts&quot;&gt;import &#123; onUnmounted, reactive &#125; from &#x27;vue&#x27;import &#123; bus &#125; from &#x27;@/main&#x27;const emits = defineEmits([&#x27;form-submit&#x27;])//点击事件//定义函数类型type ValidateFunc = () =&gt; boolean//定义清空Input函数类型type clearInputsFunc = () =&gt; void//定义类型//定义接收的函数数组const funcArr = reactive&lt;ValidateFunc[]&gt;([])//定义接收用于清空的函数数组const clearFuncArr = reactive&lt;clearInputsFunc[]&gt;([])//测试回调const callback = (func: ValidateFunc) =&gt; &#123; //将每个校验函数加入数组 funcArr.push(func)&#125;//事件回调const clearInputFunc = (func: clearInputsFunc) =&gt; &#123; clearFuncArr.push(func)&#125;//绑定监听事件bus.on(&#x27;form-item-created&#x27;, callback as ValidateFunc)bus.on(&#x27;form-item-clear&#x27;, clearInputFunc as clearInputsFunc)//提交按钮触发事件const submitForm = () =&gt; &#123; const result = funcArr.map(func =&gt; func()).every(result =&gt; result) // 触发提交事件 //遍历funcArr中的每个校验函数 emits(&#x27;form-submit&#x27;, result) //遍历清空函数数组并依次并执行 //当校验通过时候才会清空input if (result) &#123; clearFuncArr.map(func =&gt; func()) &#125;&#125;onUnmounted(() =&gt; &#123; // 移除事件监听器 bus.off(&#x27;form-item-created&#x27;, callback as ValidateFunc) bus.off(&#x27;form-item-clear&#x27;, clearInputFunc as clearInputsFunc)&#125;)&lt;/script&gt; Validate-input组件 123456789101112131415onMounted(() =&gt; &#123; //直接把validateInput校验事件传递过去 bus.emit(&#x27;form-item-created&#x27;, validateInput) //直接触发事件先传入每个input的值 bus.emit(&#x27;form-item-clear&#x27;, clearInput)&#125;)//定义表单的数据const inputRef = reactive(&#123; //如果为空 val: props.modelValue || &#x27;&#x27;, error: false, //表单验证是否通过 message: &#x27;&#x27; //错误信息&#125;) 把清空表单数据的处理函数收集起来 最后利用map方法依次执行清除即可 五：演示和使用 在 vue template 中添加结构代码123456789101112131415161718192021&lt;Validate-Form @form-submit=&quot;submitForm&quot; ref=&quot;validateFormRef&quot;&gt; &lt;!-- 邮箱地址 --&gt; &lt;div class=&quot;mb-3&quot;&gt; &lt;label for=&quot;exampleInputEmail1&quot; class=&quot;form-label&quot;&gt;邮箱地址&lt;/label&gt; &lt;!-- 自定义组件Validate-input --&gt; &lt;Validate-input v-model=&quot;loginParams.email&quot; :rules=&quot;emailRules&quot; placeholder=&quot;请输入邮箱地址&quot;&gt;&lt;/Validate-input&gt; &lt;/div&gt; &lt;!-- 密码 --&gt; &lt;div class=&quot;mb-3&quot;&gt; &lt;label for=&quot;exampleInputPassword1&quot; class=&quot;form-label&quot;&gt;密码&lt;/label&gt; &lt;Validate-input v-model=&quot;loginParams.password&quot; :rules=&quot;passwordRules&quot; type=&quot;password&quot; placeholder=&quot;请输入密码&quot; &gt;&lt;/Validate-input&gt; &lt;/div&gt; &lt;template #submit&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary btn-block btn-large&quot;&gt;提交&lt;/button&gt; &lt;/template&gt;&lt;/Validate-Form&gt; 在 setup语法糖中添加数据12345678910111213141516171819202122//定义验证类型数据const emailRules: RulesProp = [ &#123; type: &#x27;required&#x27;, message: &#x27;电子邮箱地址不能为空&#x27; &#125;, &#123; type: &#x27;email&#x27;, message: &#x27;请输入正确的电子邮箱格式&#x27; &#125;]//定义密码验证类型数据const passwordRules: RulesProp = [ &#123; type: &#x27;required&#x27;, message: &#x27;密码不能为空&#x27; &#125;, &#123; type: &#x27;range&#x27;, min: &#123; message: &#x27;你的密码至少包括6位,不能含有空格&#x27;, length: 6 &#125;, max: &#123; message: &#x27;你的密码至多15位,不能含有空格&#x27;, length: 15 &#125; &#125;]//监听结果const submitForm = (result: boolean) =&gt; &#123; console.log(result)&#125; Validate-Form属性和事件 form-submit： 类型：事件 默认：- 说明：回调参数 (result: boolean) &#x3D;&gt; void, result 代表是否通过了验证 Validate-Input属性和事件 rules 类型：array 默认：- 说明： 单个输入框的验证类型，可以传入包含特定对象的数组, 详情可见上面示例代码 tag 类型：input | textarea 默认：input 说明： 根节点类型 v-model 类型： string 默认：- 说明： 支持 v-model，请对响应式数据","categories":[{"name":"Vue","slug":"Vue","permalink":"http://awesomeboy.cn/categories/Vue/"}],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"http://awesomeboy.cn/tags/Vue3/"},{"name":"TS","slug":"TS","permalink":"http://awesomeboy.cn/tags/TS/"},{"name":"组件封装","slug":"组件封装","permalink":"http://awesomeboy.cn/tags/%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85/"}],"author":"awesomeboy"},{"title":"闭包","slug":"闭包","date":"2023-09-08T11:02:18.000Z","updated":"2023-09-08T14:29:41.866Z","comments":true,"path":"2023/09/08/闭包/","link":"","permalink":"http://awesomeboy.cn/2023/09/08/%E9%97%AD%E5%8C%85/","excerpt":"","text":"一：什么是闭包 闭包是一个函数和其词法环境的组合 换个意思来说，闭包可以让开发者可以从函数内部访问到外部函数的作用域 在JS中，闭包会随着函数的创建而被同时创建 词法环境：主要分两个对象 用于管理变量函数和作用域的关系 环境记录：存储变量和函数声明的地方 对外部环境的引用：指向包含当前词法环境的外部词法环境的引用。这使得内部环境可以引用外部环境的变量。这种引用关系形成了作用域链 词法环境例子： 12345678910function init() &#123; var name = &quot;Mozilla&quot;; // name 是一个被 init 创建的局部变量 function displayName() &#123; // displayName() 是内部函数，一个闭包 alert(name); // 使用了父函数中声明的变量 &#125; displayName();&#125;init(); 执行init（）函数后，可以成功突出name变量的值，displayName函数的词法作用域可以引用外部Init函数词法作用域中的name变量 闭包例子: 1234567891011function makeFunc() &#123; var name = &quot;Mozilla&quot;; function displayName() &#123; alert(name); &#125; return displayName;&#125;var myFunc = makeFunc();myFunc(); 执行makeFunc函数，创建makeFunc函数，在之前displayName函数之前将该函数返回，myFunc变量是displayName函数的实例 makeFunc函数创建的局部变量name，在displayName函数中被引用 myFunc维持了displayName函数的词法环境的一个引用，使得makeFunc函数在执行结束后，变量name仍然可用 二：使用场景 创建私有变量 延长变量的生命周期 如果在执行上下文中创建的函数是一个闭包，并且在闭包中引用了外部词法环境的变量，那么该词法环境不会在执行上下文销毁后立即被销毁。相反，词法环境会被保留，直到不再有任何引用指向闭包或相关的词法环境。这是因为闭包需要持续访问外部变量，所以相关的词法环境不能被销毁。 事件处理12345678910111213function makeSizer(size) &#123; return function() &#123; document.body.style.fontSize = size + &#x27;px&#x27;; &#125;;&#125;var size12 = makeSizer(12);var size14 = makeSizer(14);var size16 = makeSizer(16);document.getElementById(&#x27;size-12&#x27;).onclick = size12;document.getElementById(&#x27;size-14&#x27;).onclick = size14;document.getElementById(&#x27;size-16&#x27;).onclick = size16; 使用闭包创建和分配事件处理函数 makeSizer函数创建闭包，makeSizer返回一个匿名函数，并接收一个参数size，匿名函数捕获了外部函数的size变量，使得即使makeSizer函数执行结束后，也使得内部函数可以访问外部size变量 事件处理函数内部执行，当用户点击链接时，与链接相关的事件处理函数（闭包）被触发。这些函数内部访问了它们创建时捕获的字体大小 相比将事件处理函数直接赋值给onclick属性的区别 在作用域和数据封装方面，事件处理函数被封装到一个自包含的作用域中，它可以通过捕获外部函数的size变量，而避免将该变量引入到全局作用域中，避免全局变量污染。直接设置事件处理函数，是在全局作用域去设置事件处理函数，可能会导致全局命名函数的命名冲突，和污染全局变量 动态性和复用性：直接设置事件处理函数想要设置不同的字体大小需要设置三个不同的事件处理函数，而闭包实现，可以通过传递不同的size参数，然后由事件处理函数捕获外部size值进行操作赋值 使用闭包模拟私有方法JS可以通过闭包来模拟私有方法，即该私有属性只能被该类上的其余方法调用，而无法被外界直接使用 这种方式也称为模块化 1234567891011121314151617181920212223242526272829303132function Counter ()&#123; // 私有变量 var count = 0; // 私有方法 function increment () &#123; count++; &#125; // 公共方法，可以访问私有方法和私有变量 return &#123; getCount: function () &#123; return count; &#125;, incrementAndReturnCount: function () &#123; increment(); return count; &#125; &#125;&#125;var myCounter = new Counter();console.log(myCounter.getCount()); // 输出: 0console.log(myCounter.incrementAndReturnCount()); // 输出: 1console.log(myCounter.getCount()); // 输出: 1console.log(myCounter.count); //输出: undefined 通过闭包模拟私有方法 在Counter构造函数内部创建count私有变量和increment私有方法 通过在Counter函数中返回两个公共方法getCount和incrementAndReturnCount方法，通过闭包，getCount的词法环境可以引入外部Counter的词法环境的变量 因此外部函数只能通过公共方法间接访问私有方法和修改私有属性 以这种方式使用闭包，提供了许多与面向对象编程相关的好处 —— 特别是数据隐藏和封装。 在循环中创建闭包 该案例想要实现，当三个不同的文本框获得光标时候，触发事件显示对应三个不同的文本内容 12345&lt;p id=&quot;help&quot;&gt;Helpful notes will appear here&lt;/p&gt;&lt;p&gt;E-mail: &lt;input type=&quot;text&quot; id=&quot;email&quot; name=&quot;email&quot; /&gt;&lt;/p&gt;&lt;p&gt;Name: &lt;input type=&quot;text&quot; id=&quot;name&quot; name=&quot;name&quot; /&gt;&lt;/p&gt;&lt;p&gt;Age: &lt;input type=&quot;text&quot; id=&quot;age&quot; name=&quot;age&quot; /&gt;&lt;/p&gt; 123456789101112131415161718192021function showHelp(help) &#123; document.getElementById(&quot;help&quot;).innerHTML = help;&#125;function setupHelp() &#123; var helpText = [ &#123; id: &quot;email&quot;, help: &quot;Your e-mail address&quot; &#125;, &#123; id: &quot;name&quot;, help: &quot;Your full name&quot; &#125;, &#123; id: &quot;age&quot;, help: &quot;Your age (you must be over 16)&quot; &#125;, ]; for (var i = 0; i &lt; helpText.length; i++) &#123; var item = helpText[i]; document.getElementById(item.id).onfocus = function () &#123; showHelp(item.help); &#125;; &#125;&#125;setupHelp(); 在该代码中出现错误，三个文本框显示的都是同一个内容 发现错误： 在setupHelp函数中，想要循环给三个文本框添加三个不同的事件，用var关键字声明item变量，由于var声明的变量具体变量提升特性，导致item变量的作用域是函数作用域，这会使得最终三个文本框的事件处理函数中的item指向的是同一个item变量，由于最终item变量值指向helpText的最后一个内容，所以三个文本框显示的是同一个内容 使用匿名闭包处理 123456789101112for (var i = 0; i &lt; helpText.length; i++) &#123; (function () &#123; var item = helpText[i]; // console.log(&#x27;item = &#x27; + item.help); document.getElementById(item.id).onfocus = function () &#123; console.log(&#x27;x&#x27;); showHelp(item.help); &#125;; &#125;)()&#125; 通过匿名闭包函数，将每次迭代的item变量通过匿名闭包函数包裹起来，这个闭包函数会立即执行，因此每次迭代都会产生独立的词法环境用于存储item的副本，避免了共享的问题 文本框的 onfocus 事件处理函数被设置为一个闭包函数。这个闭包函数可以访问自己的局部作用域，因此它能够正确地引用其所关联的 item 变量，显示正确的帮助文本。 onfous事件接收一个闭包 12345678910111213141516171819202122function makeHelpCallback (help)&#123; return function () &#123; console.log(help); showHelp(help); &#125;;&#125;function setupHelp ()&#123; var helpText = [ &#123; id: &quot;email&quot;, help: &quot;Your e-mail address&quot; &#125;, &#123; id: &quot;name&quot;, help: &quot;Your full name&quot; &#125;, &#123; id: &quot;age&quot;, help: &quot;Your age (you must be over 16)&quot; &#125;, ]; for (var i = 0; i &lt; helpText.length; i++) &#123; var item = helpText[i]; document.getElementById(item.id).onfocus = makeHelpCallback(item.help); &#125;&#125; makeHelpCallback 函数接受一个参数 help，然后返回一个新的函数，这个新函数就是回调函数。这个回调函数的作用是在文本框获得焦点时显示相应的帮助文本。 当在循环中调用 makeHelpCallback(item.help) 时，它会根据传递给它的 help 参数的值，创建一个独立的回调函数。这个回调函数“记住”了它创建时的 help 参数的值。 因为每次循环迭代都会调用 makeHelpCallback，所以每次迭代都会创建一个新的回调函数，而且这些回调函数之间是相互独立的，它们没有共享相同的内部状态。 当某个文本框获得焦点时，对应的独立回调函数会执行。这个回调函数使用自己“记住”的 help 参数的值，来显示正确的帮助文本。由于每个回调函数都有自己独立的 help 参数，所以它们能够正确地显示不同的帮助文本，而不会混淆或共享数据。 使用let声明item变量 12345678for (var i = 0; i &lt; helpText.length; i++) &#123; var item = helpText[i]; document.getElementById(item.id).onfocus = function () &#123; console.log(&#x27;x&#x27;); showHelp(item.help); &#125;;;&#125; let作用域是块级作用域，每一次迭代都会声明不同的item变量，因此每个 onfocus 事件处理函数都捕获了自己迭代中的 item 值","categories":[{"name":"JS","slug":"JS","permalink":"http://awesomeboy.cn/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://awesomeboy.cn/tags/JS/"}],"author":"awesomeboy"},{"title":"LeetCode-17-电话号码的字母组合","slug":"LeetCode-17-电话号码的字母组合","date":"2023-09-08T08:13:37.000Z","updated":"2023-09-08T08:22:38.627Z","comments":true,"path":"2023/09/08/LeetCode-17-电话号码的字母组合/","link":"","permalink":"http://awesomeboy.cn/2023/09/08/LeetCode-17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/","excerpt":"","text":"一：题目描述：给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 二：示例与提示示例 1:12输入：digits = &quot;23&quot;输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;] 示例 2:12输入：digits = &quot;&quot;输出：[] 示例 3:12输入：digits = &quot;2&quot;输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;] 提示： 0 &lt;= digits.length &lt;= 4 digits[i] 是范围 [&#39;2&#39;, &#39;9&#39;] 的一个数字。 三：思路回溯 对于这种不同集合之间的组合，一开始会去想着，两个集合用两个for循环，三个集合三个for循环，但是我们无法去控制几个for循环，所以就想到用递归来控制for循环，再想到组合问题也需要用到回溯 利用一个数组存储对应的下标的字符 可以模拟构建一个树形结构 横向拓展由for循环控制对digit的遍历 纵向拓展由递归函数进行回溯 需要注意该题是两个集合的组合，不是一个集合的组合，考虑用index变量控制 四：代码 + 复杂度分析回溯+剪枝123456789101112131415161718192021222324252627282930313233/** * @param &#123;string&#125; digits * @return &#123;string[]&#125; */var letterCombinations = function(digits) &#123; //回溯 //用数组下标对应字符 const map = [&quot;&quot;, &quot;&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;,&quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;] if(digits.length === 0) return [] if(digits.length === 1) return map[digits].split(&quot;&quot;) //存储结果 const res = [] //单个结果 const path = [] const backtracking = (digits, index) =&gt; &#123; if(digits.length === path.length) &#123; //拼接起来 //ad console.log(path) res.push(path.join(&#x27;&#x27;)) return &#125; for(let i of map[digits[index]]) &#123; //[&#x27;a&#x27;, &#x27;d&#x27;] path.push(i) backtracking(digits, index + 1) path.pop() &#125; &#125; backtracking(digits, 0) return res&#125;; 时间复杂度：O(3 ^ m * 4 ^ m) 在最坏情况下，每个数字都映射到一个包含 3 或 4 个字符的集合（例如，数字 ‘2’ 对应 “abc”，数字 ‘7’ 对应 “pqrs”）。 空间复杂度: O(n + k) res 数组用于存储最终的字母组合，因此其空间复杂度是 O(k)，其中 k 表示可能的字母组合数量。 path 数组用于存储当前的组合路径，它的最大长度等于输入数字字符串的长度，因此其空间复杂度为 O(n)，其中 n 表示输入数字字符串的长度。","categories":[{"name":"算法","slug":"算法","permalink":"http://awesomeboy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"回溯","slug":"回溯","permalink":"http://awesomeboy.cn/tags/%E5%9B%9E%E6%BA%AF/"},{"name":"数组","slug":"数组","permalink":"http://awesomeboy.cn/tags/%E6%95%B0%E7%BB%84/"}],"author":"awesomeboy"},{"title":"LeetCode-77-组合","slug":"LeetCode-77-组合","date":"2023-09-08T04:15:29.000Z","updated":"2023-09-08T05:15:05.565Z","comments":true,"path":"2023/09/08/LeetCode-77-组合/","link":"","permalink":"http://awesomeboy.cn/2023/09/08/LeetCode-77-%E7%BB%84%E5%90%88/","excerpt":"","text":"一：题目描述：给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。 你可以按 任何顺序 返回答案。 二：示例与提示示例 1:12345678910输入：n = 4, k = 2输出：[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],] 示例 2:12输入：n = 1, k = 1输出：[[1]] 提示： 1 &lt;= n &lt;= 20 1 &lt;= k &lt;= n 三：思路回溯+剪枝 对于这类组合问题，可以将题目所描述的数组通过组合去构建一个树形结构 横向拓展是数组中的元素个数，从1到n 纵向拓展是深度，是对应元素的组合 通过不断的递归和回溯，在每一层次中构建组合，搜索到对应的叶子节点 图中每次搜索到了叶子节点，我们就找到了一个结果，将结果收集到结果集中即可 四：代码 + 复杂度分析回溯+剪枝12345678910111213141516171819202122232425262728293031323334/** * @param &#123;number&#125; n * @param &#123;number&#125; k * @return &#123;number[][]&#125; */var combine = function(n, k) &#123; //回溯 //确定回溯函数的参数 //存放最终所有结果的数组 const res = [] //path单层结果 const path = [] const backtracking = (n, k, index) =&gt; &#123; //终止条件 if(path.length === k) &#123; console.log(path) //收集结果 res.push([...path]) return &#125; //单层逻辑 for(let i = index; i &lt;= n - (k - path.length) + 1; i++) &#123; //路径收集 path.push(i) //递归 backtracking(n, k, i + 1) // console.log(path) //回溯 path.pop() &#125; &#125; backtracking(n, k, 1) return res&#125;; 时间复杂度：O(C（n， k）) 对于每个数字，我们有两个选择（包括或不包括），并且我们有k个选择（需要选择k个数字） 其中C(n, k)表示从n个元素中选择k个元素的组合数，也可以表示为二项式系数 空间复杂度：O(k + 2^n) 总的空间复杂度是 O(k + 2^n)，其中 k 反映了递归树的深度，而 2^n 反映了结果数组 res 的可能长度","categories":[{"name":"算法","slug":"算法","permalink":"http://awesomeboy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"回溯","slug":"回溯","permalink":"http://awesomeboy.cn/tags/%E5%9B%9E%E6%BA%AF/"},{"name":"数组","slug":"数组","permalink":"http://awesomeboy.cn/tags/%E6%95%B0%E7%BB%84/"}],"author":"awesomeboy"},{"title":"JS中执行上下文和执行栈是什么？","slug":"JS中执行上下文和执行栈是什么？","date":"2023-09-07T08:41:59.000Z","updated":"2023-09-07T10:31:51.077Z","comments":true,"path":"2023/09/07/JS中执行上下文和执行栈是什么？/","link":"","permalink":"http://awesomeboy.cn/2023/09/07/JS%E4%B8%AD%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/","excerpt":"","text":"一：执行上下文 执行上下文是一种对js执行代码的环境的一种抽象，只要js在执行中，那它一定是运行在执行上下文中 执行上下文的类型 全局执行上下文：全局执行上下文是在程序启动时创建的，它包含全局范围定义的变量和函数。在浏览器中，通常是在页面加载时候创建的，它是在页面整个生命周期中都存在的。 函数执行上下文：存在无数个函数执行上下文，但是只有函数被调用时候才会创建函数执行上下文。函数执行上下文包含函数作用域范围内的变量，函数参数，函数和作用域链。 eval执行上下文： 指的是运行在 eval 函数中的代码，很少用而且不建议使用 示例 二：生命周期执行上下文的生命周期为：创建阶段 —&gt; 执行阶段 —&gt; 销毁阶段 2.1 创建阶段 创建阶段：在代码执行之前，会进行对执行上下文的创建 全局执行上下文的创建：在整个程序启动时候，会创建全局执行上下文，其中包含全局函数，全局变量的创建、 函数执行上下文的创建：在函数被调用时，在函数执行前会创建函数执行上下文，其中会构建局部变量，局部函数和作用域链 具体包含三件事 ThisBinding：this的绑定 LexicalEnvironment（词法环境）：创建词法环境 VariableEnvironment（变量环境）：创建变量环境 执行上下文对象 伪代码 123456789//执行上下文对象const executionContext = &#123; //确定this值 ThisBindings = &#123; .....&#125;, //创建词法环境 LexicalEnvironment = &#123; ....&#125;, //创建变量环境 VariableEnvironment = &#123; ....&#125;,&#125; ThisBinding this 的值是在执行时（运行时）确定的，而不是在执行上下文创建时确定的。这意味着 this 的绑定是动态的，取决于代码的实际执行情况。 词法环境 词法环境（Lexical Environment）是 JavaScript 中的一个重要概念，用于管理变量和函数的词法作用域 环境记录（Environment Record）：环境记录是一个存储变量和函数声明的地方。它可以看作是一个字典或映射，将标识符（如变量名、函数名）映射到对应的值。环境记录有以下两种主要类型： Declarative Environment Record（声明式环境记录）： 用于存储变量声明、函数声明等。这种记录可以包含诸如函数的参数、局部变量、函数声明等。 Object Environment Record（对象环境记录）： 用于与具体的对象相关联，典型的例子是与全局对象或某个特定对象的属性相关联。在这种记录中，标识符会映射到对象的属性上。 1234567891011121314151617GlobalExectionContext = &#123; // 全局执行上下文 LexicalEnvironment: &#123; // 词法环境 EnvironmentRecord: &#123; // 环境记录 Type: &quot;Object&quot;, // 全局环境 // 标识符绑定在这里 outer: &lt;null&gt; // 对外部环境的引用 &#125; &#125;FunctionExectionContext = &#123; // 函数执行上下文 LexicalEnvironment: &#123; // 词法环境 EnvironmentRecord: &#123; // 环境记录 Type: &quot;Declarative&quot;, // 函数环境 // 标识符绑定在这里 // 对外部环境的引用 outer: &lt;Global or outer function environment reference&gt; &#125; &#125; 在创建执行上下文的时候，会对不同的执行上下文对象的词法环境类型进行记录 全局执行上下文的词法环境就是Object Environment Record，对象环境记录 函数执行上下文的词法环境就是Declarative Environment Record，声明式环境记录 变量环境 变量环境实际上是词法环境的一个子集 词法环境用于收集存储函数的声明和变量（let和const）的绑定 变量环境用于存储变量（var）的绑定 伪代码 12345678910 let a = 10 const b = 100 var c = 20 function sum (number1, numebr2) &#123; var res = 0 return res + number1 + number2 &#125;c = sum(20, 30) 执行上下文对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849GlobalExectionContext = &#123; ThisBinding: &lt;Global Object&gt;, LexicalEnvironment: &#123; // 词法环境 EnvironmentRecord: &#123; Type: &quot;Object&quot;, // 标识符绑定在这里 a: &lt; uninitialized &gt;, b: &lt; uninitialized &gt;, sum: &lt; func &gt; &#125; outer: &lt;null&gt; &#125;, VariableEnvironment: &#123; // 变量环境 EnvironmentRecord: &#123; Type: &quot;Object&quot;, // 标识符绑定在这里 c: undefined, &#125; outer: &lt;null&gt; &#125; &#125;FunctionExectionContext = &#123; ThisBinding: &lt;Global Object&gt;, //词法环境 LexicalEnvironment: &#123; EnvironmentRecord: &#123; Type: &quot;Declarative&quot;, // 标识符绑定在这里 Arguments: &#123;0: 20, 1: 30, length: 2&#125;, &#125;, outer: &lt;GlobalLexicalEnvironment&gt; &#125;, //变量环境 VariableEnvironment: &#123; EnvironmentRecord: &#123; Type: &quot;Declarative&quot;, // 标识符绑定在这里 res: undefined &#125;, outer: &lt;GlobalLexicalEnvironment&gt; &#125; &#125; 全局执行上下文对象 词法环境：收集变量let和const的绑定和函数提升 由于let和const定义的a和b变量，不会出现变量提升，所以类型为uninitialized(未初始化状态) sum出现函数提升 outer：由于是全局执行上下文，不会再有外部环境的引用，所以类型为Null 变量环境：收集var定义的变量的绑定，由于var定义的变量会出现变量提升，会被初始化为undefined 函数执行上下文对象 词法环境：也收集函数参数 变量类型：res变量提升 2.2 执行阶段 执行阶段：在创建完成之后，会进入执行阶段 代码逐行进行执行，条件判断，语句赋值等都会进行执行 如果遇到函数调用，则会创建函数执行上下文，并且将该函数的执行上下文压入到执行栈中 2.3 回收阶段 当代码块执行完毕或函数执行完毕时，执行上下文进入执行结束和销毁阶段。 在这个阶段，局部变量通常会被销毁，内存资源得到释放。 三：执行栈1234567891011let a = &#x27;Hello World!&#x27;;function first() &#123; console.log(&#x27;Inside first function&#x27;); second(); console.log(&#x27;Again inside first function&#x27;);&#125;function second() &#123; console.log(&#x27;Inside second function&#x27;);&#125;first();console.log(&#x27;Inside Global Execution Context&#x27;); 执行上下文的创建和销毁是一个动态的过程，由 JavaScript 引擎负责管理。执行上下文的栈结构（调用栈）用于跟踪代码的执行顺序，并确保上下文按照正确的顺序进入和离开。这种生命周期管理有助于确保变量的作用域、函数的调用顺序和内存资源的释放都得以正确执行。","categories":[{"name":"JS","slug":"JS","permalink":"http://awesomeboy.cn/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://awesomeboy.cn/tags/JS/"}],"author":"awesomeboy"},{"title":"LeetCode-165-比较版本号","slug":"LeetCode-165-比较版本号","date":"2023-09-04T02:46:10.000Z","updated":"2023-09-04T02:59:38.847Z","comments":true,"path":"2023/09/04/LeetCode-165-比较版本号/","link":"","permalink":"http://awesomeboy.cn/2023/09/04/LeetCode-165-%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7/","excerpt":"","text":"一：题目描述：给你两个版本号 version1 和 version2 ，请你比较它们。 版本号由一个或多个修订号组成，各修订号由一个 &#39;.&#39; 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。 比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 忽略任何前导零后的整数值 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 &lt; 1 。 返回规则如下： 如果 *version1* &gt; *version2* 返回 1， 如果 *version1* &lt; *version2* 返回 -1， 除此之外返回 0。 二：示例与提示示例 1:123输入：version1 = &quot;1.01&quot;, version2 = &quot;1.001&quot;输出：0解释：忽略前导零，&quot;01&quot; 和 &quot;001&quot; 都表示相同的整数 &quot;1&quot; 示例 2:123输入：version1 = &quot;1.0&quot;, version2 = &quot;1.0.0&quot;输出：0解释：version1 没有指定下标为 2 的修订号，即视为 &quot;0&quot; 示例 3:123输入：version1 = &quot;0.1&quot;, version2 = &quot;1.1&quot;输出：-1解释：version1 中下标为 0 的修订号是 &quot;0&quot;，version2 中下标为 0 的修订号是 &quot;1&quot; 。0 &lt; 1，所以 version1 &lt; version2 提示： 1 &lt;= version1.length, version2.length &lt;= 500 version1 和 version2 仅包含数字和 &#39;.&#39; version1 和 version2 都是 有效版本号 version1 和 version2 的所有修订号都可以存储在 32 位整数 中 三：思路split分割 利用split方法分割字符串为数组，[‘1’, ‘001’] 通过两个数组对应下标进行数值对比 通过paresInt将字符转换成数值，自然使得’001’和’01’数值上相同 但两个verison长度不同，可能version1的下标在version2中不存在，parseInt(undefined)为NAN 因此当取不出来对应值时，赋值为0 双指针 直接比较数字部分，不拆分字符串 当遇到.的时候，逻辑上把它们点之间的部分拆分 循环一遍，但当遇到点的时候，sum更新为0 这两个循环的结合使得我们能够在不拆分版本号字符串的情况下，直接在字符串上操作并比较数字部分。当两个版本号的相应部分都提取完毕并转换为数字后，就可以进行比较操作。 从头对应对比sum1和sum2值大小 四：代码 + 复杂度分析split分割1234567891011121314151617181920212223242526/** * @param &#123;string&#125; version1 * @param &#123;string&#125; version2 * @return &#123;number&#125; */var compareVersion = function(version1, version2) &#123; //split分割字符串为数组 let arr1 = version1.split(&#x27;.&#x27;) let arr2 = version2.split(&#x27;.&#x27;) //然后将对应下标的数值进行对比大小 //有‘01’和‘001’ 转换成数值对比 let max = Math.max(arr1.length, arr2.length) for(let i = 0; i &lt; max; i++) &#123; //如果不存在对应的数值 // parseInt(undefined)是NAN 就默认取值为0 let number1 = parseInt(arr1[i]) || 0 let number2 = parseInt(arr2[i]) || 0 console.log(number1, number2) if(number1 &gt; number2) &#123; return 1 &#125;else if(number2 &gt; number1)&#123; return -1 &#125; &#125; return 0&#125;; 时间复杂度： O（max(m, n)） 空间复杂度：O（n） 创建了两个额外的数组arr1和arr2来存储拆分结果 双指针1234567891011121314151617181920212223242526272829303132333435/** * @param &#123;string&#125; version1 * @param &#123;string&#125; version2 * @return &#123;number&#125; */var compareVersion = function(version1, version2) &#123; //双指针 //直接跳过.提取数值比大小 let i = 0 let j = 0 //外层循环用于 逻辑上分割.之间的部分 while(i &lt; version1.length || j &lt; version2.length) &#123; let sum1 = 0 let sum2 = 0 //内层循环用于将点之间的数值提取出来 加和直接进行相互比大小 while(i &lt; version1.length &amp;&amp; version1[i] !== &#x27;.&#x27;) &#123; sum1 = sum1 * 10 + parseInt(version1[i]) //指针右移 i++ &#125; while(j &lt; version2.length &amp;&amp; version2[j] !== &#x27;.&#x27;) &#123; sum2 = sum2 * 10 + parseInt(version2[j]) j++ &#125; if(sum1 &gt; sum2) &#123; return 1 &#125;else if(sum1 &lt; sum2) &#123; return -1 &#125; //跳过点号 i++ j++ &#125; return 0&#125;; 时间复杂度：O（max(n + m)） 空间复杂度：O(1)","categories":[{"name":"算法","slug":"算法","permalink":"http://awesomeboy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"http://awesomeboy.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"数组","slug":"数组","permalink":"http://awesomeboy.cn/tags/%E6%95%B0%E7%BB%84/"}],"author":"awesomeboy"},{"title":"TCP三次握手详解","slug":"TCP三次握手详解","date":"2023-09-03T09:14:35.000Z","updated":"2023-09-04T08:34:59.332Z","comments":true,"path":"2023/09/03/TCP三次握手详解/","link":"","permalink":"http://awesomeboy.cn/2023/09/03/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"TCP三次握手过程 第一次握手，客户端向服务器发送一个SYN标志置位1的TCP报文段。报文段包含了客户端的初始序列号client_isn，以及一些其它选项，SYN表示客户端希望与服务器建立连接 第二次握手，服务器接收到客户端发送的SYN报文段，需要确认连接请求。服务器向客户端发送一个ACK标志至1的TCP报文段，同时初始化自己的序列号ISN，将客户段的初始序列号+1（client_isn + 1）作为确认应答号填入，将SYN置位1，表示接受连接请求 第三次握手，客户端接收到服务器的响应后，发送一个ACK标志置位1的TCP报文段，将服务器的初始序列号 + 1（server_isn + 1）作为应答，该报文段不包含SYN标志，确认信号服务器连接已成功。 一旦完成三次握手，双方都处于 ESTABLISHED 状态，此时连接就已建立完成，客户端和服务端就可以相互发送数据了。 为什么不是两次握手？1. 三次握手确认双方的接收能力 在三次握手中才能互相确认客户端和服务端具有接收能力，以确保双方都具备发送和接收数据的能力 第一次握手，客户端向服务端发送请求，但服务端不能确定客户端是否具备接收数据能力 第二次握手，服务端确认了客户端的请求并告诉客户端自己准备好了，但客户端无法知道服务端是否准备好 只有第三次握手，客户端才能确认服务器的准备状态，从而确认服务端的准备状态，才可以开始传输数据 2. 避免已失效的连接请求 如果两次握手，第一次连接请求因为某种原因（网络阻塞后），由客户端重新发送一个请求给服务端 如果服务端先是接收到了第一个网络阻塞后的请求，于是向客户端发送了第二次握手，但服务端不知道这个是失效的连接，会直接建立连接发送数据，这时候就会造成服务器资源的浪费和安全问题 两次握手会造成消息滞留情况下，服务端重复接受无用的连接请求 SYN 报文，而造成重复分配资源。 3. 同步双方初始序列号 TCP连接三次握手中，需要客户端和服务端在握手过程中，交换自己的初始序列号，这些初始序列号用于标识每个TCP报文段的数据，以确保数据的有序传输和可靠接收 接收方可以通过序列号去除重复的数据 接收方可以通过序列号进行有序接收 可以标识发送的数据哪些已被对方接受，通过确认ACK报文中的确认号（ACK Num）可知道， 为什么不是四次握手？ 三次握手就已经初始化双方的序列号和确认号，就可以确保数据在两个方向上进行传输。 如果采用四次握手，会给通信增加了延迟，还可能引入不必要的复杂性。","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://awesomeboy.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"TCP","slug":"TCP","permalink":"http://awesomeboy.cn/tags/TCP/"}],"author":"awesomeboy"},{"title":"LeetCode-904-水果成篮","slug":"LeetCode-904-水果成篮","date":"2023-09-03T08:32:17.000Z","updated":"2023-09-03T08:55:04.078Z","comments":true,"path":"2023/09/03/LeetCode-904-水果成篮/","link":"","permalink":"http://awesomeboy.cn/2023/09/03/LeetCode-904-%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE/","excerpt":"","text":"一：题目描述：你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。 你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果： 你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。 你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。 一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。 给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。 二：示例与提示示例 1:123输入：fruits = [1,2,1]输出：3解释：可以采摘全部 3 棵树。 示例 2:1234输入：fruits = [0,1,2,2]输出：3解释：可以采摘 [1,2,2] 这三棵树。如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。 示例 3:1234输入：fruits = [1,2,3,2,2]输出：4解释：可以采摘 [2,3,2,2] 这四棵树。如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。 示例 4:123输入：fruits = [3,3,3,1,2,1,1,2,3,3,4]输出：5解释：可以采摘 [1,2,1,1,2] 这五棵树。 提示： 1 &lt;= fruits.length &lt;= 105 0 &lt;= fruits[i] &lt; fruits.length 三：思路暴力求解法 两层循环遍历，找到所有情况 外层循环控制起始位置 内层循环控制终止位置 两层嵌套，找到满足小于等于两种水果的所有情况，然后返回最大长度 该结果会超时 滑动窗口 当出现第三种水果时候，窗口应该缩小，直到满足还是小于等于两种水果的情况 当满足小于等于两种情况时候，窗口自动扩大，右指针向右移动 使用map数据结构来对水果进行存储 set数据结构不行 set数据结构是无法实现的 因为set集合只会存在不同的元素，相同的元素无法存储，也无法存储每个元素出现的次数 无法记录该元素的次数，就无法正确地移动左指针，就无法正确的记录每个正常情况下的长度值 输入 1[3,3,3,1,2,1,1,2,3,3,4] 使用set数据结构存储水果数量时候，可以看到右指针是正确移动的，但是左指针只移动了一次 虽然前三个案例是可以通过 但出现多个重复水果时候，就会由于集合中无法记录不同水果出现的次数，导致无法正确移动左指针 导致长度计算出现问题 正确应该当出现3,1,2情况时，left指针已经移动到了最后一个3，但他还是在第一个3，所以只能使用map数据结构来存储元素次数 四：代码 + 复杂度分析暴力求解123456789101112131415161718192021/** * @param &#123;number[]&#125; fruits * @return &#123;number&#125; */var totalFruit = function(fruits) &#123; //暴力求解 if(fruits.length &lt;= 2) return fruits.length let result = -Infinity for(let i = 0; i &lt; fruits.length; i++) &#123; let set = new Set() for(let j = i; j &lt; fruits.length; j++) &#123; set.add(fruits[j]) if(set.size &lt;= 2) &#123; result = Math.max(result, j - i + 1) &#125;else &#123; break &#125; &#125; &#125; return result&#125;; 时间复杂度：O（n ^ 2） 空间复杂度：O（1） 滑动窗口1234567891011121314151617181920212223242526272829/** * @param &#123;number[]&#125; fruits * @return &#123;number&#125; */var totalFruit = function(fruits) &#123; //滑动窗口 let left = 0 let map = new Map() let result = -Infinity for(let right = 0; right &lt; fruits.length; right++) &#123; //利用map数据结构存储水果 map.set(fruits[right], (map.get(fruits[right]) || 0) + 1); //遇到第三类水果缩小窗口 while(map.size &gt; 2) &#123; //判断最左边水果的数量 如果为0直接删除 如果不为0 减一 map.set(fruits[left], map.get(fruits[left]) - 1) if(map.get(fruits[left]) == 0) &#123; map.delete(fruits[left]) &#125; //移动左指针 left++ &#125; //记录 result = Math.max(result, right - left + 1) console.log(result) &#125; // console.log(map) return result&#125;; 时间复杂度：O（n） 外层循环从 right = 0 遍历到 right = n - 1，其中 n 是输入数组 fruits 的长度。这一步的时间复杂度是 O(n) 内层循环是一个 while 循环，它会在窗口中水果种类数大于2时缩小窗口。在最坏情况下，内层循环会将窗口从右到左移动，因此最多会遍历一次整个数组。因此，内层循环的时间复杂度也是 O(n) 整体算法复杂度不是O（n ^ 2），因为这是因为这两个循环并不会同时遍历整个数组的所有元素，内层循环当满足条件小于等于2时候，内层while循环就不执行，一旦窗口中的水果种类数恢复到2以下，就会退出内层循环，内层 while 循环的最坏的时间复杂度也是 O(n)，但它并不会导致整体的算法复杂度为 O(n^2) 空间复杂度：O（1）","categories":[{"name":"算法","slug":"算法","permalink":"http://awesomeboy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"http://awesomeboy.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"数组","slug":"数组","permalink":"http://awesomeboy.cn/tags/%E6%95%B0%E7%BB%84/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"http://awesomeboy.cn/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"}],"author":"awesomeboy"},{"title":"LeetCode-88-合并两个有序数组","slug":"LeetCode-88-合并两个有序数组","date":"2023-09-03T07:15:46.000Z","updated":"2023-09-03T07:29:38.788Z","comments":true,"path":"2023/09/03/LeetCode-88-合并两个有序数组/","link":"","permalink":"http://awesomeboy.cn/2023/09/03/LeetCode-88-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/","excerpt":"","text":"一：题目描述：给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。 请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。 注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。 二：示例与提示示例 1:1234输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3输出：[1,2,2,3,5,6]解释：需要合并 [1,2,3] 和 [2,5,6] 。合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。 示例 2:1234输入：nums1 = [1], m = 1, nums2 = [], n = 0输出：[1]解释：需要合并 [1] 和 [] 。合并结果是 [1] 。 示例 3:12345输入：nums1 = [0], m = 0, nums2 = [1], n = 1输出：[1]解释：需要合并的数组是 [] 和 [1] 。合并结果是 [1] 。注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。 提示： nums1.length == m + n nums2.length == n 0 &lt;= m, n &lt;= 200 1 &lt;= m + n &lt;= 200 -109 &lt;= nums1[i], nums2[j] &lt;= 109 三：思路暴力求解法 把nums1后面0所占的位置直接让nums2填满，最后直接sort排序输出正就行 逆序双指针 利用两个数组中都是升序的特点 初始化三个指针 p1指向nums1的末尾 p2指向nums2的末尾 p指向两个合并数组的末尾 从后面往前面遍历nums1，数组，将较大的元素放在合并数组的末尾，并且移动相应的指针 当nums2的末尾大于nums1有效元素的末尾时候，就说明nums2的末尾是两个数组中最大的元素，放在合并数组的末尾 当nums1有效元素的末尾大于nums2的末尾时候，就说明此时该元素是最大元素，就放在p所值向合并的数组的位置 循环结束时，nums2可能还剩余数组，因为nums1有效元素的值可能都大于num2的元素，使得一直让nums1的元素移向nums2，p1指针不断前移，p2指针移动的少，最后只需要将p2的元素，根据p所指向复制过去就好 四：代码 + 复杂度分析暴力求解123456789101112131415161718/** * @param &#123;number[]&#125; nums1 * @param &#123;number&#125; m * @param &#123;number[]&#125; nums2 * @param &#123;number&#125; n * @return &#123;void&#125; Do not return anything, modify nums1 in-place instead. */var merge = function(nums1, m, nums2, n) &#123; //暴力求解 //把nums1后面0所占的位置直接让nums2填满 //最后直接sort排序输出正就行 for(let i = m, j = 0; i &lt; nums1.length; i++, j++) &#123; nums1[i] = nums2[j] &#125; return nums1.sort((a, b) =&gt; &#123; return a - b &#125;)&#125;; 时间复杂度：O(n log n) 一层循环遍历nums1，时间复杂度为O（n） 使用 sort 方法对整个 nums1 进行排序。sort 方法的时间复杂度通常是 O(n log n)，其中 n 是 nums1 的长度。 整体复杂度为O（n + n log(n)），主要时间开销来自于排序步骤，因此最终的时间复杂度主要由排序步骤决定，即为 O(n log n)。 空间复杂度：O（1） 逆序双指针123456789101112131415161718192021222324/** * @param &#123;number[]&#125; nums1 * @param &#123;number&#125; m * @param &#123;number[]&#125; nums2 * @param &#123;number&#125; n * @return &#123;void&#125; Do not return anything, modify nums1 in-place instead. */var merge = function(nums1, m, nums2, n) &#123; //逆序双指针 //利用两数组中各是升序特点 let p1 = m - 1 let p2 = n - 1 let p = m + n - 1 while(p1 &gt;= 0 &amp;&amp; p2 &gt;= 0) &#123; if(nums1[p1] &gt; nums2[p2]) &#123; nums1[p--] = nums1[p1--] &#125;else &#123; nums1[p--] = nums2[p2--] &#125; &#125; while(p2 &gt;= 0) &#123; nums1[p--] = nums2[p2--] &#125;&#125;; 时间复杂度：O（n + m） while循环中，时间复杂度是O（m + n），m和n分别是nums1和nums2的长度 空间复杂度：O（1）","categories":[{"name":"算法","slug":"算法","permalink":"http://awesomeboy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"http://awesomeboy.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"数组","slug":"数组","permalink":"http://awesomeboy.cn/tags/%E6%95%B0%E7%BB%84/"}],"author":"awesomeboy"},{"title":"LeetCode-3-无重复字符的最长子串","slug":"LeetCode-3-无重复字符的最长子串","date":"2023-09-03T06:16:36.000Z","updated":"2023-09-03T06:38:46.675Z","comments":true,"path":"2023/09/03/LeetCode-3-无重复字符的最长子串/","link":"","permalink":"http://awesomeboy.cn/2023/09/03/LeetCode-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/","excerpt":"","text":"一：题目描述：给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度 二：示例与提示示例 1:123输入: s = &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2:123输入: s = &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3:1234输入: s = &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 提示： 0 &lt;= s.length &lt;= 5 * 104 s 由英文字母、数字、符号和空格组成 三：思路暴力求解法 两层循环遍历字符串，找到所有的子串可能，返回子串长度 外层循环表示子串起始位置 内层循环J表示子串结束位置 利用set数据结构创造set集合，不断添加s[j]，元素，当未遇到set集合中有的，即是满足条件的子串，计算子串的最大长度 当遇到集合中有的直接break内层循环 滑动窗口 不断调整子序列的起始位置和终止位置，从而得到我们想要的结果 用一个for循环就达到了两层循环的效果 for循环应表示的是滑动窗口的终止位置 如果表示的是滑动窗口的起始位置，那么还需要一个变量去不断地向右去遍历，这样的逻辑与暴力求解没什么区别，所以不行 利用一个左指针i去表示子序列的起始位置 当遇到重复子串，就应该缩小窗口，即左指针向右移动 右指针有循环控制着，窗口扩大 缩小窗口，是先删除左指针的元素，再将左指针右移 四：代码 + 复杂度分析暴力求解1234567891011121314151617181920212223/** * @param &#123;string&#125; s * @return &#123;number&#125; */var lengthOfLongestSubstring = function(s) &#123; //暴力解法 if(s.length === 0) return false let result = -Infinity for(let i = 0; i &lt; s.length; i++) &#123; const set = new Set() for(let j = i; j &lt; s.length; j++) &#123; let char = s.charAt(j) if(!set.has(char))&#123; result = Math.max(result, j - i + 1) &#125;else &#123; break &#125; set.add(char) &#125; &#125; return result&#125;; 时间复杂度： 最坏时间复杂度为O（n ^ 2） 外层循环遍历整个字符串为n 内层循环表示从当前字符位置向右遍历整个字符串，最坏程度为n，即未遇到重复字符 但一般会遇到重复字符，所以内层循环一般遍历n &#x2F; 2 平均时间复杂度为 O ( n * n &#x2F; 2) -&gt; O (n ^ 2 &#x2F; 2) -&gt; O (n ^ 2) 空间复杂度：O（n） 在每次内层循环中，都会创建一个新的Set集合来存储字符，最坏情况下会创建n个字符实例 滑动窗口12345678910111213141516171819202122232425262728/** * @param &#123;string&#125; s * @return &#123;number&#125; */var lengthOfLongestSubstring = function(s) &#123; //滑动窗口 //缩小窗口 -- 当遇到含有该字符串的时候 //扩大窗口 -- 外层循环向右移动 if(s.length === 0) return 0 //左指针 let left = 0 let result = -Infinity const set = new Set() //一层循环 for(let right = 0; right &lt; s.length; right++) &#123; let char = s.charAt(right) while(set.has(char)) &#123; set.delete(s[left]) left++ &#125; set.add(char) result = Math.max(result, right - left + 1) console.log(result) console.log(s[right]) &#125; return result&#125;; 时间复杂度：O（n） 外层循环（for 循环）会执行 n 次，其中 n 是输入字符串 s 的长度。 内层循环（while 循环）的执行次数并不会累积到 n^2。虽然内层循环看起来是一个循环嵌套在另一个循环中，但每个字符只会被 left 指针移动一次。一旦字符在内层循环中被处理过，它不会再次被处理。因此，内层循环的总执行次数是 n，而不是 n^2。 空间复杂度：O（n）","categories":[{"name":"算法","slug":"算法","permalink":"http://awesomeboy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"http://awesomeboy.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"数组","slug":"数组","permalink":"http://awesomeboy.cn/tags/%E6%95%B0%E7%BB%84/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"http://awesomeboy.cn/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"}],"author":"awesomeboy"},{"title":"LeetCode-209-长度最小的子数组","slug":"LeetCode-209-长度最小的子数组","date":"2023-09-02T12:20:02.000Z","updated":"2023-09-03T06:32:23.096Z","comments":true,"path":"2023/09/02/LeetCode-209-长度最小的子数组/","link":"","permalink":"http://awesomeboy.cn/2023/09/02/LeetCode-209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/","excerpt":"","text":"一：题目描述： 给定一个含有 n 个正整数的数组和一个正整数 target 。 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。 二：示例与提示示例 1:123输入：target = 7, nums = [2,3,1,2,4,3]输出：2解释：子数组 [4,3] 是该条件下的长度最小的子数组。 示例 2:12输入：target = 11, nums = [1,1,1,1,1,1,1,1]输出：0 提示： 1 &lt;= target &lt;= 109 1 &lt;= nums.length &lt;= 105 1 &lt;= nums[i] &lt;= 105 三：思路暴力求解法 两层循环遍历数组，找到满足条件的所有子数组，再返回长度最小的数组的长度即可 外层循环控制起始位置 内层循环控制终止位置 滑动窗口 不断调整子序列的起始位置和终止位置，从而得到我们想要的结果 用一个for循环就达到了两层循环的效果 for循环应表示的是滑动窗口的终止位置 如果表示的是滑动窗口的起始位置，那么还需要一个变量去不断地向右去遍历，这样的逻辑与暴力求解没什么区别，所以不行 利用一个左指针i去表示子序列的起始位置 当窗口的值大于target了，窗口就需要向右移动了，即需要移动左指针使得缩小窗口 当不满足条件之后，即小于target之后，for循环的下次遍历，使得右指针向右移动 四：代码 + 复杂度分析暴力求解123456789101112131415161718192021222324252627/** * @param &#123;number&#125; target * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var minSubArrayLen = function(target, nums) &#123; //暴力枚举 //外层循环控制起始位置 //子数组长度存储 //时间复杂度为O(n ^ 2) let result = Infinity for(let i = 0; i &lt; nums.length; i++) &#123; //内层循环控制终止位置 let sum = 0 for(let j = i; j &lt; nums.length; j++) &#123; sum += nums[j] if(sum &gt;= target) &#123; //记录下标 result = Math.min(result, j - i + 1) break &#125; &#125; &#125; if(result === Infinity) return 0 return result&#125;; 时间复杂度：O（n ^ 2） 两层for循环嵌套 空间复杂度：O（1） 主要是辅助变量的存储，result，sum都为O（1） 滑动窗口12345678910111213141516171819202122232425262728/** * @param &#123;string&#125; s * @return &#123;number&#125; */var lengthOfLongestSubstring = function(s) &#123; //滑动窗口 //缩小窗口 -- 当遇到含有该字符串的时候 //扩大窗口 -- 外层循环向右移动 if(s.length === 0) return 0 //左指针 let left = 0 let result = -Infinity const set = new Set() //一层循环 for(let right = 0; right &lt; s.length; right++) &#123; let char = s.charAt(right) while(set.has(char)) &#123; set.delete(s[left]) left++ &#125; set.add(char) result = Math.max(result, right - left + 1) console.log(result) console.log(s[right]) &#125; return result&#125;; 时间复杂度：O（n） n是nums数组的长度，线性时间复杂度算法 空间复杂度：O（1）","categories":[{"name":"算法","slug":"算法","permalink":"http://awesomeboy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"http://awesomeboy.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"数组","slug":"数组","permalink":"http://awesomeboy.cn/tags/%E6%95%B0%E7%BB%84/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"http://awesomeboy.cn/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"}],"author":"awesomeboy"},{"title":"防抖和节流","slug":"防抖和节流","date":"2023-09-01T11:30:51.000Z","updated":"2023-09-01T11:59:08.995Z","comments":true,"path":"2023/09/01/防抖和节流/","link":"","permalink":"http://awesomeboy.cn/2023/09/01/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/","excerpt":"","text":"一： 防抖 防抖的主要思想是，当一个事件被触发后，延迟一段时间后再执行相应的操作，如果在这段时间内事件再次触发，就会取消之前的操作，并重新计时 防抖会等待一定的时间（称为防抖延迟），只有在该时间内没有新事件触发时才执行相应的操作。如果在延迟期间事件不断触发，计时会被重新开始，操作不会被执行。 应用场景 防抖通常用于以下情况： 处理用户输入，例如搜索框输入，可以等待用户停止输入一段时间后再进行搜索请求，以减少请求次数。 处理窗口大小调整事件，以避免在用户调整窗口大小时频繁触发事件。 处理按钮点击，以避免用户连续多次点击按钮造成意外的操作。 JS实现123456789101112131415161718192021//防抖function debounce (fn, delay)&#123; //设置一个定时器 let timer = 0 //返回一个函数 return function (...arguments) &#123; if (timer) &#123; //清除上一个定时器 clearTimeout(timer) &#125; //开启下一个定时器 timer = setTimeout(() =&gt; &#123; //透传 this 和 参数 fn.apply(this, arguments) &#125;, delay); &#125;&#125; 该函数有两个参数，fn待传入的原始函数即需要添加防抖的函数，delay设置的延迟时间 如果在延迟时间内有新事件触发，就会清除之前的定时器并重新设置新的定时器，以此来达到控制事件触发频率的效果 fn.apply(this, arguments);：当新的定时器触发时，会执行传递给 debounce 函数的原始函数 fn，并将之前捕获的参数 arguments 传递给它。apply 方法用于在指定的上下文（this）中执行函数，并传递一个参数数组。 二：节流 节流的主要思想是，在一段时间内，无论事件触发多少次，只执行一次相应的操作，然后再等待下一个时间段。 具体来说，节流会设置一个时间间隔，在这个时间间隔内，只有第一次触发事件会执行操作，之后的触发事件会被忽略，直到时间间隔过去，然后才会重新接受新的事件。 应用场景 控制滚动事件的触发频率，以提高性能，例如在实现无限滚动加载更多内容时。 控制鼠标移动事件的触发频率，以减少事件处理的负担。 防止用户在短时间内多次提交表单或点击按钮。 JS实现 时间戳结合定时器实现 1234567891011121314151617181920212223242526272829303132function throttle (func, delay)&#123; //定义上次执行的结束时间 let lastExecTime = 0; //定时器标识 let timeoutId; //返回函数 执行逻辑 return function (...args) &#123; //定义当前时间 const currentTime = Date.now(); //判断间隔时间是否小于delay延迟时间 if (currentTime - lastExecTime &lt; delay) &#123; if (timeoutId) &#123; //清除上次的定时器 clearTimeout(timeoutId); &#125; //开启定时器 timeoutId = setTimeout(() =&gt; &#123; //更新结束时间 lastExecTime = currentTime; func.apply(this, args); &#125;, delay); &#125; else &#123; //间隔时间大于延迟时间 可直接执行函数 lastExecTime = currentTime; func.apply(this, args); &#125; &#125;;&#125; 利用时间戳和定时器来实现一个更精准的节流函数 通过把控间隔时间和设置的延时时间，来判断，下次执行事件是否过了设置的延迟时间 若是还没过延迟时间，开启定时器，直到延迟时间过去再执行 若间隔时间大于延迟时间，直接执行事件","categories":[{"name":"JS","slug":"JS","permalink":"http://awesomeboy.cn/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://awesomeboy.cn/tags/JS/"}],"author":"awesomeboy"},{"title":"把一个数组旋转K步","slug":"把一个数组旋转K步","date":"2023-09-01T09:40:52.000Z","updated":"2023-09-01T09:51:39.216Z","comments":true,"path":"2023/09/01/把一个数组旋转K步/","link":"","permalink":"http://awesomeboy.cn/2023/09/01/%E6%8A%8A%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E6%97%8B%E8%BD%ACK%E6%AD%A5/","excerpt":"","text":"一：题目描述 定义一个函数，实现数组的旋转。如输入 [1, 2, 3, 4, 5, 6, 7] 和 key = 3， 输出 [5, 6, 7, 1, 2, 3, 4]考虑时间复杂度和性能 二：示例与提示示例 1:12输入：arr = [1, 2, 3, 4, 5, 6, 7]， k = 3输出：[5, 6, 7, 1, 2, 3, 4] 示例 2:12输入：arr = [1, 2, 3, 4, 5, 6, 7]， k = -3输出：[5, 6, 7, 1, 2, 3, 4] 三：思路思路一： 将数组arr，每次pop最后一个元素，然后unshift添加到第一个元素 思路二： 利用slice方法，将数组根据k进行分割成两个数组，然后重新concat连接 四：代码思路一：12345678910111213function rotate1(arr: number[], k: number): number[] &#123; //判断空 if (!k || arr.length === 0) return arr //如果step大于数组本身长度 const step = Math.abs(k % arr.length) for (let i = 0; i &lt; step; i++) &#123; const n = arr.pop() if (n) &#123; arr.unshift(n) &#125; &#125; return arr&#125; 思路二：1234567891011function rotate2(arr: number[], k: number): number[] &#123; //判断空 if (!k || arr.length === 0) return arr //如果step大于数组本身长度 const step = Math.abs(k % arr.length) //使用concat const part1 = arr.slice(-step) const part2 = arr.slice(0, arr.length - step) const part3 = part1.concat(part2) return part3&#125; 五：复杂度分析思路一 时间复杂度：O（n ^ 2） 对arr数组的遍历为n次，同时unshift内置方法，将数组每个元素向后推移，也是为n次 空间复杂度：O （1） 思路二 时间复杂度：O（1） 空间复杂度：O （n）","categories":[{"name":"算法","slug":"算法","permalink":"http://awesomeboy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://awesomeboy.cn/tags/%E6%95%B0%E7%BB%84/"}],"author":"awesomeboy"},{"title":"TCP协议基础","slug":"TCP协议基础","date":"2023-08-29T09:07:01.000Z","updated":"2023-08-29T10:04:00.879Z","comments":true,"path":"2023/08/29/TCP协议基础/","link":"","permalink":"http://awesomeboy.cn/2023/08/29/TCP%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/","excerpt":"","text":"一： TCP协议是什么？ TCP协议是基于面向连接，可靠传输，基于字节流的传输层通信协议 1. 面向连接 TCP协议是一种面向连接的协议，意味着在双方在建立数据传输之前，需要进行一个逻辑上的连接，且是一对一的连接，这种连接的建立和维护使得数据可以在发送和接受中能够进行可靠和有序的传输 UDP协议是无连接协议，可以进行一对多的连接通信 2. 可靠传输 TCP可靠传输是基于以下几点机制达成的 连接的建立和终止：TCP在数据传输之前需要建立逻辑上的连接，在传输完成后会进行连接的断开，这样确保数据在开始时和结束时的完整性 流量控制： TCP使用滑动窗口机制来控制发送方的数据流量。接收方可以通知发送方它可以接受的数据量，以防止发送方发送过多的数据导致接收方缓冲区溢出 拥塞控制： TCP具有拥塞控制机制，可以在网络出现拥塞时降低数据发送速率，以避免网络拥塞问题进一步加剧 确认与重传机制：发送方向接收方发送数据，在一段时间内若为收到接受方的确认，会认为该数据在传输中丢失，会触发数据的重传机制。这确保了数据在丢失后仍会被重新发出 序列号与顺序控制：TCP会为每一个发送的数据段分配唯一的序列号，接收方会通过序列号将发送的数据片按重组成正确的顺序，从而避免了数据的乱序 校验和：TCP首部有个校验和控制 字段，用于检测数据是否在传输中被损坏或者修改 校验和的计算基于发送方的TCP首部内容，包括源端口、目标端口、序列号、确认号、控制位等等。这些字段的数值会被计算成一个校验和值，并附加在TCP首部中。接收方在接收到TCP首部后，会重新计算校验和并与传输过来的校验和值进行比较。如果两者不匹配，接收方可以推断数据在传输过程中发生了错误。 3. 字节流 字节流指的是在数据的传输中，数据被视为连续的字节序列，而不是离散的数据块 TCP并不关心应用程序中数据的分块结构，它只负责在发送方和接收方之间传输字节数据 这种字节流的特性使得TCP适用于各种应用，包括传输文件、网页内容、视频流等。应用程序可以在发送数据时将其分块，但在TCP层面，这些数据将会被重新组织成一个连续的字节流，然后在接收端按照顺序重新分块以供应用程序处理 二：TCP首部格式 源端口号（Source Port）：16位，指示发送方的应用程序使用的端口号。 目的端口号（Destination Port）：16位，指示接收方的应用程序期望使用的端口号。 序列号（Sequence Number）：32位，用于对TCP数据段进行编号，以便接收方按正确的顺序重组数据。 确认号（Acknowledgment Number）：32位，指示接收方期望下一个接收的数据的序列号，用于确认已经成功接收到的数据。 数据偏移（Data Offset）：4位，指示TCP头部的长度，以32位字（4字节）为单位计算。 控制位（Control Bits）：6位，包含了TCP控制信息，如SYN、ACK、FIN等标志位，用于控制连接的建立、数据传输和连接的释放等。 窗口大小（Window Size）：16位，指示发送方允许接收方缓存的字节数量，用于流量控制。 校验和（Checksum）：16位，用于检测TCP头部在传输过程中的错误。 紧急指针（Urgent Pointer）：16位，指示紧急数据的末尾位置，用于通知接收方需要紧急处理的数据。 选项和填充（Options and Padding）：TCP头部可包含选项字段和填充字段，用于扩展头部功能或填充字节，可变长度。 2.1 如何计算TCP首部长度？ 通过数据偏移控制字段计算 TCP首部的长度是通过数据偏移控制字段来表示的，其表示TCP数据段部分相较于整个TCP报文起始位置的偏移量大小，这个偏移量是以4字节单位计算的 所以 TCP首部的长度 &#x3D; 数据偏移控制字段的值 * 4字节 注意 尽量避免通过IP首部信息进行计算TCP负载数据长度 由于TCP和IP协议是两个独立的协议，在网络通信中各自负责不同的任务 TCP协议无法直接从IP首部中获取对应的数据 在传输过程中，应用程序会在TCP首部中的数据偏移字段和TCP数据段的长度中指示负载数据的实际长度 2.2 TCP目的端口号和IP目的地址 TCP首部中包含源端口和目的端口号字段，是16位的 IP首部中包含源地址和目的地址，是32位的 访问一个网址时，IP地址 和 对应端口号显示的并不是32位的和16位的二进制数，例如http: &#x2F;&#x2F; 127.0.0.1 : 5173 &#x2F; IP地址： 在IPv4协议中，IP地址是32位的，通常用四个8位的数字（0-255的范围）表示，每个数字之间使用点号（.）分隔 端口号： 端口号是16位的整数，用来标识应用程序或服务的通信端口。它可以是0到65535之间的值。例如，”:5173” 表示连接的目标端口号是5173。 实际的通信过程中，操作系统和网络设备会将IP地址和端口号转化为相应的二进制格式，以进行数据的传输和路由 2.3 什么是TCP连接？ 用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括 Socket、序列号和窗口大小称为连接。 TCP连接是一种虚拟的通信路径，用于在网络上的两台计算机之间传输数据 Socket： Socket是一种用于网络通信的抽象概念，它可以被看作是一个端点，用于标识网络中的一台计算机上的进程或应用程序。一个Socket由IP地址和端口号组成，形如”IP地址:端口号”。在TCP连接中，客户端和服务器分别使用Socket来识别彼此，建立连接，并进行数据的发送和接收。 序列号： TCP协议使用序列号来标识发送和接收的数据段。发送方为每个数据段分配一个唯一的序列号，接收方根据序列号来重新组装数据段，保证数据的顺序性。 窗口大小： 窗口大小是TCP流量控制的一部分，用于控制发送方发送数据的速率，以适应接收方的处理能力。窗口大小表示接收方还有多少可用的缓冲区空间来接受更多的数据。通过调整窗口大小，可以防止发送方过快地发送数据，导致接收方的缓冲区溢出。 三：IP协议和TCP协议联合工作 在网络传输中，通常同时使用IP协议和TCP协议进行工作的 IP协议负责将数据包在网络中从一个计算机传输到另一个计算机中 TCP协议负责在这个传输过程中，建立可靠的连接和可靠的数据传输 3.1 访问网站时的联合工作 IP协议和TCP协议通常是一起使用的，以实现在网络中的可靠数据传输。它们在不同层级上执行不同的任务，共同构成了网络通信的基础。 DNS解析：当我们键入网址，计算机会向DNS服务器，查询该域名的IP地址，涉及到IP协议的工作，来找到目标的IP地址 TCP建立连接：直到目标的IP地址，计算机会使用TCP协议与目标网站建立可靠连接。涉及到IP地址和端口连接的过程，确保你的计算机与目标网站可进行数据传输 数据传输：TCP建立连接后，要与目标网站进行数据传输，TCP协议负责将数据分割成数据段，并为每个数据段添加确认号，序列号，达成数据的可靠传输 IP传输：TCP将数据段交给IP协议，然后IP协议负责将数据段从你的计算机发送给目标的服务器，经过多个中间路由和网络设备 TCP数据重组：目标服务器通过IP协议获得数据段，通过TCP协议将数据段的按照序列号重组数据恢复正确顺序，获得原始的数据流 数据响应： 目标服务器通过TCP协议将响应数据发送回您的计算机，经过类似的过程。 四：UDP协议是什么 UDP（User Datagram Protocol）是一种在计算机网络中使用的传输层协议，与TCP一样属于传输层的两个主要协议之一。不同于TCP的面向连接特性，UDP是一种无连接的、简单的协议，它主要用于支持实时性要求高、对数据可靠性要求较低的应用。 无连接性： UDP协议不需要在通信开始之前建立连接，通信双方可以直接开始传输数据。这使得UDP的传输过程更加轻量和快速，但也导致了数据传输过程中的不可靠性。 不可靠性： UDP不提供数据的可靠传输，这意味着发送的数据包可能会在传输过程中丢失、重复、乱序等。UDP不执行像TCP那样的序列号和确认号机制，也不会进行自动重传。 简单： UDP头部相对较短，仅包含源端口、目的端口、长度和校验和等基本信息，这使得UDP在处理速度上更快。 实时性： 由于UDP的无连接性和不可靠性，它更适用于那些需要实时性、低延迟的应用，如实时音视频传输、在线游戏等。 广播和多播： UDP支持广播和多播，使得一个主机可以向多个目标主机发送相同的数据。 应用场景： 由于UDP的特性，它适用于那些对数据完整性和可靠性要求较低的应用，例如音频和视频流传输、DNS查询、实时通信等。 4.1 UDP首部格式 4.2 TCP和UDP的区别 连接性： TCP：是一种面向连接的协议，它在通信的开始和结束时都需要建立和终止连接。数据传输前需要建立连接，传输结束后需要释放连接。 UDP：是一种无连接的协议，它不需要事先建立连接或释放连接。每个UDP数据包都是独立的，它们之间没有直接的关系。 可靠性： TCP：提供可靠的数据传输。它通过确认、重传、序列号等机制确保数据的可靠性和顺序性，但这也导致了一些额外的开销。 UDP：不提供数据传输的可靠性保证。数据包在传输过程中可能丢失、重复或乱序，因此应用程序需要自行处理这些情况。 数据包大小： TCP：由于TCP有额外的头部信息用于管理连接、确认等，它的头部开销比较大。因此，对于较小的数据包，TCP的开销可能会相对较高。 UDP：UDP的头部开销相对较小，适用于传输较小的数据包。 流量控制和拥塞控制： TCP：具有流量控制和拥塞控制机制，以避免数据过载导致网络拥塞。这使得TCP更适合对网络质量要求较高的应用。 UDP：不具备流量控制和拥塞控制机制，数据传输的速率受限于应用程序的设计和网络的状况。 适用场景： TCP：适用于需要可靠传输、数据顺序和错误检测的应用，如网页浏览、文件下载等。 UDP：适用于实时性要求较高、且能容忍少量数据丢失的应用，如在线游戏、实时视频传输等。","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://awesomeboy.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"TCP","slug":"TCP","permalink":"http://awesomeboy.cn/tags/TCP/"}],"author":"awesomeboy"},{"title":"惠医通-医院挂号订单平台","slug":"“惠医通-医院挂号订单平台”","date":"2023-08-28T08:19:00.000Z","updated":"2023-08-28T11:07:51.881Z","comments":true,"path":"2023/08/28/“惠医通-医院挂号订单平台”/","link":"","permalink":"http://awesomeboy.cn/2023/08/28/%E2%80%9C%E6%83%A0%E5%8C%BB%E9%80%9A-%E5%8C%BB%E9%99%A2%E6%8C%82%E5%8F%B7%E8%AE%A2%E5%8D%95%E5%B9%B3%E5%8F%B0%E2%80%9D/","excerpt":"","text":"结合已学习过的vue3和TS完成的项目，便于患者对自己想要就诊的科室进行挂号，付款 一：项目简介前端技术栈 Vue3 TS vue-router Element-ui Axios Pinia 项目架构 二：主要模块1. axios二次封装1.1 创建实例12345//利用axios.create方法创建一个axios实例const request = axios.create(&#123; baseURL: &#x27;/api&#x27;, //请求基础路径设置 timeout: 5000 //超时的时间设置，超出5s请求就是失败&#125;) 1.2 请求拦截器 引入store仓库中的用户token，设置请求头携带token参数，后序请求需要验证token 1234567891011121314//请求拦截器request.interceptors.request.use(config =&gt; &#123; //config:请求拦截器回调注入的对象（配置对象），配置对象的身上最重要的一件事情headers属性 //可以通过请求头携带公共参数 -token //获取用户仓库 let userStore = useUserStore() // console.log(userStore.userInfo) // token: 公共参数，用户登录了需要携带 if (userStore.userInfo.token) &#123; config.headers.token = userStore.userInfo.token &#125; return config&#125;) 1.3 响应拦截器 利用响应拦截器进行简化数据 当http网络错误时，设置提示信息 1234567891011121314151617181920212223242526272829303132333435//响应拦截器request.interceptors.response.use( response =&gt; &#123; //响应拦截器成功的回调，一般会简化数据 return response.data &#125;, error =&gt; &#123; //处理http网络错误 let status = error.response.status switch (status) &#123; case 404: //错误信息 ElMessage(&#123; type: &#x27;error&#x27;, message: &#x27;请求失败路径出现问题&#x27; &#125;) break case 500 | 501 | 502 | 503 | 504 | 505: //错误信息 ElMessage(&#123; type: &#x27;error&#x27;, message: &#x27;服务器错误&#x27; &#125;) break case 401: //错误信息 ElMessage(&#123; type: &#x27;error&#x27;, message: &#x27;参数有误&#x27; &#125;) break &#125; return Promise.reject(new Error(error.message)) &#125;) 2. vite配置代理跨域 在跨域请求时，浏览器会采取同源策略来限制来自不同源的跨域请求，为了解决这个问题，通常可以采用代理服务器来处理该问题，使得请求在同源的环境下进行 vite服务器会将请求转发到指定的代理服务器，代理服务器再向目标请求地址发起请求 代理服务器接收到真正的响应后，再将其返回给vite服务器，最终返回给前端 123456789//配置代理跨域server: &#123; proxy: &#123; &#x27;/api&#x27;: &#123; target: &#x27;http:xxx.cn&#x27;, changeOrigin: true &#125; &#125;&#125; 3. 首页： 搜索栏 element-ui组件-自动补全输入框 12345678&lt;el-autocomplete @select=&quot;goDetail&quot; :trigger-on-focus=&quot;false&quot; clearable placeholder=&quot;请你输入医院名称&quot; v-model=&quot;hosname&quot; :fetch-suggestions=&quot;fetchData&quot;/&gt; 1234567891011121314151617181920212223242526272829303132//引入请求方法import &#123; reqHospitalInfo &#125; from &#x27;@/api/home&#x27;import type &#123; HospitalInfo &#125; from &#x27;@/api/home/type&#x27;//创建路由器对象let $router = useRouter()//收集搜索的关键字(医院的名字)let hosname = ref&lt;string&gt;(&#x27;&#x27;)//顶部组件的回调const fetchData = async (keyword: string, cb: any) =&gt; &#123; //当用户输入完关键字时 函数执行 发送请求获取需要展示的数据 // console.log(123) let result: HospitalInfo = await reqHospitalInfo(keyword) // console.log(result) //该组件 需要的数据字段为 value 返回的数据字段为hosname 整理修改 let showData = result.data.map(item =&gt; &#123; return &#123; value: item.hosname, //展示的是医院的编码 hoscode: item.hoscode //存储医院的编码 &#125; &#125;) //给组件提供展示的数据 cb(showData)&#125;//点击某一个推荐项const goDetail = (item: any) =&gt; &#123; //点击推荐项目进入医院详情页,将来需要携带query参数(医院的编码) // console.log(item) $router.push(&#123; path: &#x27;/hospital/register&#x27;, query: &#123; hoscode: item.hoscode &#125; &#125;)&#125; fetch-suggestions方法，需要两个参数，keyword是搜索框输入的参数，cb，callback回调函数，需要将给组件展示的数据传给回调函数 因此，调用根据输入的字段获取医院信息，使用map方法遍历返回的数据，再根据对应的字段将数据返回出来，作为showData，再将其传入回调 select事件，当选中对应选项时触发，携带对应医院参数跳转到对应医院详情页 4. 首页： 根据等级和地区筛选 4.1 子组件：Level-医院等级 自定义事件向父组件传递等级参数 子组件通过defineEmits设置要发射给父组件需要使用的方法getLevel 使用defineEmits会返回一个方法，使用一个变量emits(变量名随意)去接收 在对应时机触发事件，并传入需要传递给父组件的参数 123456789//点击等级的按钮回调const changeLevel = (level: string) =&gt; &#123; //高亮响应式数据存储leve数值 activeFlag.value = level //触发自定义事件： 将医院的等级数值传递给父组件 $emit(&#x27;getLevel&#x27;, level)&#125;let $emit = defineEmits([&#x27;getLevel&#x27;]) 4.2 子组件：Region-地区12345678//点击不同区域按钮回调const changeRegion = (region: string) =&gt; &#123; regionFlag.value = region //触发自定义事件传值 $emits(&#x27;getRegion&#x27;, region)&#125;let $emits = defineEmits([&#x27;getRegion&#x27;]) 4.3 父组件：home-首页 当页面挂载时候，获取医院数据并展示 但当用户选中等级和地区时，需要重新根据对应的参数获取对应的医院数据 因此需要用到地区子组件和等级子组件传递来的对应参数 用到自定义事件接受两个子组件传递的参数 1234567891011121314//子组件自定义事件：获取子组件传递的医院等级数据const getLevel = (level: string) =&gt; &#123; //更新存储医院等级数据 hosType.value = level //更新完医院等级数据再重新发起请求 getHospitalInfo()&#125;//子组件自定义事件：获取子组件传递的地区数据const getRegion = (region: string) =&gt; &#123; //更新存储医院地区数据 districtCode.value = region //更新完医院等级数据再重新发起请求 getHospitalInfo()&#125; 5. 登录&#x2F;退出 1234567891011121314151617181920212223//用户登录const login = async () =&gt; &#123; //保证表单校验两项都复合条件 await form.value.validate() try &#123; //用户登录成功 await userStore.userLogin(loginParam) //关闭对话框 userStore.visiable = false //获取url的query参数 let redirect = $route.query.redirect if (redirect) &#123; $router.push(redirect as string) &#125; else &#123; $router.push(&#x27;/home&#x27;) &#125; &#125; catch (error) &#123; ElMessage(&#123; type: &#x27;error&#x27;, message: (error as Error).message &#125;) &#125;&#125; 仓库处理登录逻辑，并保存响应状态 123456789101112131415//用户登录请求async userLogin(loginParam: any) &#123; let result: UserLoginResponseData = await reqUserLogin(loginParam) // console.log(loginParam) // console.log(result) if (result.code === 200) &#123; //存储name和token this.userInfo = result.data //本地存储持久化存储用户信息 SET_TOKEN(JSON.stringify(this.userInfo)) return &#x27;ok&#x27; &#125; else &#123; return Promise.reject(new Error(result.message)) &#125;&#125;, 12345678910111213//本地存储操作用户信息的方法export const SET_TOKEN = (userInfo: string) =&gt; &#123; localStorage.setItem(&#x27;userInfo&#x27;, userInfo)&#125;export const GET_TOKEN = () =&gt; &#123; return localStorage.getItem(&#x27;userInfo&#x27;)&#125;export const REMOVE_TOKEN = () =&gt; &#123; localStorage.removeItem(&#x27;userInfo&#x27;)&#125; 封装操作用户相关信息持久化存储的相关方法 1234567//退出登录loginOut() &#123; //清空仓库的数据 this.userInfo = &#123; name: &#x27;&#x27;, token: &#x27;&#x27; &#125; //清空本地存储的数据 REMOVE_TOKEN()&#125; 退出登录，清空仓库的数据，清除本地存储数据 6. 挂号 123456//点击对应日期获取对应数据存储const changeTime = async (item: string) =&gt; &#123; workTime.value = item //再调用获取医生数据请求 getDoctorWorkData()&#125; 12345678910111213141516//获取当前日期下的医生信息和票价格请求const getDoctorWorkData = async () =&gt; &#123; //三个参数 //医院编号 let hoscode: string = $route.query.hoscode as string //科室编号 let depcode: string = $route.query.depcode as string //工作日期 let workDate: string = workTime.value.workDate //发请求存储数据 let result: DoctorResponseData = await reqHospitalDoctor(hoscode, depcode, workDate) // console.log(result) if (result.code === 200) &#123; docArr.value = result.data &#125;&#125; workTime存储改日日期，通过点击对应日期，更新workTime的值，然后再次获取医生数据请求，就可以获取选中日期下的号源数据 7. 微信支付：Qrcode 每个订单有对应的订单id，通过对应的订单id获取唯一对应的订单二维码 根据服务器返回的二维码信息通过Qrcode.js生成二维码图片 调用qrcode的相关API库，传入对应的参数 保存生成的二维码图片地址 12345678910111213141516171819202122232425//打开二维码支付对话框const openDialog = async () =&gt; &#123; dialogVisible.value = true //获取支付需要使用二维码信息 let result: QrCode = await reqQrcode($route.query.orderId as string) //更具服务器返回二维码信息生成二维码图片 imgUrl.value = await QRCode.toDataURL(result.data.codeUrl) //设置定时器每间隔2s发起请求 查询订单是否支付 timer.value = setInterval(async () =&gt; &#123; let result: PayReslt = await reqQueryPayState($route.query.orderId as string) if (result.data === true) &#123; //关闭对话框 dialogVisible.value = false //提示信息 ElMessage(&#123; type: &#x27;success&#x27;, message: &#x27;支付成功&#x27; &#125;) //清除定时器 clearInterval(timer.value) //再次获取订单详情的数据 getOrderInfo() &#125; &#125;, 2000)&#125; 当打开支付页面时，就要开启定时器，每个两秒发一次请求用于询问订单是否支付 直到支付成功后清除定时器 8. 就诊人管理8.1 级联选择器选择多级地址信息 1&lt;el-cascader :props=&quot;props&quot; v-model=&quot;userParams.addressSelected&quot; /&gt; 12345678910111213141516171819//级联选择器地址信息方法const props: CascaderProps = &#123; lazy: true, //懒加载数据 //加载级联选择器数据方法 async lazyLoad(node: any, resolve: any) &#123; let result: any = await reqCity(node.data.id || &#x27;86&#x27;) //整理数据 let showData = result.data.map((item: any) =&gt; &#123; return &#123; id: item.id, label: item.name, value: item.value, leaf: !item.hasChildren &#125; &#125;) //注入组件需要展示的数据 resolve(showData) &#125;&#125; props是级联选择器内置配置参数进行设置的对象 lazy属性设置为true，表示开启懒加载 定义一个lazyLoad方法，用于加载级联选择器的数据，接受两个参数node和resolve回调 node表示当前选中的节点信息，resolve表示用于回调的函数 方法内部通过id获取城市信息，为一级省份 再使用map方法对城市数据进行整理，将id、name、value和是否有子级节点的信息映射到一个新的对象中，并存储在showData数组中 最后，调用resolve函数，将整理后的数据传入，以便组件进行展示 8.2 就诊人信息收集 123456789101112131415//watch监听数据watch( () =&gt; userArr.value, () =&gt; &#123; //如果是从预约挂号那里跳转过来 监听数据变化 根据id找到对应要修改的人 if ($route.query.type === &#x27;edit&#x27;) &#123; let user = userArr.value.find((item: any) =&gt; &#123; return item.id == $route.query.id &#125;) //收集数据 Object.assign(userParams, user) &#125; &#125;) Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。 当在选择就诊人信息时候，点击修改信息按钮，跳转到对应页面，要收集原先的数据信息 需要通过watch监听userArr，判断路径是否是从预约挂号跳转过来的 通过find方法从所有就诊人中找到对应选中修改的就诊人 将其信息通过object.assign方法进行收集并展示 9. 挂号订单 调用接口信息展示即可 10. 路由鉴权1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//路由鉴权： 路由守卫import router from &#x27;./router&#x27;//引入大仓库import pinia from &#x27;@/store&#x27;//引入进度条//@ts-ignoreimport Nprogress from &#x27;nprogress&#x27;//引入用户相关的仓库import useUserStore from &#x27;@/store/modules/user&#x27;let userStore = useUserStore(pinia)//引入进度条样式import &#x27;nprogress/nprogress.css&#x27;//进度条的加载小圆球不要Nprogress.configure(&#123; showSpinner: false &#125;)//存储用户未登录可以访问路由得路径let whiteList = [ &#x27;/home&#x27;, &#x27;/hospital/register&#x27;, &#x27;/hospital/detail&#x27;, &#x27;/hospital/notice&#x27;, &#x27;/hospital/close&#x27;, &#x27;/hospital/search&#x27;]//前置守卫router.beforeEach((to, from, next) =&gt; &#123; //访问路由组件的之前,进度条开始动 Nprogress.start() //动态设置网页左上角的标题 //@ts-ignore document.title = to.meta.title //判断用户是否登录-token let token = userStore.userInfo.token if (token) &#123; next() &#125; else &#123; //用户未登录 if (whiteList.includes(to.path)) &#123; next() &#125; else &#123; //登录组件 userStore.visiable = true next(&#123; path: &#x27;/home&#x27;, query: &#123; redirect: to.fullPath &#125; &#125;) &#125; &#125;&#125;)//后置守卫router.afterEach((to, from) =&gt; &#123; //访问路由组件成功,进度条消失 Nprogress.done()&#125;) 三：规范代码格式和提交规范 eslint prettier cz-git 3.1 prettier1234567891011121314module.exports = &#123; singleQuote: true, // 使用单引号, 默认false(在jsx中配置无效, 默认都是双引号) semi: false, // 使用分号, 默认true printWidth: 120, // 每行超过多少字符自动换行 arrowParens: &#x27;avoid&#x27;, // avoid 能省略括号的时候就省略 例如x =&gt; x bracketSpacing: true, // 对象中的空格 默认true trailingComma: &#x27;none&#x27;, // all 包括函数对象等所有可选 tabWidth: 4, // tab缩进大小,默认为2 useTabs: false, // 使用tab缩进，默认false htmlWhitespaceSensitivity: &#x27;ignore&#x27;, // 对象大括号直接是否有空格，默认为true，效果：&#123; foo: bar &#125; bracketSpacing: true&#125; 3.2 eslint1234567891011121314151617181920212223242526272829303132333435module.exports = &#123; env: &#123; browser: true, es2021: true, node: true &#125;, extends: [ &#x27;eslint:recommended&#x27;, &#x27;plugin:vue/vue3-essential&#x27;, &#x27;plugin:@typescript-eslint/recommended&#x27;, &#x27;plugin:prettier/recommended&#x27; // 解决ESlint和Prettier冲突 ], overrides: [], // 配置支持 vue 和 ts parser: &#x27;vue-eslint-parser&#x27;, parserOptions: &#123; ecmaVersion: &#x27;latest&#x27;, sourceType: &#x27;module&#x27;, parser: &#x27;@typescript-eslint/parser&#x27; &#125;, plugins: [&#x27;vue&#x27;, &#x27;@typescript-eslint&#x27;], rules: &#123; &#x27;@typescript-eslint/no-explicit-any&#x27;: &#x27;off&#x27;, // 禁止使用该any类型。 &#x27;@typescript-eslint/no-unused-vars&#x27;: &#x27;off&#x27;, //禁止未使用的变量 &#x27;vue/valid-template-root&#x27;: &#x27;off&#x27;, &#x27;vue/no-v-html&#x27;: &#x27;off&#x27;, &#x27;prefer-const&#x27;: &#x27;off&#x27;, &#x27;@typescript-eslint/ban-types&#x27;: &#x27;off&#x27;, &#x27;@typescript-eslint/no-empty-function&#x27;: &#x27;off&#x27;, &#x27;@typescript-eslint/ban-ts-comment&#x27;: &#x27;off&#x27;, &#x27;vue/multi-word-component-names&#x27;: &#x27;off&#x27;, endOfLine: &#x27;off&#x27;, // 添加忽略换行格式的检查。 &#x27;vue/require-default-prop&#x27;: &#x27;off&#x27; // props 需要设置默认值 &#125;&#125; 3.3 commitlintrc.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// .commitlintrc.jsmodule.exports = &#123; rules: &#123; // @see: https://commitlint.js.org/#/reference-rules &#125;, prompt: &#123; messages: &#123; type: &#x27;选择你要提交的类型 :&#x27;, scope: &#x27;选择一个提交范围（可选）:&#x27;, customScope: &#x27;请输入自定义的提交范围 :&#x27;, subject: &#x27;填写简短精炼的变更描述 :\\n&#x27;, body: &#x27;填写更加详细的变更描述（可选）。使用 &quot;|&quot; 换行 :\\n&#x27;, breaking: &#x27;列举非兼容性重大的变更（可选）。使用 &quot;|&quot; 换行 :\\n&#x27;, footer: &#x27;列举关联issue (可选) 例如: #31, #I3244 :\\n&#x27;, confirmCommit: &#x27;是否提交或修改commit ?&#x27; &#125;, types: [ &#123; value: &#x27;feat&#x27;, name: &#x27;feat: 新增功能 | A new feature&#x27;, emoji: &#x27;✨&#x27; &#125;, &#123; value: &#x27;fix&#x27;, name: &#x27;fix: 修复缺陷 | A bug fix&#x27;, emoji: &#x27;🐛&#x27; &#125;, &#123; value: &#x27;docs&#x27;, name: &#x27;docs: 文档更新 | Documentation only changes&#x27;, emoji: &#x27;📄&#x27; &#125;, &#123; value: &#x27;style&#x27;, name: &#x27;style: 代码格式 | Changes that do not affect the meaning of the code&#x27;, emoji: &#x27;💄&#x27; &#125;, &#123; value: &#x27;refactor&#x27;, name: &#x27;refactor: 代码重构 | A code change that neither fixes a bug nor adds a feature&#x27;, emoji: &#x27;♻️&#x27; &#125;, &#123; value: &#x27;perf&#x27;, name: &#x27;perf: 性能提升 | A code change that improves performance&#x27;, emoji: &#x27;⚡️&#x27; &#125;, &#123; value: &#x27;test&#x27;, name: &#x27;test: 测试相关 | Adding missing tests or correcting existing tests&#x27;, emoji: &#x27;✅&#x27; &#125;, &#123; value: &#x27;build&#x27;, name: &#x27;build: 构建相关 | Changes that affect the build system or external dependencies&#x27;, emoji: &#x27;📦️&#x27; &#125;, &#123; value: &#x27;ci&#x27;, name: &#x27;ci: 持续集成 | Changes to our CI configuration files and scripts&#x27;, emoji: &#x27;🎡&#x27; &#125;, &#123; value: &#x27;revert&#x27;, name: &#x27;revert: 回退代码 | Revert to a commit&#x27;, emoji: &#x27;⏪️&#x27; &#125;, &#123; value: &#x27;chore&#x27;, name: &#x27;chore: 其他修改 | Other changes that do not modify src or test files&#x27;, emoji: &#x27;🔨&#x27; &#125; ], useEmoji: true, // scope 类型（定义之后，可通过上下键选择） scopes: [ [&#x27;components&#x27;, &#x27;组件相关&#x27;], [&#x27;hooks&#x27;, &#x27;hook 相关&#x27;], [&#x27;utils&#x27;, &#x27;utils 相关&#x27;], [&#x27;element-ui&#x27;, &#x27;对 element-ui 的调整&#x27;], [&#x27;styles&#x27;, &#x27;样式相关&#x27;], [&#x27;deps&#x27;, &#x27;项目依赖&#x27;], [&#x27;auth&#x27;, &#x27;对 auth 修改&#x27;], [&#x27;other&#x27;, &#x27;其他修改&#x27;] ].map(([value, description]) =&gt; &#123; return &#123; value, name: `$&#123;value.padEnd(30)&#125; ($&#123;description&#125;)` &#125; &#125;), // 是否允许自定义填写 scope，在 scope 选择的时候，会有 empty 和 custom 可以选择。 allowCustomScopes: true, // 跳过要询问的步骤 skipQuestions: [&#x27;body&#x27;, &#x27;breaking&#x27;, &#x27;footer&#x27;], subjectLimit: 100, // subject 限制长度 // 设置只有 type 选择了 feat 或 fix，才询问 breaking message allowBreakingChanges: [&#x27;feat&#x27;, &#x27;fix&#x27;], issuePrefixs: [ // 如果使用 gitee 作为开发管理 &#123; value: &#x27;link&#x27;, name: &#x27;link: 链接 ISSUES 进行中&#x27; &#125;, &#123; value: &#x27;comment&#x27;, name: &#x27;comment: 评论 ISSUES&#x27; &#125;, &#123; value: &#x27;closed&#x27;, name: &#x27;closed: 标记 ISSUES 已完成&#x27; &#125; ] &#125;&#125;","categories":[{"name":"Vue项目开发","slug":"Vue项目开发","permalink":"http://awesomeboy.cn/categories/Vue%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"http://awesomeboy.cn/tags/Vue3/"},{"name":"TS","slug":"TS","permalink":"http://awesomeboy.cn/tags/TS/"}],"author":"awesomeboy"},{"title":"axios的二次封装","slug":"axios的二次封装","date":"2023-08-10T13:13:07.000Z","updated":"2023-08-10T13:49:48.267Z","comments":true,"path":"2023/08/10/axios的二次封装/","link":"","permalink":"http://awesomeboy.cn/2023/08/10/axios%E7%9A%84%E4%BA%8C%E6%AC%A1%E5%B0%81%E8%A3%85/","excerpt":"","text":"一：为什么要对axios进行二次封装？ 隐藏axios的细节：axios是一个强大的HTTP请求库，但它也有一些繁琐的细节需要处理，比如处理请求的错误、请求超时，以及请求的拦截等。通过二次封装，我们可以将这些细节隐藏起来，使开发人员可以更加专注于业务逻辑的开发。 统一处理请求和响应：通过二次封装，我们可以在请求之前或者响应之后做一些通用的处理，比如添加请求头、处理响应数据等。这样可以减少代码重复，提高开发效率。 拦截请求和响应：提前对数据进行处理，例如访问对应页面需要token认证，就需要对请求头进行携带token 二：axios二次封装的使用2.1 文件构建 在工程目录下的src下建立utils文件夹，放置对axios的二次封装请求 utils同级目录下，建立api文件夹，统一放置对应封装的请求接口 2.2 对axios进行二次封装request.ts 12345678910111213141516171819202122232425import axios from &#x27;axios&#x27;//利用axios.create方法创建一个axios实例const request = axios.create(&#123; baseURL: &#x27;&#x27;, //请求基础路径设置 timeout: 5000 //超时的时间设置，超出5s请求就是失败&#125;)//请求拦截器request.interceptors.request.use(config =&gt; &#123; return config&#125;)//响应拦截器request.interceptors.response.use( response =&gt; &#123; //响应拦截器成功的回调，一般会简化数据 return response.data &#125;, error =&gt; &#123;)//对外暴露axiosexport default request 2.3 封装请求接口api文件下接口文件 1234567891011121314151617//引入二次封装axiosimport request from &#x27;@/utils/request&#x27;//枚举类型enum API &#123; USERLOGIN = &#x27;/user/login&#x27;&#125;//请求的二次封装export const reqUserLogin = (params: any) =&gt; request&lt;any&gt;(&#123; url: API.USERLOGIN, method: &#x27;post&#x27;, data: params &#125;) 2.4 引入接口请求login.ts 12//引入接口import &#123; reqUserLogin &#125; from &#x27;@/api/user/index&#x27;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://awesomeboy.cn/categories/Vue/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://awesomeboy.cn/tags/HTTP/"},{"name":"axios","slug":"axios","permalink":"http://awesomeboy.cn/tags/axios/"}],"author":"awesomeboy"},{"title":"浏览器的事件循环机制(Event Loop)","slug":"事件循环机制-Event-Loop","date":"2023-08-05T08:16:44.000Z","updated":"2023-09-13T13:30:20.434Z","comments":true,"path":"2023/08/05/事件循环机制-Event-Loop/","link":"","permalink":"http://awesomeboy.cn/2023/08/05/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6-Event-Loop/","excerpt":"","text":"一：什么是浏览器的事件循环机制？ 浏览器的事件循环是指在Web浏览器中对事件的处理机制。它是基于异步编程模型，运行在JS的引擎之中 二：浏览器的进程和线程 首先要了解我们所编写的JJS代码最终是怎么在浏览器中执行的 浏览器是一个复杂的应用程序，运行时候通常包含多个进程和多个线程，用于执行不同的任务和管理不同的资源 进程：是操作系统进行资源的分配和调度的基本单位，进程是程序执行的基本实体 线程：是操作系统能够进行运算的最小单位，一个进程中可以并发执行多个线程，每个线程并行执行不同的任务 浏览器的进程和线程 渲染进程负责加载解析和渲染页面内容，每个标签页通常运行在独立的渲染进程中，每个渲染进程都包含多个线程 GUI线程：GUI主线程（也称为UI线程）是浏览器中负责处理用户界面操作和渲染的线程。它负责响应用户的交互操作、更新页面的显示等任务 JS引擎线程：负责解释和执行JS代码，将JS代码转换成可执行指令，并按照指令的顺序进行执行 在浏览器中，JS引擎的线程是单线程，一次只能执行一个任务，在执行JS代码时，用到了异步编程模型，通过事件循环机制处理异步任务，这样可以使得JS可以处理耗时的操作而不阻塞用户界面的相应 事件监听线程：浏览器中负责监听和触发事件的线程。它是浏览器的一部分，用于处理用户输入、网络操作、定时器等事件的触发和相应。 定时器线程负责管理和触发定时器相关的任务，如setTimeout和setInterval 异步http请求线程：当发起AJAX请求时，浏览器会创建一个独立的线程来处理网络请求，该线程负责与服务器进行通信并接收响应 插件进程负责控制网络使用的所有插件 GPU进程负责整个浏览器界面的渲染 三：同步和异步在JavaScript中，所有的任务都可以分为 同步任务：同步任务会在GUI线程（主线程）和JS引擎线程中进行执行 GUI线程：主要负责页面的渲染，所以不能被长时间的同步代码阻塞 JS引擎线程：会阻碍其它任务的执行，包括GUI主线程的执行，如果JS引擎线程上的同步任务多的话，会导致页面的渲染和用户交互被暂时中断 异步任务：异步执行的任务，比如ajax网络请求，setTimeout 定时函数等 定时器线程 异步http请求线程 事件监听线程 三：宏任务和微任务 异步任务又分为宏任务和微任务 宏任务：需要在事件循环中单独执行的任务单元 渲染事件（如绘制页面、重新布局等） 用户交互事件（如鼠标点击、键盘事件等） 定时器事件（如 setTimeout 和 setInterval 的回调函数） 网络请求完成、文件读写完成等异步操作的回调函数 微任务：在当前宏任务执行完毕后立即执行的任务单元 Promise 的回调函数 Object.Observer MutaionObserver的回调函数 四：事件循环机制 在事件循环中，调用栈和事件队列是两个重要的组成部分 调用栈：当执行到JS代码时候，函数调用会被添加到调用栈中，按照先进后出的顺序执行 任务队列：存储着待执行的异步任务，任务队列分为宏任务队列和微任务队列 宏任务队列：存储着需要在事件循环中单独执行的任务，如定时器回调、事件回调等。 微任务队列：存储着需要在当前宏任务执行完毕后立即执行的任务，如 Promise 的回调函数、MutationObserver 的回调函数等 事件循环流程 当执行同步代码的时候，函数调用会依次进入到调用栈中执行 当遇到异步任务时，定时器回调，定时器到期时，回调函数会进入到宏任务队列中等待执行 任务队列中的任务会等到调用栈为空时候，事件循环会从任务队列取出一个任务加入到调用栈中执行 注意 微任务队列具有更高的优先级，会在下一个宏任务执行之前被处理。所以，当微任务队列不为空时，即使宏任务队列中有待执行的任务，也会先处理微任务队列中的任务。 代码 1234567891011121314console.log(1)setTimeout(() =&gt;&#123; console.log(2)&#125;, 0)new Promise((resolve, reject) =&gt;&#123; console.log(&#x27;new Promise&#x27;) resolve()&#125;).then(() =&gt;&#123; console.log(&#x27;then&#x27;)&#125;)console.log(3) 先执行同步代码，将console.log(1)压入调用栈中，执行完毕弹出，输出1 遇到定时器，异步任务，交给定时器线程处理，等定时器到期将回调函数加入到宏任务队列 宏任务队列：console.log(1) new Promise是同步代码，直接执行，输出new Promise 遇到.then异步代码，微任务，加入微任务队列 微任务队列：console.log(‘then’) 执行到console.log(3)，同步代码直接执行，输出3 同步代码全部执行完毕后，调用栈为空，要从任务队列中取出任务加入调用栈中 由于微任务优先，所以从微任务队列中取出console.log(‘then’)，并执行输出then 再从宏任务队列中取出console.log(2)，并执行输出2","categories":[{"name":"JS","slug":"JS","permalink":"http://awesomeboy.cn/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://awesomeboy.cn/tags/JS/"}],"author":"awesomeboy"},{"title":"LeetCode-530-二叉搜索树的最小绝对差","slug":"LeetCode-530-二叉搜索树的最小绝对差","date":"2023-08-05T07:06:05.000Z","updated":"2023-08-05T07:19:22.163Z","comments":true,"path":"2023/08/05/LeetCode-530-二叉搜索树的最小绝对差/","link":"","permalink":"http://awesomeboy.cn/2023/08/05/LeetCode-530-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE/","excerpt":"","text":"一：题目描述给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。 差值是一个正数，其数值等于两值之差的绝对值。 二：示例与提示示例 1: 12输入：root = [4,2,6,1,3]输出：1 示例 2: 12输入：root = [1,0,48,null,null,12,49]输出：1 提示: 树中节点的数目范围是 [2, 104] 0 &lt;= Node.val &lt;= 105 三：思路二叉搜索树的性质 + 升序数组 如果左子树不为空，左子树的每个节点值都小于根节点值 如果右子树不为空，右子树的每个节点值都大于根节点值 直接中序遍历，生成升序数组，由于升序，直接遍历数组作差，找到最小的差值 双指针 Pre指针指向cur指针之后的一个节点 中序遍历，作差找最小值即可 复杂度分析： 时间复杂度：O(n)，n为二叉搜索树的节点的数目，只是对二叉搜索树进行一个遍历，取最小值 空间复杂度：O(n)，递归函数的空间复杂度由递归的栈深度决定，而栈深度在二叉搜索树为一条链的情况下会达到 O*(*n) 级别。 四：代码123456789101112131415161718192021222324252627282930313233343536/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number&#125; */var getMinimumDifference = function(root) &#123; //利用二叉搜索树的性质 //双指针 let pre = null //最小值 let min = Infinity const getTree = (cur) =&gt; &#123; // 左中右 if(!cur) return //遍历 getTree(cur.left) //中 if(pre)&#123; // 相减取最小 min = Math.min(min, cur.val - pre.val) &#125; //pre指针先指向cur当前位置 pre = cur //右 cur指针移动至下个位置 这样子pre 紧跟 cur后一个 getTree(cur.right) &#125; getTree(root) return min&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://awesomeboy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"http://awesomeboy.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"author":"awesomeboy"},{"title":"LeetCode-617-合并二叉树","slug":"LeetCode-617-合并二叉树","date":"2023-08-05T06:32:52.000Z","updated":"2023-08-05T06:37:33.797Z","comments":true,"path":"2023/08/05/LeetCode-617-合并二叉树/","link":"","permalink":"http://awesomeboy.cn/2023/08/05/LeetCode-617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"一：题目描述给你两棵二叉树： root1 和 root2 。 想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。 返回合并后的二叉树。 注意: 合并过程必须从两个树的根节点开始。 二：示例与提示示例 1: 12输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]输出：[3,4,5,5,4,null,7] 示例 2:12输入：root1 = [1], root2 = [1,2]输出：[2,2] 提示: 两棵树中的节点数目在范围 [0, 2000] 内 -104 &lt;= Node.val &lt;= 104 三：思路递归构造二叉树 需要注意递归遍历时候，遍历到的是两个树的相同位置，并不是第一个树开始操作了，第二个树还没开始遍历 判断条件，如果第一个树的左子树不存在，那么就返回第二个树的左子树 同样，第一个树左子树存在，第二个树左子树不存在，那就返回第一个树的左子树 如果同时都不存在，那就返回空就好 然后进行递归遍历，注意遍历顺序，采用前序遍历较为清晰 四：代码123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root1 * @param &#123;TreeNode&#125; root2 * @return &#123;TreeNode&#125; */var mergeTrees = function(root1, root2) &#123; const getTree = (root1, root2) =&gt; &#123; //终止条件 if(!root1) return root2 if(!root2) return root1 if(!root1 &amp;&amp; !root2) return null //创建新的节点 let node = new TreeNode(0) //值相加 node.val = root1.val + root2.val //左右子树 node.left = getTree(root1.left, root2.left) node.right = getTree(root1.right, root2.right) return node &#125; return getTree(root1, root2)&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://awesomeboy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"http://awesomeboy.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"author":"awesomeboy"},{"title":"LeetCode-98-验证二叉搜索树","slug":"LeetCode-98-验证二叉搜索树","date":"2023-08-05T06:24:50.000Z","updated":"2023-08-05T06:31:58.278Z","comments":true,"path":"2023/08/05/LeetCode-98-验证二叉搜索树/","link":"","permalink":"http://awesomeboy.cn/2023/08/05/LeetCode-98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","excerpt":"","text":"一：题目描述给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。 有效 二叉搜索树定义如下： 节点的左子树只包含 小于 当前节点的数。 节点的右子树只包含 大于 当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 二：示例与提示示例 1: 12输入：root = [2,1,3]输出：true 示例 2: 123输入：root = [5,1,4,null,null,3,6]输出：false解释：根节点的值是 5 ，但是右子节点的值是 4 。 提示: 树中节点数目范围在[1, 104] 内 -231 &lt;= Node.val &lt;= 231 - 1 三：思路二叉搜索树特性 + 升序数组 二叉搜索树的特性 如果二叉树的左子树不为空，那么其左子树的所有节点的值小于根节点的值 如果二叉树的右子树不为空，那么其右子树的所有节点的值要大于根节点的值 利用中序遍历的顺序，左中右的遍历顺序，会将二叉搜索树的节点按照升序排序的顺序输出 我们就只用判断这个数组是否符合升序排序即可 比较节点之间的值大小 在遍历的时候就进行比较操作，相邻两个节点值的大小，如果符合二叉搜索树的条件的话返回true，否则返回false 四：代码二叉搜索树特性 + 升序数组12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;boolean&#125; */var isValidBST = function(root) &#123; 中序遍历二叉搜索树 将其输出到一个数组中 判断这个数组是否升序排序 const res = [] const getTree = (root, res) =&gt; &#123; if(!root) return res getTree(root.left, res) res.push(root.val) getTree(root.right, res) return res &#125; const result = getTree(root, res) for(let i = 0; i &lt; result.length; i++)&#123; if(result[i] &gt;= result[i+1])&#123; return false &#125; &#125; return true&#125;; 比较节点之间的值大小1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;boolean&#125; */var isValidBST = function(root) &#123; let pre = null const getTree = (root) =&gt; &#123; if(!root) return true //左中右 let left = getTree(root.left) //中 //如果当前节点元素值大于最小值 更新最小值 保证升序 if (pre !== null &amp;&amp; pre.val &gt;= root.val) return false; pre = root; //右 let right = getTree(root.right) return left &amp;&amp; right &#125; return getTree(root)&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://awesomeboy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"http://awesomeboy.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"广度优先搜索","slug":"广度优先搜索","permalink":"http://awesomeboy.cn/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"}],"author":"awesomeboy"},{"title":"LeetCode-106-从中序与后序遍历序列构造二叉树","slug":"LeetCode-106-从中序与后序遍历序列构造二叉树","date":"2023-08-04T03:57:23.000Z","updated":"2023-08-04T04:18:36.412Z","comments":true,"path":"2023/08/04/LeetCode-106-从中序与后序遍历序列构造二叉树/","link":"","permalink":"http://awesomeboy.cn/2023/08/04/LeetCode-106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"一：题目描述给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。 二：示例与提示示例 1: 12输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]输出：[3,9,20,null,null,15,7] 示例 2:12输入：inorder = [-1], postorder = [-1]输出：[-1] 提示: 1 &lt;= inorder.length &lt;= 3000 postorder.length == inorder.length -3000 &lt;= inorder[i], postorder[i] &lt;= 3000 inorder 和 postorder 都由 不同 的值组成 postorder 中每一个值都在 inorder 中 inorder 保证是树的中序遍历 postorder 保证是树的后序遍历 三：思路递归构造二叉树 中序遍历顺序是，左中右 后序遍历顺序是，左右中 因此，可以通过后序遍历可以先知道，根节点是什么，再在中序中，通过根节点知道左右两区间也就是左右子树 依次遍历就将二叉树构造出来了 根据前序遍历来构造二叉树的具体步骤：中，左，右 判断终止条件（递归优先步），当中序遍历数组为空时候，返回空节点 找到根节点，对根节点进行操作（中），即找到后序遍历数组中最后一个元素 寻找根节点在中序遍历数组中的下标索引index，通过index索引对两个序列数组切割左右子树，也作为递归的新参数 分割中序遍历数组，通过slice方法对其进行分割左右区间，注意slice区间范围左闭右开 分割后序遍历数组 递归处理左右区间(左、右)，node.left，node.right指向左右子树 最终返回node 四：代码12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;number[]&#125; inorder * @param &#123;number[]&#125; postorder * @return &#123;TreeNode&#125; */var buildTree = function(inorder, postorder) &#123; // const getTree = (inorder, postorder) =&gt; &#123; //中序遍历数组是要被切割的数组 //中序遍历数组只剩一个元素返回 if(inorder.length === 0) return null //单层逻辑 //确定根节点同时删除后序遍历数组中的根节点 let rootVal = postorder.pop() let node = new TreeNode(rootVal) if(inorder.length === 1) return node //获取根节点元素在中序遍历数组中的下标以便切割 let index = inorder.indexOf(rootVal) //处理中序遍历数组中的左右区间问题 //左 //切割数组 let inorderLeft = inorder.slice(0, index) let postorderLeft = postorder.slice(0, index) node.left = getTree(inorderLeft, postorderLeft) //切割数组 let inorderRight = inorder.slice(index + 1, inorder.length) let postorderRight = postorder.slice(index, postorder.length) node.right = getTree(inorderRight, postorderRight) return node &#125; return getTree(inorder, postorder)&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://awesomeboy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"http://awesomeboy.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"author":"awesomeboy"},{"title":"LeetCode-654-最大二叉树","slug":"LeetCode-654-最大二叉树","date":"2023-08-04T03:48:20.000Z","updated":"2023-08-04T03:56:38.850Z","comments":true,"path":"2023/08/04/LeetCode-654-最大二叉树/","link":"","permalink":"http://awesomeboy.cn/2023/08/04/LeetCode-654-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"一：题目描述给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建: 创建一个根节点，其值为 nums 中的最大值。 递归地在最大值 左边 的 子数组前缀上 构建左子树。 递归地在最大值 右边 的 子数组后缀上 构建右子树。 返回 nums 构建的 *最大二叉树* 。 二：示例与提示示例 1: 1234567891011输出：[6,3,5,null,2,0,null,null,1]解释：递归调用如下所示：- [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。 - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。 - 空数组，无子节点。 - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。 - 空数组，无子节点。 - 只有一个元素，所以子节点是一个值为 1 的节点。 - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。 - 只有一个元素，所以子节点是一个值为 0 的节点。 - 空数组，无子节点。 示例 2: 12输入：nums = [3,2,1]输出：[3,null,2,null,1] 提示: 1 &lt;= nums.length &lt;= 1000 0 &lt;= nums[i] &lt;= 1000 nums 中的所有整数 互不相同 三：思路递归构造二叉树 整个过程可以看做是一个自顶向下的递归过程，通过不断地找到最大元素，将数组分割成左右两个子数组，并依次构建左子树和右子树，最终构建出完整的最大二叉树。函数返回的就是最大二叉树的根节点。 根据题目模拟就可以构造 重要的是根据前序遍历构造该二叉树，优先对中节点进行处理，之后再对左右子树进行构造 找到数组中的最大值作为该二叉树的根节点 通过indexOf获取根元素的下标，根据slice方法分割数组，slice方法的特点是分割左闭右开区间 根据根节点的左右两区间数组，作为左子树和右子树 递归调用 最终返回node节点 四：代码12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;number[]&#125; nums * @return &#123;TreeNode&#125; */var constructMaximumBinaryTree = function(nums) &#123; //最大二叉树 const getTree = (nums) =&gt; &#123; //终止条件 //数组为空数组 if(nums.length === 0) return null //单层逻辑 //每次先找到数组中最大的元素 let max = nums[0] nums.forEach(item =&gt; &#123; if(item &gt; max) max = item &#125;) let node = new TreeNode(max) if(nums.length === 1) return node //左前缀的最大值在左子树，右前缀的最大值在右子树 //分割两个数组 let index = nums.indexOf(max) //递归遍历 //左 //分割数组 let arrLeft = nums.slice(0, index) node.left = getTree(arrLeft) //右 let arrRight = nums.slice(index + 1, nums.length) node.right = getTree(arrRight) return node &#125; return getTree(nums) &#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://awesomeboy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"http://awesomeboy.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"author":"awesomeboy"},{"title":"手写Promise核心代码","slug":"手写Promise","date":"2023-08-03T09:22:45.000Z","updated":"2023-08-10T13:56:49.970Z","comments":true,"path":"2023/08/03/手写Promise/","link":"","permalink":"http://awesomeboy.cn/2023/08/03/%E6%89%8B%E5%86%99Promise/","excerpt":"","text":"一： Promise声明123456789101112class MyPromise &#123; // 构造器 constructor(func) &#123; // 成功 let resolve = () =&gt; &#123;&#125;; // 失败 let reject = () =&gt; &#123;&#125;; // 立即执行 func(this.resolve, this.reject); &#125;&#125; 二： 基本状态12345678910111213141516171819202122232425class MyPromise &#123; static PENDING = &#x27;待定&#x27;; static FULFILLED = &#x27;成功&#x27;; static REJECTED = &#x27;拒绝&#x27;; // 构造器 constructor(func) &#123; //初始状态都为待定 this.status = MyPromise.PENDING; //result接受成功和失败的值 this.result = null // 成功 let resolve = (result) =&gt; &#123; this.status = MyPromise.FULFILLED; this.result = result &#125;; // 失败 let reject = (result) =&gt; &#123; this.status = MyPromise.FULFILLED; this.result = result &#125;; // 立即执行 //在构造实例的时候立即调用该函数 func(this.resolve.bind(this), this.reject.bind(this)); &#125;&#125; 初始状态都为待定 当调用resolve方法时候，状态改为成功，同时将参数赋值给result 当调用reject方法时，状态改为失败，同时将参数赋值给result 2.1 this指向问题 要注意func执行函数中的this执行问题，在resolve方法和reject方法中，使用了普通的函数声明而不是箭头函数。这意味着在调用这些方法时，它们的this应该指向实例对象。但是，由于没有正确绑定this，导致在调用resolve方法时报错。 123456789 当执行promise时候抛出错误，要进行判断，如果无异常正常执行 //如果错误，直接调用reject方法，并把错误信息传递过去 try &#123; //在构造实例的时候立即调用该函数 func(this.resolve.bind(this), this.reject.bind(this)); &#125; catch (error) &#123; this.reject(error); &#125;&#125; 2.2 抛出错误 Promise创造实例，抛出错误是可以通过调用reject报出错误信息的，而我们创建的MyPromise需要对这样的实例进行一个判断，如果抛出错误， 直接调用reject方法并且把错误信息传递给reject方法 123let myPromise = new MyPromise((resolve, reject) =&gt; &#123; throw new Error(&#x27;xxx&#x27;);&#125;); 三： then方法12345678then(onFULFILLED, onREJECTED) &#123; if (this.status === MyPromise.FULFILLED) &#123; onFULFILLED(this.result); &#125; if (this.status === MyPromise.REJECTED) &#123; onREJECTED(this.result); &#125;&#125; 3.1： then方法的参数变为可选参数123456789then() &#123; ---略--- //Promise允许then方法参数不是函数时候要省略，所以要判断then方法的两个参数是不是函数 //不是函数，赋值为空函数 onFULFILLED = typeof onFULFILLED === &#x27;function&#x27; ? onFULFILLED : () =&gt; &#123;&#125;; onREJECTED = typeof onREJECTED === &#x27;function&#x27; ? onREJECTED : () =&gt; &#123;&#125;;&#125; 四： 处理异步逻辑（待定状态下保存回调）123456789class MyPromise &#123; constructor(func) &#123; let resolve = () =&gt; &#123;&#125;; let reject = () =&gt; &#123;&#125;; //实现then方法多次调用添加多个处理函数 初始化回调为数组依次执行 this.resolveCallbacks = []; this.rejectCallbacks = []; &#125;&#125; 123456789then()&#123; //判断状态为待定时的处理方法 if (this.status === MyPromise.PENDING) &#123; //因为resolve 和 reject的方法还没有获取到值 //需要让then中的函数稍后执行，等resolve执行后了再执行then,保存当前的函数参数 this.resolveCallbacks.push(onFULFILLED); this.rejectCallbacks.push(onREJECTED); &#125;&#125; 123456789101112resolve(result) &#123; //resolve和reject要在事件循环末尾来执行的 //加上setTimeout setTimeout(() =&gt; &#123; this.status = MyPromise.FULFILLED; this.result = result; //遍历数组，是否有then保留的待执行函数 this.resolveCallbacks.forEach((callback) =&gt; &#123; callback(result); &#125;); &#125;);&#125; 123456789reject(result) &#123; setTimeout(() =&gt; &#123; this.status = MyPromise.REJECTED; this.result = result; this.rejectCallbacks.forEach((callback) =&gt; &#123; callback(result); &#125;); &#125;);&#125; 为了实现异步的逻辑，当then方法比resolve和reject方法先调用时，此时对应的状态应该为pending待定状态 此时我们需要对pending状态下进行处理操作，保留此时then的参数来等到resolve和reject方法的调用 创建两个数组保存pending状态下当前的函数参数 在resolve和reject方法中遍历对应两数组，执行数组中的回调函数，来处理异步逻辑 五： then方法链式调用12345then(onFULFILLED, onREJECTED) &#123; //Promise的链式，允许then.then需要返回一个Promise return new MyPromise((resolve, reject) =&gt; &#123; ---- * ---- &#125; promise中返回一个promise来实现promise的链式调用 六：完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374class MyPromise &#123; static PENDING = &#x27;待定&#x27;; static FULFILLED = &#x27;成功&#x27;; static REJECTED = &#x27;拒绝&#x27;; //func就是promise内的回调函数 constructor(func) &#123; this.status = MyPromise.PENDING; this.result = null; //实现then方法多次调用添加多个处理函数 初始化回调为数组依次执行 this.resolveCallbacks = []; this.rejectCallbacks = []; //1. 当执行promise时候抛出错误，要进行判断，如果无异常正常执行 //如果错误，直接调用reject方法，并把错误信息传递过去 try &#123; //在构造实例的时候立即调用该函数 func(this.resolve.bind(this), this.reject.bind(this)); &#125; catch (error) &#123; this.reject(error); &#125; &#125; resolve(result) &#123; //resolve和reject要在事件循环末尾来执行的 //加上setTimeout setTimeout(() =&gt; &#123; this.status = MyPromise.FULFILLED; this.result = result; //遍历数组，是否有then保留的待执行函数 this.resolveCallbacks.forEach((callback) =&gt; &#123; callback(result); &#125;); &#125;); &#125; reject(result) &#123; setTimeout(() =&gt; &#123; this.status = MyPromise.REJECTED; this.result = result; this.rejectCallbacks.forEach((callback) =&gt; &#123; callback(result); &#125;); &#125;); &#125; //then方法 //两个参数，成功的回调，失败的回调 then(onFULFILLED, onREJECTED) &#123; //Promise的链式，允许then.then需要返回一个Promise return new MyPromise((resolve, reject) =&gt; &#123; // 2. Promise允许then方法参数不是函数时候要省略，所以要判断then方法的两个参数是不是函数 //不是函数，赋值为空函数 onFULFILLED = typeof onFULFILLED === &#x27;function&#x27; ? onFULFILLED : () =&gt; &#123;&#125;; onREJECTED = typeof onREJECTED === &#x27;function&#x27; ? onREJECTED : () =&gt; &#123;&#125;; //判断 if (this.status === MyPromise.PENDING) &#123; //因为resolve 和 reject的方法还没有获取到值 //需要让then中的函数稍后执行，等resolve执行后了再执行then,保存当前的函数参数 this.resolveCallbacks.push(onFULFILLED); this.rejectCallbacks.push(onREJECTED); &#125; if (this.status === MyPromise.FULFILLED) &#123; setTimeout(() =&gt; &#123; onFULFILLED(this.result); &#125;); &#125; if (this.status === MyPromise.REJECTED) &#123; setTimeout(() =&gt; &#123; onREJECTED(this.result); &#125;); &#125; &#125;); &#125;&#125;","categories":[{"name":"JS","slug":"JS","permalink":"http://awesomeboy.cn/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://awesomeboy.cn/tags/JS/"},{"name":"Promise","slug":"Promise","permalink":"http://awesomeboy.cn/tags/Promise/"}],"author":"awesomeboy"},{"title":"LeetCode-113-路径总和2","slug":"LeetCode-113-路径总和2","date":"2023-08-03T03:33:21.000Z","updated":"2023-08-03T03:40:35.767Z","comments":true,"path":"2023/08/03/LeetCode-113-路径总和2/","link":"","permalink":"http://awesomeboy.cn/2023/08/03/LeetCode-113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C2/","excerpt":"","text":"一：题目描述：给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。 叶子节点 是指没有子节点的节点。 二：示例与提示示例 1: 12输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22输出：[[5,4,11,2],[5,8,4,5]] 示例 2: 12输入：root = [1,2,3], targetSum = 5输出：[] 示例 3：12输入：root = [1,2], targetSum = 0输出：[] 提示: 树中节点的数目在范围 [0, 5000] 内 -1000 &lt;= Node.val &lt;= 1000 -1000 &lt;= targetSum &lt;= 1000 三：思路深度优先搜索和回溯 遍历每个节点的时候targetSum减去当前节点值，当遍历到叶子节点时候，如果targetSum为0，说明存在一条路径，满足该路径上的所有节点的和为targetSum 终止条件是遍历到叶子节点时，是否targetSum为0，如果满足存在该路径就把path加入到res结果集中，不存在就return 返回 如果不是叶子节点，递归调用，避免操作空指针，先判断是否存在左右子树，然后将该节点的val值加入到当前path路径中 重要的是回溯，在递归调用之后，将该值从 “path” 数组中移除（回溯），以便探索其他路径。 “pathSum” 函数通过传入根节点、目标和减去根节点值（targetSum - root.val）以及初始路径（只包含根节点的值）来调用 “getPath” 函数。 四：代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @param &#123;number&#125; targetSum * @return &#123;number[][]&#125; *///路径总和var pathSum = function(root, targetSum) &#123; //存放路径的结果集 let res = [] if(!root) return res //单条路径 let path = [root.val] const getPath = (root, targetSum, path) =&gt; &#123; //终止条件 //碰到叶子节点时候 才将路径加入res if(!root.left &amp;&amp; !root.right &amp;&amp; targetSum === 0)&#123; res.push([...path]); // res.push(path) &#125; //不为0 返回 if(!root.left &amp;&amp; !root.right &amp;&amp; !targetSum !== 0) &#123; return &#125; //递归遍历 if(root.left) &#123; // 将节点加入到单条路径中 path.push(root.left.val) //递归 getPath(root.left, targetSum - root.left.val, path) //回溯 path.pop() &#125; if(root.right) &#123; path.push(root.right.val) //递归 getPath(root.right, targetSum - root.right.val, path) path.pop() &#125; // console.log(path) return &#125; getPath(root, targetSum - root.val, path) // console.log(res) return res&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://awesomeboy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"http://awesomeboy.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"深度优先搜索","slug":"深度优先搜索","permalink":"http://awesomeboy.cn/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"name":"回溯","slug":"回溯","permalink":"http://awesomeboy.cn/tags/%E5%9B%9E%E6%BA%AF/"}],"author":"awesomeboy"},{"title":"LeetCode-112-路径总和","slug":"LeetCode-112-路径总和","date":"2023-08-03T03:23:13.000Z","updated":"2023-08-03T03:32:57.619Z","comments":true,"path":"2023/08/03/LeetCode-112-路径总和/","link":"","permalink":"http://awesomeboy.cn/2023/08/03/LeetCode-112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/","excerpt":"","text":"一：题目描述：给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。 叶子节点 是指没有子节点的节点。 二：示例与提示示例 1: 123输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22输出：true解释：等于目标和的根节点到叶节点路径如上图所示。 示例 2: 123456输入：root = [1,2,3], targetSum = 5输出：false解释：树中存在两条根节点到叶子节点的路径：(1 --&gt; 2): 和为 3(1 --&gt; 3): 和为 4不存在 sum = 5 的根节点到叶子节点的路径。 示例 3：123输入：root = [], targetSum = 0输出：false解释：由于树是空的，所以不存在根节点到叶子节点的路径。 提示: 树中节点的数目在范围 [0, 5000] 内 -1000 &lt;= Node.val &lt;= 1000 -1000 &lt;= targetSum &lt;= 1000 三：思路深度优先搜索 targetsum是总和，每次遍历节点时候减去当前节点的值，当遍历到叶子节点时候，如果targetsum减到0，就说明存在一条路径符合该路径上的值全加起来等于targetSum 在每次递归调用时，首先检查终止条件。当遍历到叶子节点时，如果目标和正好为0，则说明找到了符合条件的路径，返回true；否则，返回false 如果当前节点不是叶子节点，需要继续向下递归遍历。首先对左子树调用isPath函数，传递的目标和为targetSum - root.left.val（减去当前节点值）。如果返回值为true，则说明在左子树中找到了符合条件的路径，直接返回true。否则，继续对右子树调用isPath函数，传递的目标和为targetSum - root.right.val（减去当前节点值）。如果返回值为true，则说明在右子树中找到了符合条件的路径，直接返回true。 如果左右子树都没有找到符合条件的路径，则返回false。 最后，主函数hasPathSum首先检查根节点是否为空，如果为空则直接返回false。否则，通过调用isPath函数，传递的目标和为targetSum - root.val（减去根节点值），判断是否存在符合条件的路径。 四：代码12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @param &#123;number&#125; targetSum * @return &#123;boolean&#125; */var hasPathSum = function(root, targetSum) &#123; //后序遍历 const isPath = (root, targetSum) =&gt; &#123; //终止条件 //当遍历到叶子节点时候同时目标值为0 就找到对应的路径 if(!root.left &amp;&amp; !root.right &amp;&amp; targetSum === 0) return true //当遍历到叶子节点时，目标值不为0 则不是返回false if(!root.left &amp;&amp; !root.right &amp;&amp; targetSum !== 0) return false //如果是true才层层返回 if(root.left &amp;&amp; isPath(root.left, targetSum - root.left.val)) return true if(root.right &amp;&amp; isPath(root.right, targetSum - root.right.val)) return true return false &#125; if(!root) return false return isPath(root, targetSum - root.val)&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://awesomeboy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"http://awesomeboy.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"深度优先搜索","slug":"深度优先搜索","permalink":"http://awesomeboy.cn/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"}],"author":"awesomeboy"},{"title":"HTTPS TLS握手","slug":"HTTPS-RSA握手","date":"2023-08-03T01:07:33.000Z","updated":"2023-09-01T12:14:58.444Z","comments":true,"path":"2023/08/03/HTTPS-RSA握手/","link":"","permalink":"http://awesomeboy.cn/2023/08/03/HTTPS-RSA%E6%8F%A1%E6%89%8B/","excerpt":"","text":"RSA握手过程 HTTPS采用了公钥加密和对称加密结合的方式进行数据加密和解密 RSA握手是HTTPS连接建立过程中的一个关键步骤，用于确保通信双方的身份验证和生成对称加密所需的密钥 通过RSA握手过程，客户端和服务器可以协商出一个共享的对称密钥，并确保通信双方的身份验证和数据传输的安全性 通过Wireshark抓包，一共经历了四次握手 TLS第一次握手 客户端向服务器发出Client Hello，客户端向服务器发送一个包含加密套件列表、随机数和其他参数的消息，以表示自己支持的加密算法和通信参数 Random随机数是生成会话秘钥的材料之一 TLS第二次握手 服务器发送ServerHello：服务器从客户端发送的加密套件列表中选择最合适的加密套件，并返回给客户端一个包含自己的证书（包含公钥）、随机数和其他参数的消息。 服务端的密钥套件为：Cipher Suite: TLS_RSA_WITH_AES_128_GCM_SHA256 一般WITH前面有两个算法，这只有RSA，说明密钥交换算法和签名算法都是RSA 握手后使用AES对称算法 随机数是产生会话秘钥的第二个材料 返回给客户端的证书是包含服务器的公钥的，客户端通过CA的公钥来解密获得服务器的公钥 数字证书的签发和验证流程 TLS第三次握手 客户端生成一个随机数(pre-master)，再用服务器的RSA公钥加密该随机数，通过Client key Exchange消息传给服务器 因此，客户端，服务器都有了三个随机数，分别是Client Random，Server Random和pre-master 双方通过这三个随机数生成会话秘钥，用于对后续的HTTP请求响应的加密 生成完会话秘钥后，客户端发送change cipher spec消息给服务端，开始使用会话秘钥进行加密通信 客户端最后再发Encrypted Handshake Message消息把之前数据做一个摘要处理，使用会话秘钥加密发送给服务器，让服务器做验证 TLS第四次握手 服务器也发送一样的消息给客户端，让客户端做验证，如果都没问题，那么握手就完成了，之后就使用会话秘钥进行加密通信了","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://awesomeboy.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"HTTPS","slug":"HTTPS","permalink":"http://awesomeboy.cn/tags/HTTPS/"}],"author":"awesomeboy"},{"title":"HTTP缓存机制","slug":"HTTP缓存机制","date":"2023-08-03T00:08:51.000Z","updated":"2023-08-10T13:48:15.249Z","comments":true,"path":"2023/08/03/HTTP缓存机制/","link":"","permalink":"http://awesomeboy.cn/2023/08/03/HTTP%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/","excerpt":"","text":"HTTP缓存的作用 HTTP缓存机制对于减少网络请求、提高页面加载速度和减轻服务器负载起到了重要的作用 减少网络请求：当浏览器再次请求相同的资源时，在有效期内的缓存可以直接返回给浏览器，无需再次向服务器发送请求，减少了网络带宽的消耗和请求的延迟。 提高页面加载速度：使用缓存可以避免重复下载和传输资源，加快页面加载速度，提高用户体验。 减轻服务器负载：服务器不需要处理重复请求，当缓存可用时，可以减少服务器的负载，提高服务器的性能和吞吐量。 改善移动端性能：移动设备通常具有较慢的网络连接和有限的带宽，使用缓存可以减少数据传输量，降低用户流量消耗。 支持离线浏览：在缺少网络连接或者资源服务器不可用时，缓存可以提供离线浏览的支持，允许用户访问之前缓存的页面或资源。 一：强缓存 HTTP强缓存是通过在HTTP相应头中设置相关字段，可以让浏览器在一定时间内直接从本地存储中获取相应的资源，无需发起网络请求 强缓存通过设置&quot;Cache-Control&quot;和&quot;Expires&quot;字段来实现。 “Cache-Control”是一个指令 public：表示响应可以被任意缓存（包括私有缓存和共享缓存）缓存。 private：表示响应只能被私有缓存（例如浏览器缓存）缓存。 no-cache：表示缓存可以缓存响应，但在使用之前需要重新验证资源的有效性。 max-age：表示缓存的有效时间（以秒为单位）。 “Expires”字段指定资源的到期时间，是一个绝对的时间戳。 进入b站时发起的请求中，请求头对应字段的设置 当浏览器发起请求时，会检查响应头中的”Cache-Control”和”Expires”字段，如果在有效时间内（仍然在缓存有效期内），浏览器将直接从缓存中获取资源。只有在缓存过期后，浏览器才会重新发起请求获取最新的资源。这样可以大大减少网络请求，提高页面加载速度。 缺点 缓存过期问题：强缓存是基于时间来确定缓存是否过期的。但是，如果服务器上的资源在有效期内发生了变化，例如更新了文件或修改了页面内容，由于强缓存的有效时间仍未过期，浏览器无法获知资源已经发生了变化，仍然从缓存中获取旧版本的资源，导致页面内容不是最新的。 不适用于个性化内容：强缓存是基于共享缓存的原则，无法针对不同用户或不同情境提供个性化的内容。如果网站需要根据用户身份、位置或其他条件来展示不同的数据，使用强缓存会导致所有用户都获取相同的缓存内容，无法满足个性化需求。 无法适应动态内容：如果网站包含动态生成的内容或频繁变动的数据，使用强缓存会导致缓存的内容无法及时更新，从而无法及时展示最新的数据。 二：协商缓存 协商缓存解决了强缓存中，无法动态更新服务器最新资源的问题 HTTP协商缓存是一种在客户端和服务器之间进行缓存内容协商的机制，用于提高Web应用程序的性能和效率。它允许客户端和服务器就资源的有效性进行交流，并决定是否使用缓存副本或从服务器获取最新的版本。 常见的请求有两种If-None-Match和If-Modified-Since 请求头部中的If-None-Match和响应头部的ETag字段 响应头部中 Etag：唯一标识响应资源 如果客户端拥有资源的ETag值，它可以将该值包含在If-None-Match头部中发送给服务器。服务器会检查请求的ETag与当前资源的ETag是否匹配，如果匹配，则返回状态码304 Not Modified，告知客户端使用缓存的副本 请求头部中的If-Modified-Since和响应头部的Last-Modified字段 响应头部中的 Last-Modified：标示这个响应资源的最后修改时间； 服务器会检查请求的时间戳与当前资源的最后修改时间是否匹配，如果匹配，则返回状态码304 Not Modified。 协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求。 两种方式区别 ETag比Last-Modified更加精确，因为它可以通过生成一个唯一的标识符来判断资源是否发生了变化，而不仅仅是比较时间戳。 ETag相对于Last-Modified来说在实现上更加灵活，可以根据实际情况选择不同的算法生成标识符 Last-Modified是基于时间的机制，而ETag是基于标识符的机制。 Last-Modified使用资源的最后修改时间来进行协商，而ETag使用唯一的标识符来进行协商。 协商缓存流程图","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://awesomeboy.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://awesomeboy.cn/tags/HTTP/"}],"author":"awesomeboy"},{"title":"LeetCode-513-找树左下角的值","slug":"LeetCode-513-找树左下角的值","date":"2023-08-01T08:15:47.000Z","updated":"2023-08-01T08:21:24.215Z","comments":true,"path":"2023/08/01/LeetCode-513-找树左下角的值/","link":"","permalink":"http://awesomeboy.cn/2023/08/01/LeetCode-513-%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC/","excerpt":"","text":"一：题目描述：给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。 假设二叉树中至少有一个节点。 二：示例与提示示例 1: 12输入: root = [2,1,3]输出: 1 示例 2: 12输入: [1,2,3,4,null,5,6,null,null,7]输出: 7 提示: 二叉树的节点个数的范围是 [1,104] -231 &lt;= Node.val &lt;= 231 - 1 三：思路广度优先搜索 使用层序遍历，遍历每一层，最后一层的第一元素即是最左下角的元素 深度优先搜索 使用curDepth记录下每个节点当前的深度，来查找最大深度的节点 因为先遍历左节点后遍历右节点，所以在同层下一定是左节点先被遍历到。 即找最大深度的节点即是最左下角的节点 四：代码广度优先搜索1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number&#125; */var findBottomLeftValue = function(root) &#123; //层序遍历 let res = [] let queue = [root] while(queue.length)&#123; let length = queue.length const curLevel = [] for(let i = 0; i &lt; length; i++)&#123; let node = queue.shift() curLevel.push(node.val) if(node.left) queue.push(node.left) if(node.right) queue.push(node.right) &#125; res.push(curLevel) &#125; return res[res.length-1][0]&#125;; 深度优先搜索1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number&#125; */var findBottomLeftValue = function(root) &#123; //递归 找到最大深度的叶子节点 let maxDepth = 0 let res = null const dfsTree = (root, curPath) =&gt; &#123; //找叶子节点 if(!root.left &amp;&amp; !root.right)&#123; //找最大叶子节点并更新 if(curPath &gt; maxDepth)&#123; maxDepth = curPath res = root.val &#125; &#125; //左右 root.left &amp;&amp; dfsTree(root.left, curPath + 1) root.right &amp;&amp; dfsTree(root.right, curPath + 1) &#125; dfsTree(root, 1) return res&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://awesomeboy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"http://awesomeboy.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"深度优先搜索","slug":"深度优先搜索","permalink":"http://awesomeboy.cn/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"name":"广度优先搜索","slug":"广度优先搜索","permalink":"http://awesomeboy.cn/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"}],"author":"awesomeboy"},{"title":"HTTPS协议","slug":"HTTPS协议","date":"2023-08-01T03:07:33.000Z","updated":"2023-08-10T13:51:55.554Z","comments":true,"path":"2023/08/01/HTTPS协议/","link":"","permalink":"http://awesomeboy.cn/2023/08/01/HTTPS%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"一：什么是HTTPS？ HTTPS（Hypertext Transfer Protocol Secure）是一种用于在网络上安全传输数据的协议。它是基于HTTP协议的加密版本，通过使用SSL（Secure Sockets Layer）或TLS（Transport Layer Security）协议对通信进行加密和认证，以保护数据的机密性和完整性。 当使用HTTPS时，客户端与服务端之间的通信会进行加密处理，防止第三方窃听和泄露数据。这种加密通过使用公钥和私钥来实现，公钥用于加密数据，而私钥则用于解密数据。 二：HTTPS和HTTP的区别 主要有四个不同的区别 安全性：HTTP是不安全的协议，它规定的数据传输都是明文的，容易被恶意攻击者窃取和篡改。而HTTPS通过使用SSL（Secure Sockets Layer）或TLS（Transport Layer Security）等加密协议，在HTTP的基础上添加了加密层，确保数据在传输过程中的机密性和完整性 端口号：HTTP默认使用80端口进行通信，HTTPS默认使用443端口进行通信。 证书：HTTPS使用数字证书，通常由受信任的第三方机构进行颁发，用于验证服务器的身份。可以防止中间人的攻击，确保通信的安全性 协议速度：由于HTTPS需要进行加密和解密操作，相对于HTTP来说会引入一些额外的开销，导致稍微降低一些性能。但是随着计算机硬件和网络技术的进步，这个差距已经变得越来越小，几乎可以忽略不计。 三：HTTPS工作过程3.1 对称加密 在HTTPS传输中，对称加密是一种使用相同密钥进行加密和解密的加密算法。双方（客户端和服务器）在建立安全通信之前，必须协商一个共享的密钥。这个密钥用于加密传输的数据，以确保数据在传输过程中的机密性和完整性。 尽管对称加密效率高，但存在一个安全性挑战：如何安全地将密钥传输给对方 3.2 非对称加密 在HTTPS传输中，非对称加密（asymmetric encryption）是一种加密方式，使用了两个密钥：公钥（public key）和私钥（private key）。这种加密算法也称为公钥加密（public-key encryption）。 在通信双方之间建立一个安全连接前，服务器会生成一对密钥，包括一个公钥和一个私钥。公钥是可共享给任何人使用的，而私钥则只有服务器拥有并保密。公钥用于加密数据，而私钥则用于解密数据。 当客户端与服务器进行通信时，服务器将其公钥发送给客户端。客户端使用服务器的公钥对要传输的数据进行加密，并将加密后的数据发送回服务器。由于只有服务器持有私钥，因此只有服务器能够解密客户端发送的数据。 生成密钥对：首先，客户端和服务器各自生成一对密钥，包括公钥和私钥。 公钥交换：客户端将自己的公钥发送给服务器，而服务器也将自己的公钥发送给客户端。这个过程可以通过安全的渠道进行，以确保公钥的安全性。 加密数据：客户端要向服务器发送加密数据时，它会使用服务器的公钥对数据进行加密。这样，只有持有服务器的私钥的服务器能够解密这些数据。 解密数据：服务器接收到加密数据后，使用自己的私钥对其进行解密。 3.3 数字证书 HTTPS的数字证书是用于加密和验证网站身份的安全证书。它是由受信任的第三方机构（称为证书颁发机构或CA）签发的，用于确保用户与网站之间的通信是安全和私密的。 数字证书包含以下信息 网站的公钥：公钥用于加密从浏览器到服务器之间的数据传输。 网站的域名：证书会明确指定该数字证书保护的域名。 证书颁发机构的数字签名：数字证书会被证书颁发机构使用其私钥进行签名，以确保证书的真实性和完整性。 生成密钥对：首先，服务器生成一对密钥，包括一个私钥和一个公钥。私钥被服务器保密存储，而公钥则可以公开。 创建证书签名请求（CSR）：服务器使用自己的私钥创建一个证书签名请求（CSR），其中包含有关服务器的信息，如域名、组织等。CSR还包含服务器的公钥。 向证书颁发机构（CA）提交CSR：服务器将CSR发送给一个受信任的证书颁发机构（CA）。CA是一个可靠的第三方实体，负责验证服务器的身份和信息。 CA验证和签名证书：CA接收到CSR后，会对服务器的身份进行验证。这通常包括确认域名的所有权和验证服务器的身份等。如果通过验证，CA将使用自己的私钥对服务器的公钥和其他相关信息进行签名，生成数字证书。 返回数字证书：CA将签名后的数字证书返回给服务器。该证书包含服务器的公钥、服务器信息和CA的数字签名。 客户端与服务器建立连接：当客户端通过浏览器等访问HTTPS网站时，服务器会将其数字证书发送给客户端。 验证数字证书：客户端接收到服务器的数字证书后，会使用预装在其操作系统或浏览器中的信任的根证书颁发机构（Root CA）的公钥来验证证书的真实性和完整性。这些根证书颁发机构的公钥是事先被信任的。 建立安全连接：如果客户端成功验证了证书，它将生成一个会话密钥，并使用服务器的公钥对该密钥进行加密，然后发送给服务器。服务器使用自己的私钥解密会话密钥。现在，服务器和客户端都有了相同的会话密钥，可以使用对称加密算法进行加密和解密通信内容。 安全通信：通过建立的安全连接，客户端和服务器之间的通信将使用会话密钥进行加密和解密，以确保数据的保密性和完整性。 四：HTTPS的优缺点HTTPS优点： 数据传输安全：HTTPS使用加密技术对数据进行加密，使得传输过程中的数据无法被窃听或篡改。这对于敏感信息（如信用卡号码、用户名和密码等）的传输尤为重要。 身份验证和数据完整性：HTTPS利用SSL证书对服务器进行身份验证，确保用户连接到的是真实可信的服务器而非恶意的伪造网站。此外，HTTPS还使用消息验证码（Message Authentication Code）来确保数据的完整性，防止数据在传输过程中被篡改。 排名优化：搜索引擎（如Google）倾向于将使用HTTPS的网站排名更靠前，因为HTTPS提供了更高的安全性和隐私保护。 HTTPS缺点： 性能损失：由于HTTPS需要进行加密和解密操作，会增加数据传输的处理时间和网络延迟，可能导致网页加载速度变慢。 成本和复杂性：为了使用HTTPS，网站需要获取和安装SSL证书，并进行相关配置。这可能需要支付费用，并且对于不熟悉配置的用户来说，可能会涉及一定的技术复杂性。","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://awesomeboy.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"HTTPS","slug":"HTTPS","permalink":"http://awesomeboy.cn/tags/HTTPS/"}],"author":"awesomeboy"},{"title":"HTTP协议","slug":"HTTP协议","date":"2023-07-29T02:19:48.000Z","updated":"2023-08-10T13:50:02.353Z","comments":true,"path":"2023/07/29/HTTP协议/","link":"","permalink":"http://awesomeboy.cn/2023/07/29/HTTP%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"HTTP协议 HTTP 是超文本传输协议，也就是HyperText Transfer Protocol。 HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。 一：HTTP工作过程1.1 地址解析 如果浏览器客户端要请求一个页面，就要先解析请求该页面的URL地址，例如要访问 http: &#x2F;&#x2F; localhost.com: 8080 &#x2F;index.html这个页面， 就要从中分解出协议名，主机名，端口，路径等相关部分 协议名： http 主机名：localhost.com 端口：8080 路径：&#x2F;index.html （访问该文件所在服务器的文件路径，当没有路径名时，就代表访问根目录下事先设置的默认文件，例如index.html） 1.2 封装http请求数据包 对URL解析过后，浏览器就确定了服务器和文件名，就要根据这些信息来生成HTTP请求信息了，HTTP请求一般是GET或POST请求 GET请求格式：GET 路径/文件名 HTTP/1.0 1.3 封装成TCP包，建立TCP链接，三次握手 因为HTTP协议是应用层最高层协议，因此在建立连接前，web浏览器需要先通过网络与服务器通过TCP来建立连接，根据规则，只有当低层协议建立连接之后，才可以进行更高层的协议连接，TCP与IP协议共同构建Internet，TCP&#x2F;IP网络 1.4 应答 服务器接受请求，并根据请求信息返回数据作为应答 1.5 服务器与web客户端断开连接 一般情况下，一旦web客户端获取到了服务器返回的数据，就要断开TCP连接，如果使用长连接，会在一定时间内保持连接，一旦超过一定时间没有发生请求，会自动断开连接 二：HTTP协议格式 首行：POST URL HTTP&#x2F;1.1 请求头部分 空行 请求体 HOST: 表示服务器主机的地址和端口 Content-Length：表示body数据的长度 Content-type：表示body数据的格式 application&#x2F;x-www-form-urlencoded form表单提交数据的格式，body参数格式为，query: {字段：参数} application&#x2F;json body数据为json格式 Connection：keep-alive，表示长连接，HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。 Accept：*&#x2F; * ，表示可以接受任何格式的数据 三：HTTP请求方法3.1 GET请求 GET 的语义是从服务器获取指定的资源，这个资源可以是静态的文本、页面、图片视频等。GET 请求的参数位置一般是写在 URL 中 首行里面的第一个部分就是 GET URL 里面的参数可为空可不为空 GET 请求的 body 一般是空的 3.2 POST请求 POST 的语义是根据请求负荷（报文body）对指定的资源做出处理，具体的处理方式视资源类型而不同。POST 请求携带数据的位置一般是写在报文 body 中，body 中的数据可以是任意格式的数据 首行第一个部分就是 POST URL中的参数一般为空 POST 请求的 body 一般不为空，格式一般由content-type来决定 3.3 GET和POST的请求的区别 安全：指的是请求的方法不会对服务器上的资源进行破坏 幂等：多次执行相同操作，返回的数据是相同的 GET方法一般都是安全和幂等的，因为GET方法是只读操作，不管怎么操作，都是不会去破坏服务器的数据的，因为是只读，所以返回的数据不管是多少次都是一样相同的。可以对GET请求的数据做缓存 POST方法一般都不是安全和幂等的，POST是提交数据的操作，因此会修改服务器的数据，并且会新增数据，所以不是安全和幂等的。 四：HTTP状态码2XX： 类状态码表示服务器成功处理了客户端的请求 200：（成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 204：（无内容） 服务器成功处理了请求，但没有返回任何内容。 206：（部分内容） 服务器成功处理了部分 GET 请求。 3XX： 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向 300：（多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者选择一项操作，或提供操作列表供请求者选择。 302：（临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 304：（未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 4XX： 客户端错误，请求包含语法错误或无法完成请求 400:（错误请求) 服务器不理解请求的语法。 403：（禁止) 服务器拒绝请求。 404：（未找到) 服务器找不到请求的网页。 5XX： 这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错 500：（服务器内部错误） 服务器遇到错误，无法完成请求。 501：（尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 502：（错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。 504：（网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://awesomeboy.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://awesomeboy.cn/tags/HTTP/"}],"author":"awesomeboy"},{"title":"LeetCode-222-完全二叉树的节点个数","slug":"LeetCode-222-完全二叉树的节点个数","date":"2023-07-28T07:02:51.000Z","updated":"2023-07-28T07:11:53.052Z","comments":true,"path":"2023/07/28/LeetCode-222-完全二叉树的节点个数/","link":"","permalink":"http://awesomeboy.cn/2023/07/28/LeetCode-222-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0/","excerpt":"","text":"一：题目描述：给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。 完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。 二：示例与提示示例 1: 12输入：root = [1,2,3,4,5,6]输出：6 示例 2:12输入：root = []输出：0 示例 3：12输入：root = [1]输出：1 提示: 树中节点的数目范围是[0, 5 * 104] 0 &lt;= Node.val &lt;= 5 * 104 题目数据保证输入的树是 完全二叉树 三：思路正常遍历求节点个数 使用层次遍历，遍历每一层元素个数求和即可 使用完全二叉树特性和满二叉树节点个数计算公式 完全二叉树，除最后一层可以没有达到满节点，其余节点都是填满整层的 满二叉树节点个数为2 ^ n - 1，n为该节点的深度 那就先判断子树是否为满二叉树，如果是满二叉树可以直接利用公式，通过判断左外侧和右外侧的深度是否相等即可判断是否为满二叉树 如果不是满二叉树，返回父节点左子树的节点个数和右子树节点个数 + 1即可 四：代码层序遍历求节点个数123456789101112131415161718192021222324252627282930313233343536/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number&#125; */var countNodes = function(root) &#123; //层序遍历 let res = 0 if(!root) return res //队列 let queue = [root] while(queue.length)&#123; //记录队列的长度 let length = queue.length //记录每一层的临时一维数组 let curLevel = [] for(let i = 0; i &lt; length; i++)&#123; //出队 let node = queue.shift() curLevel.push(node.val) //若存在左右子节点入队 if(node.left) queue.push(node.left) if(node.right) queue.push(node.right) &#125; res += curLevel.length &#125; return res&#125;; 完全二叉树特性123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number&#125; */var countNodes = function(root) &#123; //完全二叉树解法 节点为2^n - 1 n为深度 if(!root) return 0 //终止条件 let leftDepth = 1 let rightDepth = 1 // let leftNode = root.left let rightNode = root.right while(leftNode)&#123; //不断遍历左节点 直到为空 leftNode = leftNode.left //左侧深度++ leftDepth++ &#125; while(rightNode)&#123; rightNode = rightNode.right rightDepth++ &#125; //判断是否该节点下的子树是否为满二叉树 if(leftDepth === rightDepth)&#123; return Math.pow(2, leftDepth) - 1 &#125; //左 let leftNumber = countNodes(root.left) //右 let rightNumber = countNodes(root.right) //中 return leftNumber + rightNumber + 1&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://awesomeboy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"http://awesomeboy.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"广度优先搜索","slug":"广度优先搜索","permalink":"http://awesomeboy.cn/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"}],"author":"awesomeboy"},{"title":"实现vue双向数据绑定","slug":"vue双向数据绑定原理","date":"2023-07-27T09:07:30.000Z","updated":"2023-08-10T13:53:08.819Z","comments":true,"path":"2023/07/27/vue双向数据绑定原理/","link":"","permalink":"http://awesomeboy.cn/2023/07/27/vue%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86/","excerpt":"","text":"一：什么是双向数据绑定？1.1 Vue中MVVM模型 模型（Model）表示应用程序的数据和业务逻辑。这可以是从后端API获取的数据，或者在前端应用程序内部定义的数据。 视图（View）是用户界面的可见部分，通常以HTML模板的形式存在。它负责将数据呈现给用户，并处理用户的输入事件。 视图模型（ViewModel）是模型和视图之间的中间层，它负责管理视图所需的数据，并处理视图中发生的事件。视图模型通过双向数据绑定将模型的状态与视图保持同步。 MVVM即是“Model-View-ViewModel”，它是一种设计模式，用于实现用户界面的分离和交互。 主要职责 View中视图变化，通过ViewModel中的监听器反馈给model进行数据的更新 Model中数据的变化，通过ViewModel中的解析器反馈给View进行视图的更新 1.2 双向数据绑定原理 vue.js是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调来渲染视图。 二：实现双向数据绑定进行数据的准备，我们目的是为了实现双向数据绑定 模板解析，姓名年龄渲染出来的内容是将括号内容替换成我们的数据 数据绑定，文本框的内容和上方渲染的数据是一致的，通过修改文本框上方渲染的内容同步修改 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h3&gt;姓名：&#123;&#123;name&#125;&#125;&lt;/h3&gt; &lt;h3&gt;年龄：&#123;&#123;more.age&#125;&#125;&lt;/h3&gt; 输入姓名：&lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt; &lt;br&gt; 输入年龄：&lt;input type=&quot;text&quot; v-model=&quot;more.age&quot;&gt; &lt;/div&gt; &lt;!-- 引入自己的vue.js文件 --&gt; &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; const vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; name: &#x27;张三&#x27;, more: &#123; age: 18 &#125; &#125; &#125;) console.log(vm); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 数据初始化 123456789//定义vue类class Vue &#123; //构造函数 constructor(obj_instance) &#123; //执行初始化 this.$data = obj_instance.data console.log(this.$data);&#125; 我们创建的vm实例已经传给vue类，为了模拟vue中$data，也在构造函数利用this.$data来存储我们创建的vm实例中的data数据 只是此时的数据都还不是响应式的 2.1 数据劫持1234567891011121314151617181920212223242526272829303132//数据劫持 - 监听实例中的数据function Observer(data_instance) &#123; //递归出口 if (!data_instance || typeof data_instance !== &#x27;object&#x27;) return; //object.keys以数组形式返回对象中的属性 //遍历属性属性，通过obj.defineProperty来进行数据监视 Object.keys(data_instance).forEach((key) =&gt; &#123; let value = data_instance[key]; //递归将 子属性的值进行数据劫持 Observer(value); //三个参数，(对象， 监视的属性， 回调) Object.defineProperty(data_instance, key, &#123; //可以枚举 属性描述符可以改变 enumerable: true, configurable: true, //通过getter 和 setter函数进行数据监视 get() &#123; //访问属性时候 调用getter函数 返回return 值 console.log(`访问了属性：$&#123;key&#125; -&gt; 值为$&#123;value&#125;`); // console.log(Dependency.temp); return value; &#125;, //修改的新属性值 set(newValue) &#123; console.log(`将属性：$&#123;key&#125;的值$&#123;value&#125; 修改为-&gt;$&#123;newValue&#125;`); value = newValue; Observer(newValue); &#125;, &#125;); &#125;);&#125; Vue.js是通过Object.defineProperty来实现对数据的监视 data_instance是一个对象，通过Object.keys来实现对对象以数组形式放回 将数组中的每一项通过Object.defineProperty进行数据监视，设置getter和setter，当访问数据和修改数据时调用 还要通过递归去将每一项的子属性的值都进行数据监听 2.2 模板解析 对每个元素节点的指令进行扫描跟解析,根据指令模板替换数据,以及绑定相应的更新函数 12345678910111213//创建vue类class Vue &#123; //执行初始化 constructor(obj_instance) &#123; this.$data = obj_instance.data; //调用Observe - 对data中的每个数据进行数据劫持 //对data中的每一项进行响应式处理 Observer(this.$data); //解析模板 Compile(obj_instance.el, this); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142//HTML模板解析 - &#123;&#123;&#125;&#125;替换domfunction Compile(element, vm) &#123; //获取id为app的dom元素 绑定到vm.$el上 vm.$el = document.querySelector(element); // console.log(vm.$el); //创建文档碎片节点 临时存储数据的改变 避免过频繁地操作dom 文档片段存储在于内存中不在dom中，元素的改变不会引起页面的回流 const fragment = document.createDocumentFragment(); //循环将vm.$el中的dom元素 插入到fragment文档碎片中 let child; while ((child = vm.$el.firstChild)) &#123; //使用fragment.append会将原先dom删除 fragment.append(child); &#125; // console.log(fragment); // console.log(fragment.childNodes); //要将&#123;&#123;&#125;&#125;替换 所以节点类型为 1 和 3为h3 fragment_compile(fragment); //替换文档碎片内容 function fragment_compile(node) &#123; //正则匹配 &#123;&#123; 属性 &#125;&#125; const pattern = /\\&#123;\\&#123;\\s*(\\S+)s*&#125;\\&#125;/; //如果节点为文本节点 if (node.nodeType === 3) &#123; const temp = node.nodeValue //输出正则验证过后 去除换行符等一些不需要的元素 返回的数组 &quot;&#123;&#123; name &#125;&#125;&quot; &quot;name&quot; 需要索引为1的值 不需要&#123;&#123;&#125;&#125; const result_regex = pattern.exec(node.nodeValue); if (result_regex) &#123; // console.log(vm.$data[result_regex[1]]); const arr = result_regex[1].split(&#x27;.&#x27;); //reduce迭代累加器 遍历arr数组 total[current] 不断地迭代的链式获取最终的值 ，reduce两个参数 ， 第一个参数是个回调函数，第二参数vm.$data是初始值，total的初始值 const value = arr.reduce( (total, current) =&gt; total[current], vm.$data ); //将 &#123;&#123;name&#125;&#125; &#123;&#123;more.age&#125;&#125; 替换成value node.nodeValue = temp.replace(pattern, value); &#125; return; &#125; //将文档碎片 fragment渲染到el中 vm.$el.appendChild(fragment);&#125; 开辟一个内存空间，创建fragment文档碎片，不属于dom，属于内存区域，当所有数据更新完成时再渲染页面，避免过多操作dom 将vm.$el中的dom元素 ，通过appendChild插入到fragment文档碎片中，原先dom中的元素会被移除，存放在fragment文档碎片之中 替换文档碎片中 括号中的内容，首先得遍历fragment中的node节点也要通过递归遍历， 通过正则表达式来匹配 内容 12//递归遍历node.childNodes.forEach((child) =&gt; fragment_compile(child)); 要将name 和 more.age 替换成数据，通过reduce方法获取数据 reduce迭代累加器 遍历arr数组 total[current] 不断地迭代的链式获取最终的值 ，reduce两个参数 ， 第一个参数是个回调函数，第二参数vm.$data是初始值，total的初始值，无法通过vm.$data[more.age]来获取数据 1234const value = arr.reduce( (total, current) =&gt; total[current], vm.$data); vm.$data[more.age] 将括号内内容替换成value 1node.nodeValue = temp.replace(pattern, value); 最终将文档碎片 fragment渲染到el中 1vm.$el.appendChild(fragment); 2.3 订阅者-发布者模式12345678910111213141516//依赖 --收集和通知订阅者class Dependency &#123; constructor() &#123; //收集订阅者 this.subscribers = []; &#125; //添加订阅者 addSub(sub) &#123; this.subscribers.push(sub); &#125; //通知订阅者 notify() &#123; //遍历订阅者 让订阅者触发自己的update函数 this.subscribers.forEach((sub) =&gt; sub.update()); &#125;&#125; 数组用于收集订阅者 添加订阅者的方法 当数据修改时需要通知订阅者，触发自己的update更新函数来更新视图 12345678910111213141516171819202122//订阅者class Watcher &#123; //三个参数 constructor(vm, key, callback) &#123; this.vm = vm; this.key = key; this.callback = callback; //临时属性 --触发getter //因为想要将watcher实例添加到依赖的数组中 Dependency.temp = this; //触发getter时候 将订阅者实例添加到订阅者数组中 key.split(&#x27;.&#x27;).reduce((total, current) =&gt; total[current], vm.$data ) //避免多次重复添加到订阅者数组中 Dependency.temp = null &#125; //更新函数 update() &#123; //获取属性值 const value = this.key.split(&#x27;.&#x27;).reduce((total, current) =&gt; total[current], this.vm.$data ) this.callback(value); &#125;&#125; 将watcher类实例添加到Dep数组中来实现数据视图的绑定 123456 //因为想要将watcher实例添加到依赖的数组中Dependency.temp = this; //触发getter时候 将订阅者实例添加到订阅者数组中 key.split(&#x27;.&#x27;).reduce((total, current) =&gt; total[current], vm.$data ) //避免多次重复添加到订阅者数组中 Dependency.temp = null 创建Dependency.temp用于临时存储创建的watcher实例，触发getter 在observer类中触发getter时，将临时存储的watcher实例添加到Dependency的存储订阅者的数组之中 1234get() &#123; //将订阅者实例添加到订阅者数组中 Dependency.temp &amp;&amp; dependency.addSub(Dependency.temp)&#125;, 同时为了避免多次重复，添加watcher实例，在添加该实例过后，赋空值 2.4 v-model数据绑定视图与数据的绑定 在fragment_compile（）函数中 1234567891011121314151617181920212223242526//找v-model属性的元素 更改其nodeValueif(node.nodeType === 1 &amp;&amp; node.nodeName === &#x27;INPUT&#x27;)&#123; const attr = Array.from(node.attributes) attr.forEach(item =&gt; &#123; if(item.nodeName === &#x27;v-model&#x27;)&#123; // console.log(item.nodeValue); //修改nodeValue const value = item.nodeValue.split(&#x27;.&#x27;).reduce((total, current) =&gt; total[current], vm.$data) // console.log(value); node.value = value //创建watcher实例 new Watcher(vm, item.nodeValue, newValue =&gt; &#123; node.value = newValue &#125;) //触发input事件来通过视图修改数据 node.addEventListener(&#x27;input&#x27;, e =&gt; &#123; const arr1 = item.nodeValue.split(&#x27;.&#x27;) // console.log(arr1); const arr2 = arr1.slice(0, arr1.length - 1) const final = arr2.reduce((total, current) =&gt; total[current], vm.$data) // console.log(final); final[arr1[arr1.length - 1]] = e.target.value &#125;) &#125; &#125;)&#125; 在文档碎片fragment中遍历node，通过node.attributes方法来找到属性值为v-model的node节点 遍历的节点 item.nodeValue，是name, more.age 通过reduce方法来获取到vm.$data上对应属性的属性值 将node.value 修改为属性值，此时将文本框中的内容和属性值相绑定 然后需要通过，文本框修改数据同时修改上方的视图，那就需要用到addEvetListener方法添加input事件 然后通过文本框视图来修改数据 1final[arr1[arr1.length - 1]] = e.target.value 三：完整代码html 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h3&gt;姓名：&#123;&#123;name&#125;&#125;&lt;/h3&gt; &lt;h3&gt;年龄：&#123;&#123;more.age&#125;&#125;&lt;/h3&gt; 输入姓名：&lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt; &lt;br&gt; 输入年龄：&lt;input type=&quot;text&quot; v-model=&quot;more.age&quot;&gt; &lt;/div&gt; &lt;!-- 引入自己的vue.js文件 --&gt; &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; const vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; name: &#x27;张三&#x27;, more: &#123; age: 18 &#125; &#125; &#125;) console.log(vm); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; vue.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170//创建vue类class Vue &#123; //执行初始化 constructor(obj_instance) &#123; this.$data = obj_instance.data; //调用Observe - 对data中的每个数据进行数据劫持 //对data中的每一项进行响应式处理 Observer(this.$data); //解析模板 Compile(obj_instance.el, this); &#125;&#125;//数据劫持 - 监听实例中的数据function Observer(data_instance) &#123; //递归出口 if (!data_instance || typeof data_instance !== &#x27;object&#x27;) return; //创建订阅者实例 const dependency = new Dependency() //object.keys以数组形式返回对象中的属性 // console.log(Object.keys(data_instance)); //遍历属性属性，通过obj.defineProperty来进行数据监视 Object.keys(data_instance).forEach((key) =&gt; &#123; let value = data_instance[key]; //递归将 子属性的值进行数据劫持 Observer(value); //三个参数，(对象， 监视的属性， 回调) Object.defineProperty(data_instance, key, &#123; //可以枚举 属性描述符可以改变 enumerable: true, configurable: true, //通过getter 和 setter函数进行数据监视 get() &#123; //访问属性时候 调用getter函数 返回return 值 console.log(`访问了属性：$&#123;key&#125; -&gt; 值为$&#123;value&#125;`); // console.log(Dependency.temp); //将订阅者实例添加到订阅者数组中 Dependency.temp &amp;&amp; dependency.addSub(Dependency.temp) return value; &#125;, //修改的新属性值 set(newValue) &#123; console.log(`将属性：$&#123;key&#125;的值$&#123;value&#125; 修改为-&gt;$&#123;newValue&#125;`); value = newValue; Observer(newValue); dependency.notify() &#125;, &#125;); &#125;);&#125;//HTML模板解析 - &#123;&#123;&#125;&#125;替换domfunction Compile(element, vm) &#123; //获取id为app的dom元素 绑定到vm.$el上 vm.$el = document.querySelector(element); // console.log(vm.$el); //创建文档碎片节点 临时存储数据的改变 避免过频繁地操作dom 文档片段存储在于内存中不在dom中，元素的改变不会引起页面的回流 const fragment = document.createDocumentFragment(); //循环将vm.$el中的dom元素 插入到fragment文档碎片中 let child; while ((child = vm.$el.firstChild)) &#123; //使用fragment.append会将原先dom删除 fragment.append(child); &#125; // console.log(fragment); // console.log(fragment.childNodes); //要将&#123;&#123;&#125;&#125;替换 所以节点类型为 1 和 3为h3 fragment_compile(fragment); //替换文档碎片内容 function fragment_compile(node) &#123; //正则匹配 &#123;&#123; 属性 &#125;&#125; const pattern = /\\&#123;\\&#123;\\s*(\\S+)s*&#125;\\&#125;/; //如果节点为文本节点 if (node.nodeType === 3) &#123; const temp = node.nodeValue //输出正则验证过后 去除换行符等一些不需要的元素 返回的数组 &quot;&#123;&#123; name &#125;&#125;&quot; &quot;name&quot; 需要索引为1的值 不需要&#123;&#123;&#125;&#125; const result_regex = pattern.exec(node.nodeValue); // console.log(result_regex); if (result_regex) &#123; // console.log(vm.$data[result_regex[1]]); const arr = result_regex[1].split(&#x27;.&#x27;); //reduce迭代累加器 遍历arr数组 total[current] 不断地迭代的链式获取最终的值 ，reduce两个参数 ， 第一个参数是个回调函数，第二参数vm.$data是初始值，total的初始值 const value = arr.reduce( (total, current) =&gt; total[current], vm.$data ); //将 &#123;&#123;name&#125;&#125; &#123;&#123;more.age&#125;&#125; 替换成value node.nodeValue = temp.replace(pattern, value); //文档碎片替换的时候添加创建订阅者 new Watcher(vm, result_regex[1], newValue =&gt; &#123; //wacther的回调函数 会将文档碎片中的nodevalue更新为我们修改的newValue node.nodeValue = temp.replace(pattern, newValue); &#125;); &#125; return; &#125; //找v-model属性的元素 更改其nodeValue if(node.nodeType === 1 &amp;&amp; node.nodeName === &#x27;INPUT&#x27;)&#123; const attr = Array.from(node.attributes) attr.forEach(item =&gt; &#123; if(item.nodeName === &#x27;v-model&#x27;)&#123; console.log(item.nodeValue); //修改nodeValue const value = item.nodeValue.split(&#x27;.&#x27;).reduce((total, current) =&gt; total[current], vm.$data) // console.log(value); node.value = value //创建watcher实例 new Watcher(vm, item.nodeValue, newValue =&gt; &#123; node.value = newValue &#125;) //触发input事件来通过视图修改数据 node.addEventListener(&#x27;input&#x27;, e =&gt; &#123; const arr1 = item.nodeValue.split(&#x27;.&#x27;) // console.log(arr1); const arr2 = arr1.slice(0, arr1.length - 1) const final = arr2.reduce((total, current) =&gt; total[current], vm.$data) // console.log(final); final[arr1[arr1.length - 1]] = e.target.value &#125;) &#125; &#125;) &#125; //递归遍历 node.childNodes.forEach((child) =&gt; fragment_compile(child)); &#125; //将文档碎片 fragment渲染到el中 vm.$el.appendChild(fragment);&#125;//依赖 --收集和通知订阅者class Dependency &#123; constructor() &#123; //收集订阅者 this.subscribers = []; &#125; //添加订阅者 addSub(sub) &#123; this.subscribers.push(sub); &#125; //通知订阅者 notify() &#123; //遍历订阅者 让订阅者触发自己的update函数 this.subscribers.forEach((sub) =&gt; sub.update()); &#125;&#125;//订阅者class Watcher &#123; //三个参数 constructor(vm, key, callback) &#123; this.vm = vm; this.key = key; this.callback = callback; //临时属性 --触发getter //因为想要将watcher实例添加到依赖的数组中 Dependency.temp = this; //触发getter时候 将订阅者实例添加到订阅者数组中 key.split(&#x27;.&#x27;).reduce((total, current) =&gt; total[current], vm.$data ) //避免多次重复添加到订阅者数组中 Dependency.temp = null &#125; //更新函数 update() &#123; //获取属性值 const value = this.key.split(&#x27;.&#x27;).reduce((total, current) =&gt; total[current], this.vm.$data ) this.callback(value); &#125;&#125;","categories":[{"name":"JS","slug":"JS","permalink":"http://awesomeboy.cn/categories/JS/"},{"name":"Vue","slug":"Vue","permalink":"http://awesomeboy.cn/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://awesomeboy.cn/tags/Vue/"}],"author":"awesomeboy"},{"title":"LeetCode-116-填充每个节点的下一个右侧节点指针","slug":"LeetCode-116-填充每个节点的下一个右侧节点指针","date":"2023-07-25T08:19:45.000Z","updated":"2023-07-25T08:29:44.037Z","comments":true,"path":"2023/07/25/LeetCode-116-填充每个节点的下一个右侧节点指针/","link":"","permalink":"http://awesomeboy.cn/2023/07/25/LeetCode-116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88/","excerpt":"","text":"一：题目描述：给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下： 123456struct Node &#123; int val; Node *left; Node *right; Node *next;&#125; 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。 初始状态下，所有 next 指针都被设置为 NULL。 二：示例与提示示例 1: 123输入：root = [1,2,3,4,5,6,7]输出：[1,#,2,3,#,4,5,6,7,#]解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，&#x27;#&#x27; 标志着每一层的结束。 示例 2:12输入：root = []输出：[] 提示: 树中节点的数量在 [0, 212 - 1] 范围内 -1000 &lt;= node.val &lt;= 1000 三：思路广度优先搜索 层序遍历，找到每层的元素将其依次顺次的连接 就需要知道该node节点的前一个或者后一个节点 四：代码123456789101112131415161718192021222324252627282930313233/** * // Definition for a Node. * function Node(val, left, right, next) &#123; * this.val = val === undefined ? null : val; * this.left = left === undefined ? null : left; * this.right = right === undefined ? null : right; * this.next = next === undefined ? null : next; * &#125;; *//** * @param &#123;Node&#125; root * @return &#123;Node&#125; */var connect = function(root) &#123; //层序遍历 if(!root) return root let queue = [] queue.push(root) while(queue.length)&#123; let length = queue.length for(let i = 0; i &lt; length; i++)&#123; let node = queue.shift() //让弹出的node 连接 队列的第一个元素 即是层次中的元素依次相连 if(i &lt; length-1)&#123; node.next = queue[0] &#125; if(node.left) queue.push(node.left) if(node.right) queue.push(node.right) &#125; &#125; return root&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://awesomeboy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"http://awesomeboy.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"广度优先搜索","slug":"广度优先搜索","permalink":"http://awesomeboy.cn/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"}],"author":"awesomeboy"},{"title":"二叉树的遍历","slug":"二叉树的遍历","date":"2023-07-25T03:24:02.000Z","updated":"2023-08-05T07:59:12.454Z","comments":true,"path":"2023/07/25/二叉树的遍历/","link":"","permalink":"http://awesomeboy.cn/2023/07/25/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/","excerpt":"","text":"以力扣的题为例 题目：给你二叉树的根节点 root ，返回它节点值的 前序 遍历。 12输入：root = [1,null,2,3]输出：[1,2,3] 一：二叉树的递归遍历前序递归遍历123456789101112131415161718192021/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number[]&#125; *///前序遍历 中左右var preorderTraversal = function(root, res = []) &#123; //递归法 if(!root) return res res.push(root.val) preorderTraversal(root.left, res) preorderTraversal(root.right, res) return res&#125;; 中序递归遍历123456789101112131415161718192021/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number[]&#125; *///前序遍历 中左右var preorderTraversal = function(root, res = []) &#123; //递归法 if(!root) return res inorderTraversal(root.left, res) res.push(root.val) inorderTraversal(root.right, res) return res&#125;; 后序递归遍历123456789101112131415161718192021/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number[]&#125; */ //左右中var postorderTraversal = function(root, res = []) &#123; //递归 if(!root) return res postorderTraversal(root.left, res) postorderTraversal(root.right, res) res.push(root.val) return res&#125;; 二：二叉树的迭代遍历前序的迭代遍历 递归的迭代遍历理论上都是可以用栈来模拟的 前序遍历 即中左右，需要注意的是，由于栈的数据结构先进后出，所以入栈顺序应为 右 左 1234567891011121314151617//前序遍历 中左右var preorderTraversal = function(root, res = []) &#123; //栈 //迭代法 if(!root) return res const stack = [] stack.push(root) let node = null while(stack.length)&#123; node = stack.pop() res.push(node.val) //向将右子节点入栈 再将左子节点入栈 if(node.right) stack.push(node.right) if(node.left) stack.push(node.left) &#125; return res&#125;; 后序的迭代遍历 后序的迭代遍历和前序很类似 访问的节点都是为当前需要处理的节点 只需要将前序的入栈顺序颠倒一下，最后将数组反转一下即可 1234567891011121314var postorderTraversal = function(root, res = []) &#123; //迭代 if(!root) return res const stack = [] stack.push(root) let node = null while(stack.length)&#123; node = stack.pop() res.push(node.val) if(node.left) stack.push(node.left) if(node.right) stack.push(node.right) &#125; return res.reverse()&#125;; 中序的迭代遍历 中序遍历的迭代遍历跟前序后序的迭代遍历有所不同 由于中序的访问节点和当前要处理的节点不是一个节点，所以需要用指针来进行处理 中序 – 左 中 右 入栈顺序 — 左 右 出栈顺序 — 左 中 右 即先遍历左子节点，访问到的左子节点加入栈中 若子节点为空，弹出栈顶元素 若右子节点为空，弹出栈顶元素 12345678910111213141516171819202122232425var inorderTraversal = function(root, res = []) &#123; // 迭代 //入栈的 左 -&gt; 右 //出栈 左 -&gt; 中 -&gt; 右 if(!root) return res const stack = [] let cur = root while(cur || stack.length)&#123; //向左边遍历 入栈 if(cur)&#123; stack.push(cur) cur = cur.left &#125;else&#123; //左 中 //弹出 cur = stack.pop() //加入数组 res.push(cur.val) //右 cur = cur.right &#125; &#125; return res&#125;; 三：二叉树的层序遍历 层序遍历，即每层输出元素。 利用队列去实现，类似于广度优先搜索。 将每层的元素放入队列中，同时记录下每层元素的个数 出队的同时，判断是否有子节点，如果有将其入队 这个时候就会遇到例如第二层第三层元素在同一队列，那么当时记录下的元素个数size就起作用了 每次出队的同时，size–，来控制将队列中的该层元素对应出队成功 1234567891011121314151617181920212223242526272829var levelOrder = function(root) &#123; //层序遍历 利用队列去实现 类似与广度优先搜索一样 let queue = [] //用于存放最终的二位数组 let res = [] //如果根节点为空返回空数组 if(!root) return res //把根节点放入队列中 queue.push(root) //循环终止条件为队列为0 while(queue.length !== 0)&#123; //记录下每层的元素个数 let length = queue.length //用于存放每层元素的一维数组 let curLevel = [] for(let i = 0; i &lt; length; i++)&#123; //弹出队列中的第一个元素 并将其加入到curlevel中 let node = queue.shift() curLevel.push(node.val) //判断是否存在左右子节点 if(node.left) queue.push(node.left) if(node.right) queue.push(node.right) &#125; //将每层curlevel加入到最终数组中 res.push(curLevel) &#125; return res&#125;;","categories":[{"name":"JS","slug":"JS","permalink":"http://awesomeboy.cn/categories/JS/"},{"name":"数据结构","slug":"数据结构","permalink":"http://awesomeboy.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"http://awesomeboy.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"JS","slug":"JS","permalink":"http://awesomeboy.cn/tags/JS/"},{"name":"数据结构","slug":"数据结构","permalink":"http://awesomeboy.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"author":"awesomeboy"},{"title":"实现二叉搜索树","slug":"实现二叉排序树","date":"2023-07-18T02:35:54.000Z","updated":"2023-08-05T07:58:07.849Z","comments":true,"path":"2023/07/18/实现二叉排序树/","link":"","permalink":"http://awesomeboy.cn/2023/07/18/%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/","excerpt":"","text":"一：二叉树和二叉搜索树 二叉树中的节点最多只能有两个子节点：一个是左侧子节点，另一个是右侧子节点。这个定义有助于我们写出更高效地在树中插入、查找和删除节点的算法，二叉树在计算机科学中的应用非常广泛。 二叉搜索树（BST）是二叉树的一种，但是只允许你在左侧节点存储（比父节点）小的值，在右侧节点存储（比父节点）大的值。 二：实现二叉搜索树2.1 创建Node类表示二叉搜索树中的每个节点123456789101112//二叉树的存储结构为class Node&#123; constructor(data, left, right) &#123; this.data = data this.left = left this.right = right //若有相同的元素插入节点，就放弃插入，count++ this.count = 1 &#125;&#125; 该图为二叉搜索树数据结构的组织方式，对于树，我们使用两个指针，一个指向左侧子节点，一个指向右侧右节点 2.2 创建BSTree 类的基本结构1234567891011121314151617181920212223242526272829303132333435class BSTree &#123; constructor() &#123; this.root = null; &#125; // 删除一个节点 _removeNode(node, data) &#123; &#125; // 删除给定的数据节点 remove(data) &#123; this.root = this._removeNode(this.root, data); &#125; // 向二叉树中插入节点 insert(data) &#123; &#125; // 寻找给定数据的节点 find(data) &#123; &#125; // 获得最小值的节点 getMinNode(node = this.root) &#123; &#125; // 获得最大值的节点 getMaxNode(node = this.root) &#123; &#125;&#125; 2.3 实现insert()方法1234567891011121314151617181920212223242526272829303132333435363738394041//向二叉树插入节点insert (data)&#123; let newNode = new Node(data, null, null) //更新根节点的值 if (this.root === null) &#123; this.root = newNode &#125; else &#123; //更新当前节点的值 let currentNode = this.root //父节点就是空 let parentNode = null while (true) &#123; //更新父节点 parentNode = currentNode //判断插入节点值在左子树还是右子树 if (newNode.data &lt; currentNode.data) &#123; //更新当前节点 currentNode = currentNode.left if (!currentNode) &#123; parentNode.left = newNode break &#125; &#125; else if (newNode.data &gt; currentNode.data) &#123; currentNode = currentNode.right if (!currentNode) &#123; parentNode.right = newNode break &#125; &#125; else if (newNode.data === currentNode.data) &#123; //如果相同数据 count++ 不做处理 currentNode.count++ break &#125; &#125; &#125;&#125; 首先创建一个新的节点newNode，该节点包含要插入的数据 检查根节点是否为空，若为空，说明这是第一个插入的节点，将根节点指向newNode 如果根节点不为空，则需要找到合适的位置插入该节点 初始化当前节点currentNode为根节点this.root，并且初始化父节点parentNode为空 进入循环，直到找到合适的位置插入节点或者遇到相同的数据 在每次循环中，更新父节点parentNode为当前节点currentNode 判断要插入的节点值和当前节点值的大小关系 如果要插入的节点值小于当前节点值，说明要插入的节点应该在当前节点的左子树中 更新当前节点为当前节点的左子节点 currentNode.left 如果当前节点的左子节点为空，说明找到了插入位置，将新节点 newNode 设置为当前节点的左子节点，并且跳出循环 如果要插入的节点值大于当前节点值，说明要插入的节点应该在当前节点的右子树中 更新当前节点为当前节点的右子节点 currentNode.right 如果当前节点的右子节点为空，说明找到了插入位置，将新节点 newNode 设置为当前节点的右子节点，并且跳出循环 如果要插入的节点值等于当前节点值，说明要插入的节点与当前节点的值相同。 将当前节点的计数器 count 加一，表示重复出现的次数。 跳出循环。 2.4 实现find()方法123456789101112131415//寻找给定数据的节点find (data)&#123; let currentNode = this.root while (currentNode) &#123; if (currentNode.data == data) &#123; return currentNode &#125; else if (currentNode.data &lt; data) &#123; currentNode = currentNode.right &#125; else &#123; currentNode = currentNode.left &#125; &#125; return null&#125; 2.5 实现getMinNode()和getMaxNode()方法12345678910111213141516171819//获取最小值getMinNode (node = this.root)&#123; let currentNode = node while (currentNode.left) &#123; currentNode = currentNode.left &#125; return currentNode&#125;//获取最大值getMaxNode (node = this.root)&#123; let currentNode = node while (currentNode.right) &#123; currentNode = currentNode.right &#125; return currentNode&#125; 2.6 实现remove()方法12345678910111213141516171819202122232425262728293031323334353637383940414243//删除节点，实例中不应调用_removeNode (node, data)&#123; if (node === null) &#123; return null &#125; //找到要删除的节点的了 if (data === node.data) &#123; //分三种情况 //1. 要删除的节点为叶子结点 if (node.left === null &amp;&amp; node.right === null) &#123; return null &#125; //2. 没有左子节点的节点 if (node.left === null) return node.right // 没有右子节点的节点 if (node.right === null) return node.left //3.有两个子节点的节点 //找到待删除节点的右子树的最小值赋值给临时节点tmpNode //将tmpNode赋值给node 就说明用右子树的最小值来代替待删除节点 let tmpNode = this.getMinNode(node.right) //tmpNode赋值给待删除节点 node.data = tmpNode.data //删除临时节点 node.right = this._removeNode(node.right, tmpNode.data) return node &#125; else if (data &lt; node.data) &#123; //待删除节点在左子树上 node.left = this._removeNode(node.left, data) return node &#125; else &#123; //待删除节点在右子树上 node.right = this._removeNode(node.right, data) return node &#125;&#125;//删除节点remove (data)&#123; this.root = this._removeNode(this.root, data);&#125; 代码接收两个参数：data表示待删除的节点的值，node表示当前递归调用的节点。 如果待删除节点的值等于当前节点的值（data == node.data），则进入条件判断。 如果当前节点是叶子节点（即没有左子节点和右子节点），则将其置为null，表示删除该节点。 如果当前节点只有左子节点而没有右子节点，则返回其左子节点，将其作为当前节点的父节点的新子节点。 如果当前节点只有右子节点而没有左子节点，则返回其右子节点，将其作为当前节点的父节点的新子节点。 如果当前节点既有左子节点又有右子节点，则需要找到待删除节点的右子树上的最小值来替代待删除节点。 通过调用getMinNode(node.right)方法，找到右子树上的最小值所在的节点，并将其赋值给临时节点tmpNode。 将临时节点tmpNode的值复制到待删除节点node，相当于用右子树上的最小值替代了待删除节点。 再次递归调用_removeNode()方法，传入当前节点的右子节点和临时节点的值，以删除右子树上的最小值节点。 最后，返回当前节点node，表示删除操作完成。 如果待删除节点的值小于当前节点的值（data &lt; node.data），则递归调用_removeNode()方法，传入当前节点的左子节点和待删除节点的值，以在左子树上继续删除操作。 如果待删除节点的值大于当前节点的值，则递归调用_removeNode()方法，传入当前节点的右子节点和待删除节点的值，以在右子树上继续删除操作。 最终，整个删除操作完成后，返回当前节点node，并将其作为父节点的新子节点。 三：测试数据1234567891011121314let myTree = new BSTree();myTree.insert(20);myTree.insert(13);myTree.insert(7);myTree.insert(9);myTree.insert(15);myTree.insert(14);myTree.insert(42);myTree.insert(22);myTree.insert(21);myTree.insert(24);myTree.insert(57); 1234console.log(myTree.getMaxNode()); console.log(myTree.getMinNode()); myTree.remove(7)console.log(myTree.find(7)); 四：全部代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157//二叉树的存储结构为class Node&#123; constructor(data, left, right) &#123; this.data = data this.left = left this.right = right //若有相同的元素插入节点，就放弃插入，count++ this.count = 1 &#125;&#125;//二叉排序树class BSTree&#123; constructor() &#123; this.root = null &#125; //向二叉树插入节点 insert (data) &#123; let newNode = new Node(data, null, null) //更新根节点的值 if (this.root === null) &#123; this.root = newNode &#125; else &#123; //更新当前节点的值 let currentNode = this.root //父节点就是空 let parentNode = null while (true) &#123; //更新父节点 parentNode = currentNode //判断插入节点值在左子树还是右子树 if (newNode.data &lt; currentNode.data) &#123; //更新当前节点 currentNode = currentNode.left if (!currentNode) &#123; parentNode.left = newNode break &#125; &#125; else if (newNode.data &gt; currentNode.data) &#123; currentNode = currentNode.right if (!currentNode) &#123; parentNode.right = newNode break &#125; &#125; else if (newNode.data === currentNode.data) &#123; //如果相同数据 count++ 不做处理 currentNode.count++ break &#125; &#125; &#125; &#125; //获取最小值 getMinNode (node = this.root) &#123; let currentNode = node while (currentNode.left) &#123; currentNode = currentNode.left &#125; return currentNode &#125; //获取最大值 getMaxNode (node = this.root) &#123; let currentNode = node while (currentNode.right) &#123; currentNode = currentNode.right &#125; return currentNode &#125; //寻找给定数据的节点 find (data) &#123; let currentNode = this.root while (currentNode) &#123; if (currentNode.data == data) &#123; return currentNode &#125; else if (currentNode.data &lt; data) &#123; currentNode = currentNode.right &#125; else &#123; currentNode = currentNode.left &#125; &#125; return null &#125; //删除节点，实例中不应调用 _removeNode (node, data) &#123; if (node === null) &#123; return null &#125; //找到要删除的节点的了 if (data === node.data) &#123; //分三种情况 //1. 要删除的节点为叶子结点 if (node.left === null &amp;&amp; node.right === null) &#123; return null &#125; //2. 没有左子节点的节点 if (node.left === null) return node.right // 没有右子节点的节点 if (node.right === null) return node.left //3.有两个子节点的节点 //找到待删除节点的右子树的最小值赋值给临时节点tmpNode //将tmpNode赋值给node 就说明用右子树的最小值来代替待删除节点 let tmpNode = this.getMinNode(node.right) //tmpNode赋值给待删除节点 node.data = tmpNode.data //删除临时节点 node.right = this._removeNode(node.right, tmpNode.data) return node &#125; else if (data &lt; node.data) &#123; //待删除节点在左子树上 node.left = this._removeNode(node.left, data) return node &#125; else &#123; //待删除节点在右子树上 node.right = this._removeNode(node.right, data) return node &#125; &#125; //删除节点 remove (data) &#123; this.root = this._removeNode(this.root, data); &#125;&#125;let myTree = new BSTree();myTree.insert(20);myTree.insert(13);myTree.insert(7);myTree.insert(9);myTree.insert(15);myTree.insert(14);myTree.insert(42);myTree.insert(22);myTree.insert(21);myTree.insert(24);myTree.insert(57);console.log(myTree);","categories":[{"name":"JS","slug":"JS","permalink":"http://awesomeboy.cn/categories/JS/"},{"name":"数据结构","slug":"数据结构","permalink":"http://awesomeboy.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://awesomeboy.cn/tags/JS/"},{"name":"数据结构","slug":"数据结构","permalink":"http://awesomeboy.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"author":"awesomeboy"},{"title":"vue3@/App.vue相关报红线","slug":"vue3-App-vue相关报红线","date":"2023-07-17T04:19:58.000Z","updated":"2023-08-10T13:55:01.609Z","comments":true,"path":"2023/07/17/vue3-App-vue相关报红线/","link":"","permalink":"http://awesomeboy.cn/2023/07/17/vue3-App-vue%E7%9B%B8%E5%85%B3%E6%8A%A5%E7%BA%A2%E7%BA%BF/","excerpt":"","text":"发现问题昨天写的时候还好好的，今早起来打开项目，就报这些错了，想想好像昨天添加了一个ts的插件，今天就报错了。 查明原因 上网查问题，有说eslint的，有说vscode缓存文件没清，有说删node_modules的，也有说vite.config.ts的path配置问题 我也一个个都尝试了，最终也还是没有什么变化 在一次打开vscode中，我发现刚启动时候，还没有报错，同时这个ts插件部分正在显示加载状态，加载完成后就报错了，让我联想到了昨天添加的ts插件。 解决问题禁用这个插件，报红线问题就解决了 猜测或许是ts监测与eslint冲突相关问题吧","categories":[{"name":"Vue项目开发","slug":"Vue项目开发","permalink":"http://awesomeboy.cn/categories/Vue%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"http://awesomeboy.cn/tags/Vue3/"}],"author":"awesomeboy"},{"title":"vue3-eslint-prettier-czgit","slug":"vue3-eslint-prettier-czgit","date":"2023-07-16T14:07:20.000Z","updated":"2023-08-10T13:54:22.306Z","comments":true,"path":"2023/07/16/vue3-eslint-prettier-czgit/","link":"","permalink":"http://awesomeboy.cn/2023/07/16/vue3-eslint-prettier-czgit/","excerpt":"","text":"vue3 + eslint + prettier + cz-git一：vue31.1 vue3创建 输入命令后根据提示选择，项目是ts所以必选typescript 1pnpm create vite 1.2 安装依赖1pnpm i 1.3 运行1pnpm run dev 二：配置eslint2.1 执行安装命令1pnpm add eslint -D 2.2 初始化eslint1pnpm eslint --init 依次选择 2.3 依赖安装完成后，会生成.eslintrc.cjs配置文件1234567891011121314151617181920212223242526272829303132333435module.exports = &#123; env: &#123; browser: true, es2021: true, node: true &#125;, extends: [ &#x27;eslint:recommended&#x27;, &#x27;plugin:vue/vue3-essential&#x27;, &#x27;plugin:@typescript-eslint/recommended&#x27;, &#x27;plugin:prettier/recommended&#x27; // 解决ESlint和Prettier冲突 ], overrides: [], // 配置支持 vue 和 ts parser: &#x27;vue-eslint-parser&#x27;, parserOptions: &#123; ecmaVersion: &#x27;latest&#x27;, sourceType: &#x27;module&#x27;, parser: &#x27;@typescript-eslint/parser&#x27; &#125;, plugins: [&#x27;vue&#x27;, &#x27;@typescript-eslint&#x27;], rules: &#123; &#x27;@typescript-eslint/no-explicit-any&#x27;: &#x27;off&#x27;, // 禁止使用该any类型。 &#x27;@typescript-eslint/no-unused-vars&#x27;: &#x27;off&#x27;, //禁止未使用的变量 &#x27;vue/valid-template-root&#x27;: &#x27;off&#x27;, &#x27;vue/no-v-html&#x27;: &#x27;off&#x27;, &#x27;prefer-const&#x27;: &#x27;off&#x27;, &#x27;@typescript-eslint/ban-types&#x27;: &#x27;off&#x27;, &#x27;@typescript-eslint/no-empty-function&#x27;: &#x27;off&#x27;, &#x27;@typescript-eslint/ban-ts-comment&#x27;: &#x27;off&#x27;, &#x27;vue/multi-word-component-names&#x27;: &#x27;off&#x27;, endOfLine: &#x27;off&#x27;, // 添加忽略换行格式的检查。 &#x27;vue/require-default-prop&#x27;: &#x27;off&#x27; // props 需要设置默认值 &#125;&#125; 2.4 在package.json文件中的script中添加lint命令12345678&#123; &quot;scripts&quot;: &#123; // eslint . 为指定lint当前项目中的文件 // --ext 为指定lint哪些后缀的文件 // --fix 开启自动修复 &quot;lint&quot;: &quot;eslint . --ext .vue,.js,.ts,.jsx,.tsx --fix&quot; &#125;&#125; 2.5 执行lint命令1pnpm lint 遇到这样的错误，很明显少安装插件了 1pnpm install eslint-plugin-prettier@latest --save-dev 1pnpm add prettier -D 2.6 安装插件eslint 在项目中新建.vscode/settings.json文件，然后在其中加入以下配置。 1234567&#123; // 开启自动修复 &quot;editor.codeActionsOnSave&quot;: &#123; &quot;source.fixAll&quot;: false, &quot;source.fixAll.eslint&quot;: true &#125;&#125; 三：配置prettier3.1 执行安装命令1pnpm add prettier -D 3.2 在根目录下新建.prettierrc.cjs 更多配置可查看官方文档 1234567891011121314module.exports = &#123; singleQuote: true, // 使用单引号, 默认false(在jsx中配置无效, 默认都是双引号) semi: false, // 使用分号, 默认true printWidth: 120, // 每行超过多少字符自动换行 arrowParens: &#x27;avoid&#x27;, // avoid 能省略括号的时候就省略 例如x =&gt; x bracketSpacing: true, // 对象中的空格 默认true trailingComma: &#x27;none&#x27;, // all 包括函数对象等所有可选 tabWidth: 2, // tab缩进大小,默认为2 useTabs: false, // 使用tab缩进，默认false htmlWhitespaceSensitivity: &#x27;ignore&#x27;, // 对象大括号直接是否有空格，默认为true，效果：&#123; foo: bar &#125; bracketSpacing: true&#125; 3.3 在package.json中的script中添加以下命令12345&#123; &quot;scripts&quot;: &#123; &quot;format&quot;: &quot;prettier --write \\&quot;./**/*.&#123;html,vue,ts,js,json,md&#125;\\&quot;&quot;, &#125;&#125; 3.4 安装Prettier - Code formatter插件 在.vscode/settings.json中添加一下规则 123456&#123; // 保存的时候自动格式化 &quot;editor.formatOnSave&quot;: true, // 默认格式化工具选择prettier &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;&#125; 四：使用cz-git4.1 全局安装commitizen,如此一来可以快速使用 cz 或 git cz 命令进行启动。1npm install -g commitizen 4.2 安装依赖1pnpm install -D cz-git 4.3 修改 package.json 添加 config 指定使用的适配器12345678910&#123; &quot;scripts&quot;: &#123; &#125;, &quot;config&quot;: &#123; &quot;commitizen&quot;: &#123; &quot;path&quot;: &quot;node_modules/cz-git&quot; &#125; &#125;&#125; 4.4 添加自定义配置 在根目录自行添加.commitlintrc.cjs文件进行配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// .commitlintrc.jsmodule.exports = &#123; rules: &#123; // @see: https://commitlint.js.org/#/reference-rules &#125;, prompt: &#123; messages: &#123; type: &#x27;选择你要提交的类型 :&#x27;, scope: &#x27;选择一个提交范围（可选）:&#x27;, customScope: &#x27;请输入自定义的提交范围 :&#x27;, subject: &#x27;填写简短精炼的变更描述 :\\n&#x27;, body: &#x27;填写更加详细的变更描述（可选）。使用 &quot;|&quot; 换行 :\\n&#x27;, breaking: &#x27;列举非兼容性重大的变更（可选）。使用 &quot;|&quot; 换行 :\\n&#x27;, footer: &#x27;列举关联issue (可选) 例如: #31, #I3244 :\\n&#x27;, confirmCommit: &#x27;是否提交或修改commit ?&#x27; &#125;, types: [ &#123; value: &#x27;feat&#x27;, name: &#x27;feat: 新增功能 | A new feature&#x27;, emoji: &#x27;✨&#x27; &#125;, &#123; value: &#x27;fix&#x27;, name: &#x27;fix: 修复缺陷 | A bug fix&#x27;, emoji: &#x27;🐛&#x27; &#125;, &#123; value: &#x27;docs&#x27;, name: &#x27;docs: 文档更新 | Documentation only changes&#x27;, emoji: &#x27;📄&#x27; &#125;, &#123; value: &#x27;style&#x27;, name: &#x27;style: 代码格式 | Changes that do not affect the meaning of the code&#x27;, emoji: &#x27;💄&#x27; &#125;, &#123; value: &#x27;refactor&#x27;, name: &#x27;refactor: 代码重构 | A code change that neither fixes a bug nor adds a feature&#x27;, emoji: &#x27;♻️&#x27; &#125;, &#123; value: &#x27;perf&#x27;, name: &#x27;perf: 性能提升 | A code change that improves performance&#x27;, emoji: &#x27;⚡️&#x27; &#125;, &#123; value: &#x27;test&#x27;, name: &#x27;test: 测试相关 | Adding missing tests or correcting existing tests&#x27;, emoji: &#x27;✅&#x27; &#125;, &#123; value: &#x27;build&#x27;, name: &#x27;build: 构建相关 | Changes that affect the build system or external dependencies&#x27;, emoji: &#x27;📦️&#x27; &#125;, &#123; value: &#x27;ci&#x27;, name: &#x27;ci: 持续集成 | Changes to our CI configuration files and scripts&#x27;, emoji: &#x27;🎡&#x27; &#125;, &#123; value: &#x27;revert&#x27;, name: &#x27;revert: 回退代码 | Revert to a commit&#x27;, emoji: &#x27;⏪️&#x27; &#125;, &#123; value: &#x27;chore&#x27;, name: &#x27;chore: 其他修改 | Other changes that do not modify src or test files&#x27;, emoji: &#x27;🔨&#x27; &#125; ], useEmoji: true, // scope 类型（定义之后，可通过上下键选择） scopes: [ [&#x27;components&#x27;, &#x27;组件相关&#x27;], [&#x27;hooks&#x27;, &#x27;hook 相关&#x27;], [&#x27;utils&#x27;, &#x27;utils 相关&#x27;], [&#x27;element-ui&#x27;, &#x27;对 element-ui 的调整&#x27;], [&#x27;styles&#x27;, &#x27;样式相关&#x27;], [&#x27;deps&#x27;, &#x27;项目依赖&#x27;], [&#x27;auth&#x27;, &#x27;对 auth 修改&#x27;], [&#x27;other&#x27;, &#x27;其他修改&#x27;] ].map(([value, description]) =&gt; &#123; return &#123; value, name: `$&#123;value.padEnd(30)&#125; ($&#123;description&#125;)` &#125; &#125;), // 是否允许自定义填写 scope，在 scope 选择的时候，会有 empty 和 custom 可以选择。 allowCustomScopes: true, // 跳过要询问的步骤 skipQuestions: [&#x27;body&#x27;, &#x27;breaking&#x27;, &#x27;footer&#x27;], subjectLimit: 100, // subject 限制长度 // 设置只有 type 选择了 feat 或 fix，才询问 breaking message allowBreakingChanges: [&#x27;feat&#x27;, &#x27;fix&#x27;], issuePrefixs: [ // 如果使用 gitee 作为开发管理 &#123; value: &#x27;link&#x27;, name: &#x27;link: 链接 ISSUES 进行中&#x27; &#125;, &#123; value: &#x27;comment&#x27;, name: &#x27;comment: 评论 ISSUES&#x27; &#125;, &#123; value: &#x27;closed&#x27;, name: &#x27;closed: 标记 ISSUES 已完成&#x27; &#125; ] &#125;&#125;","categories":[{"name":"Vue项目开发","slug":"Vue项目开发","permalink":"http://awesomeboy.cn/categories/Vue%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"http://awesomeboy.cn/tags/Vue3/"},{"name":"Eslint","slug":"Eslint","permalink":"http://awesomeboy.cn/tags/Eslint/"},{"name":"cz-git","slug":"cz-git","permalink":"http://awesomeboy.cn/tags/cz-git/"},{"name":"prettier","slug":"prettier","permalink":"http://awesomeboy.cn/tags/prettier/"}],"author":"awesomeboy"},{"title":"计网-物理层","slug":"计网-物理层","date":"2023-07-16T02:49:26.000Z","updated":"2023-07-16T02:52:40.878Z","comments":true,"path":"2023/07/16/计网-物理层/","link":"","permalink":"http://awesomeboy.cn/2023/07/16/%E8%AE%A1%E7%BD%91-%E7%89%A9%E7%90%86%E5%B1%82/","excerpt":"","text":"物理层一：物理层的基本概念 物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流 物理层为数据链路层屏蔽了各种传输媒体的差异，使数据链路层只需要考虑如何完成本层的协议和服务，而不必考虑网络具体的传输媒体是什么 1.1 传输媒体 导引型传输媒体 双绞线 同轴电缆 光纤 非导引型传输媒体 微波通信（2~40GHz） 1.2 物理层协议的主要任务 机械特性：指明接口所用接线器的形状和尺寸，引脚数目和排列，固定和锁定装置 电气特性：指明在接口电缆的各条线上出现的电压的范围 功能特性：指明某条线上出现的某一电平的电压表示何种意义 过程特性：指明对于不同功能的各种可能事件的出现顺序 二：传输方式 串行传输 并行传输 同步传输 外同步：在收发双方之间添加一条单独的时钟信号 内同步：发送端将时钟同步信号编码到发送数据中一起传输 异步传输 字节之间异步（字节之间的时间间隔不固定） 字节中的每个比特仍然要同步（各比特的持续时间是相同的） 单向通信（收音机） 双向交替通信（对讲机） 双向同时通信（手机） 三：编码与调制 码元：在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形 3.1 常用编码 不归零编码（存在同步问题） 归零编码（自同步，编码效率低） 曼彻斯特编码（码元中间时刻的跳变既表示时钟，又表示数据） 3.2 基本调制方法 3.3 混合调制 四：信道的极限容量 在信道带宽一定的情况下，根据奈氏准则和香农公式，要想提高信息的传输速率就必须采用多元制（更好的调制方法）和努力提高信道中的信噪比 自从香农公式发表后，各种新的信号处理和调制方法就不断出现，其目的都是为了尽可能地接近香农公式给出的传输速率极限 五：信道复用技术5.1 基本原理 复用就是在一条传输媒体上同时传输多路用户的信号 当一条传输媒体的传输容量大于多条信道传输的总容量时，就可以通过复用技术，在这条传输媒体上建立多条通信信道，以便充分利用传输媒体的带宽 尽管实现信道复用会增加通信成本，但如果复用的信道数量较大，还是比较划算的 5.2 常见的信道复用技术5.2.1 频分复用FDM 频分复用的所有用户同时占用不同的频带资源并行通信 5.2.2 时分复用TDM 时分复用的所有用户在不同的时间占用同样的频带 5.2.3 波分复用WDM 根据频分复用的设计思想，可在一根光纤上同时传输多个频率相近的光载波信号，实现基于光纤的频分复用技术 5.2.4 码分复用CDM 如果有两个或多个站同时发送数据，则信道中的信号就是这些站各自所发送一系列码片序列或码片序列反码的叠加。为了从信道中分离出每个站的信号，给每个站指派码片序列时，必须遵循以下原则 分配给每个站的码片序列必须各不相同，实际采用伪随机码序列 分配给每个站的码片序列必须相互正交，即各码片序列相应的码片向量之间的规格化内积为0","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://awesomeboy.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络物理层","slug":"计算机网络物理层","permalink":"http://awesomeboy.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%89%A9%E7%90%86%E5%B1%82/"}],"author":"awesomeboy"},{"title":"计算机网络概述","slug":"计网概述","date":"2023-07-16T02:46:33.000Z","updated":"2023-07-16T02:52:57.619Z","comments":true,"path":"2023/07/16/计网概述/","link":"","permalink":"http://awesomeboy.cn/2023/07/16/%E8%AE%A1%E7%BD%91%E6%A6%82%E8%BF%B0/","excerpt":"","text":"什么是互联网？一： 互联网概述1.1 网络，互联网与因特网的区别和关系 若干节点和链路互连形成网络 若干网络通过路由器互连形成互联网 因特网是当今世界上最大的互联网 1.2 因特网发展的三个阶段 二： 电路交换，分组交换，报文交换2.1 电路交换 计算机之间的数据传送是突发式的，当使用电路交换来传送计算机数据时，其线路的传输效率一般都会很低，线路上真正用来传送数据的时间往往不到10%甚至1% 2.2 分组交换 优点： 没有建立连接和释放连接的过程 分组传输过程中逐段占用通信链路，有较高的通信线路利用率 交换节点可以为每一个分组独立选择转发路由，使网络有更好的生存性 缺点： 分组首部带来了额外的传输开销 交换节点存储转发分组会造成一定的时间延迟 无法确保通信时端到端通信资源全部可用，在通信量较大时候可能造成网络拥塞 2.3 报文交换 报文交换式分组交换的前身 在报文交换中，报文被整个地发送，而不是拆分成若干个分组进行发送 交换节点将报文整体接收完成后才能查找转发表，将整个报文转发到下一个节点 因此，报文交换比分组交换带来的转发时间延迟要长很多，需要交换节点具有的缓存空间也大很多 2.4 三种方式对比 若要连续传送大量数据，并且数据传送时间远大于建立连接的时间，则使用电路交换可能有较高的传输效率。然而计算机的数据传送往往是突发式的，采用电路交换时通信线路的利用率会很低 报文交换和分组交换都不需要建立连接（即预先分配通信资源），在传送计算机的突发数据时可以提高通信线路的利用率 将报文构造成若干个更小的分组进行分组交换，比将整个报文进行报文交换的时间延迟要小，并且还可以避免太长的报文长时间占用链路，有利于差错控制，同时具有更好的灵活性 三： 计算机网络的定义和分类3.1 计算机网络的定义 计算机网络的精确定义并未统一 计算机网络的最简单定义：一些互连的，自治的计算机的集合 计算机网络主要是由一些通用的，可编程的硬件互连而成的，而这些硬件并非专门用来实现某一特定目的（例如：传送数据或视频信号）。这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛和日益增长的应用 3.2 计算机网络的分类 交换方式：电路交换，报文交换，分组交换 使用者：公用网，专用网 传输介质：有线网络，无线网络 覆盖范围：广域网WAN，城域网MAN，局域网LAN，个域网PAN 拓扑结构：总线型，星型，环形，网状型 四： 计算机网络的性能指标4.1 速率 速率是指数据的传送速率（即每秒传送多少个比特），也称为数据率或比特率 速率的基本单位：bit&#x2F;s(b&#x2F;s, bps)；常用单位：Kb&#x2F;s，Gb&#x2F;s，Tb&#x2F;s 速率单位中的K，M，G，T的数值分为别10^3，10^6，10^9，10^12 4.2 带宽 带宽在模拟信号系统中的意义：某个信号所包含的各种不同频率成分所占据的频率范围。单位：Hz（kHz，MHz，GHz） 带宽在计算机网络中的意义：用来表示网络的通信线路所能传送数据的能力，即在单位时间内从网络中的某一点到另一点所能通过的最高数据率。单位与速率单位相同 带宽的上述两种表述之间有着密切的联系：一条通信线路的“频带带宽”越宽，其所传输数据的“最高数据率”也就越高 4.3 吞吐量 吞吐量是指单位时间内通过某个网络或接口的实际数据量。吞吐量常用于对实际网络的测量，以便获知到底有多少数据量通过了网络 吞吐量受到网络带宽的限制 4.4 时延 时延是指数据从网络的一端传送到另一端所耗费的时间，也称为延迟或者迟延。数据可由一个或多个分组，甚至是一个比特构成 4.5 时延带宽积 传播时延和带宽的乘积 若发送端连续发送数据，则在发送的第一个比特即将到达终点时，发送端就已经发送了时延带宽积个比特 链路的时延带宽积又称为以比特为单位的链路长度 4.6 往返时间RTT 在许多情况下，因特网上的信息不仅仅是单方向传输，而是双向交互 4.7 利用率 信道利用率：用来表示某信道有百分之几的时间是被利用过的（有数据通过） 网络利用率：全网络的信道利用率的加权平均 利用率并非越高越好：当某信道的利用率增大时，该信道引起的时延也会迅速增加 也不能使信道利用率太低，这会使宝贵的通信资源白白浪费 当网络的利用率达到50%时，时延就要加倍 当网络的利用率超过50%时，时延急剧增大 当网络的利用率接近100%，时延就会趋于无穷大 因此，一些拥有较大主干网的ISP通常会控制它们的信道利用率不超过50%。如果超过了，就要准备扩容，增大线路的带宽 4.8 丢包率 丢包率即分组丢失率，是指在一定的时间范围内，传输过程中丢失的分组数量与总分组数量的比率 分组丢失的两个主要原因：分组误码，结点交换机缓存队列满（网络拥塞） 五： 计算机网络体系结构5.1 常见的计算机网络体系结构 5.2 计算机网络体系结构分层的必要性 计算机网络是个非常复杂的系统。早在最初的APRANET设计时就提出了分层的设计理念 “分层”可将庞大而复杂的问题，转化为若干较小的局部问题，而这些较小的局部问题就比较易于研究和处理 5.2.1 物理层 5.2.2 数据链路层 5.2.3 网络层 5.2.4 运输层 5.2.5 应用层 5.3 计算机网络体系结构分层思想举例 应用层通过HTTP协议，构建HTTP请求报文 运输层给HTTP请求报文添加一个TCP首部，使之成为TCP报文段。该首部作用主要是为了区分应用进程，以及实现可靠传输。 运输层将TCP报文段交付给网络层处理，网络层给TCP报文段添加一个IP首部，使之成为IP数据报。该首部作用是使IP数据报可以在互联网上传输，也就是被路由器转发。 网络层将IP数据报交付给数据链路层处理，数据链路层给IP数据报添加一个首部和一个尾部，使之成为帧。该首部作用是主要是为了让帧能够在一段链路上或一个网络上进行传输，能够被相应目的主机接收。ETH帧尾部的作用是让目的主机检查，所接收到的帧是否有误码。 数据链路层将帧交付给物理层，物理层将帧看作是比特流，物理层会给比特流前面加上前导码，作用是让目的主机做好接收帧的准备。物理层将添加有前导码的比特流变换为相应的信号发送到传输媒体，信号通过传输媒体到达路由器。 5.4 实体 协议 服务5.4.1 实体 实体：任何可发送或接受信息的硬件或软件进程 对等实体：收发双方相同层次中的实体 5.4.2 协议 协议：控制两个对等实体进行逻辑通信的规则的集合 协议三要素：语法 语义 同步 语法：定义所交换信息的格式 语义：定义收发双发所要完成的操作 同步：定义收发双方的时序关系 5.4.3 服务 在协议的控制下，两个对等实体间的逻辑通信使得本层能够向上一层提供服务 要实现本层协议，还需要使用下面一层所提供的服务 协议是”水平的“，服务是“垂直的” 实体看得见相邻下层所提供的服务，但不知道实现该服务的具体协议。 服务访问点：在同一系统中相邻两层的实体交换信息的逻辑接口，用于区分不同的服务类型 数据链路层的服务访问点为帧的“类型”字段 网络层的服务访问点为IP数据报首部中的“协议字段” 运输层的服务访问点为“端口号” 服务原语：上层使用下层所提供的服务必须通过与下层交换一些命令，这些命令称为服务原语 协议数据单元PDU：对等层次之间传送的数据包称为该层的协议数据单元 服务数据单元SDU：同一系统内，层与层之间交换的数据包称为服务数据单元 多个SDU可为合成成为一个PDU；一个SDU也可以划分为几个PDU","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://awesomeboy.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络概述","slug":"计算机网络概述","permalink":"http://awesomeboy.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"}],"author":"awesomeboy"},{"title":"计算机网络体系结构","slug":"计算机网络体系结构","date":"2023-07-15T03:31:38.000Z","updated":"2023-07-15T03:37:11.777Z","comments":true,"path":"2023/07/15/计算机网络体系结构/","link":"","permalink":"http://awesomeboy.cn/2023/07/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/","excerpt":"","text":"计算机网络体系结构一： 常见的计算机网络体系结构 二： 计算机网络体系结构分层的必要性 计算机网络是个非常复杂的系统。早在最初的APRANET设计时就提出了分层的设计理念 “分层”可将庞大而复杂的问题，转化为若干较小的局部问题，而这些较小的局部问题就比较易于研究和处理 物理层 数据链路层 网络层 运输层 应用层 三： 计算机网络体系结构分层思想举例 应用层通过HTTP协议，构建HTTP请求报文 运输层给HTTP请求报文添加一个TCP首部，使之成为TCP报文段。该首部作用主要是为了区分应用进程，以及实现可靠传输。 运输层将TCP报文段交付给网络层处理，网络层给TCP报文段添加一个IP首部，使之成为IP数据报。该首部作用是使IP数据报可以在互联网上传输，也就是被路由器转发。 网络层将IP数据报交付给数据链路层处理，数据链路层给IP数据报添加一个首部和一个尾部，使之成为帧。该首部作用是主要是为了让帧能够在一段链路上或一个网络上进行传输，能够被相应目的主机接收。ETH帧尾部的作用是让目的主机检查，所接收到的帧是否有误码。 数据链路层将帧交付给物理层，物理层将帧看作是比特流，物理层会给比特流前面加上前导码，作用是让目的主机做好接收帧的准备。物理层将添加有前导码的比特流变换为相应的信号发送到传输媒体，信号通过传输媒体到达路由器。 四： 实体 协议 服务实体 实体：任何可发送或接受信息的硬件或软件进程 对等实体：收发双方相同层次中的实体 协议 协议：控制两个对等实体进行逻辑通信的规则的集合 协议三要素：语法 语义 同步 语法：定义所交换信息的格式 语义：定义收发双发所要完成的操作 同步：定义收发双方的时序关系 服务 在协议的控制下，两个对等实体间的逻辑通信使得本层能够向上一层提供服务 要实现本层协议，还需要使用下面一层所提供的服务 协议是”水平的“，服务是“垂直的” 实体看得见相邻下层所提供的服务，但不知道实现该服务的具体协议。 服务访问点：在同一系统中相邻两层的实体交换信息的逻辑接口，用于区分不同的服务类型 数据链路层的服务访问点为帧的“类型”字段 网络层的服务访问点为IP数据报首部中的“协议字段” 运输层的服务访问点为“端口号” 服务原语：上层使用下层所提供的服务必须通过与下层交换一些命令，这些命令称为服务原语 协议数据单元PDU：对等层次之间传送的数据包称为该层的协议数据单元 服务数据单元SDU：同一系统内，层与层之间交换的数据包称为服务数据单元 多个SDU可为合成成为一个PDU；一个SDU也可以划分为几个PDU","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://awesomeboy.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络体系结构","slug":"计算机网络体系结构","permalink":"http://awesomeboy.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"}],"author":"awesomeboy"},{"title":"微型计算机系统","slug":"微型计算机系统","date":"2023-06-07T13:56:10.000Z","updated":"2023-07-15T03:32:17.763Z","comments":true,"path":"2023/06/07/微型计算机系统/","link":"","permalink":"http://awesomeboy.cn/2023/06/07/%E5%BE%AE%E5%9E%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"微型计算机系统 微型计算机是指以微处理为核心，配上存储器，输入&#x2F;输出接口电路等组成的计算机（又称为主机）。微型计算机系统是指以微型计算机为中心，配以相应的外围设备，电源和辅助电路以及指挥计算机工作的系统软件所构成的系统 一：微型计算机系统的组成 二：基于总线的微型计算机硬件系统1. 冯诺依曼体系结构 冯诺依曼体系结构设计基本思想 以二进制形式表示指令和数据 程序和数据事先存放在存储器之中，计算机在工作时能够高速地从存储器中取出指令加以执行 由运算器，控制器，存储器，输入设备和输出设备等五大部件组成计算机硬件系统 2. 总线 微机系统结构的特点之一采用总线结构，通过总线将微处理器(cpu)，存储器(RAM和ROM)，I&#x2F;O接口电路等连接起来，而输入输出设备则通过I&#x2F;O接口实现与微机的信息交换 **总线**：是连接计算机各个部件的一组公共信号线；总线上能同时传送二进制信息的位数称为总线宽度 **优点**：大大减少传输线数目，结构简单，便于扩充 总线分三类 地址总线（AB）：单向总线，用于传送CPU发出的地址信息，以确定存储器中信息的存放地址和I&#x2F;O接口地址 若地址总线16位，则寻址2^16 &#x3D; 64KB 若20根，则寻址2^20 &#x3D; 1024KB &#x3D; 1MB 数据总线（DB）：双向总线，在CPU，存储器和I&#x2F;O接口之间传送数据 控制总线（CB）：双向总线，用于传送控制信号，时钟信号和状态信息等 三：微型计算机一般工作过程 取指令 指令译码 取操作数 执行指令 存放运算结果 微型计算机中CPU不断重复上述过程 取指，译码，执行 1. MOV A,6 指令的工作示意图 读取第一条操作指令的工作示意图 (1)PC程序计数器读取内存储器中的第一个存储单元的地址00H，并存放至AR（地址寄存器） (2)PC程序计数器+1 (3)AR地址寄存器通过AB地址总线把地址送到存储，存储器经过译码部件找到对应的存储单元 (4)控制电路发出读命令 (5)存储器就会把对应存储单元的内容送到外部DB数据总线上 (6)外部DB数据总线将数据送到DR数据寄存器中 (7)DR数据寄存器通过内部DB数据总线将内容送到IR指令寄存器，之后再到ID指令译码器来进行译码，以确定该指令应执行什么操作 四：存储器的访问 a是存储器读操作，b是存储器写操作 cpu从存储单元读操作 CPU通过AB地址总线送出8位地址信息通过地址译码器，选中唯一的对应地址04的存储单元 控制电路进行读信息操作 DB数据总线从存储单元送入CPU中完成读操作 cpu从存储单元写操作 CPU通过AB地址总线送出8位地址信息通过地址译码器，选中唯一的对应地址08的存储单元 DB数据总线，通过CPU送出操作数存储到对应地址的存储单元 控制电路完成写操作","categories":[{"name":"微机原理","slug":"微机原理","permalink":"http://awesomeboy.cn/categories/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"微机原理","slug":"微机原理","permalink":"http://awesomeboy.cn/tags/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/"}],"author":"awesomeboy"},{"title":"8086微处理器","slug":"8086微处理器","date":"2023-06-07T12:22:26.000Z","updated":"2023-09-09T12:27:25.298Z","comments":true,"path":"2023/06/07/8086微处理器/","link":"","permalink":"http://awesomeboy.cn/2023/06/07/8086%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8/","excerpt":"","text":"8086&#x2F;8088微处理器一：8086&#x2F;8088CPU结构 总线接口单元BIU功能 （1）形成20位物理地址 （2）从内存中取指送指令队列 （3）对操作数进行存取 执行单元EU功能 （1）从指令队列取指令，译码和执行 （2）算术逻辑运算 （3）向BIU提供执行结果以及16位偏移地址 8086cpu结构优点 8086分为BIU和EU使取指令和执行指令并行执行，提高cpu效率，降低对存储器存储速度的要求 二：工作寄存器 寄存器作用 相当于存储单元 提高计算机功能 增强程序设计的灵活性 存储数据或地址 编程时用于置数和读数 三：标志寄存器FR 16 位只用其中 9 位，包括 6 个状态标志和 3 个控制标志。 1. 状态标志位（6位） CF（进位标志位）：运算时，最高位有进位或借位时CF&#x3D;1，否则CF&#x3D;0 PF（奇偶标志位）：运算结果低8位中‘1’的个数为偶数，PF&#x3D;1,否则PF&#x3D;0 AF（辅助进位标志位）：运算时，若结果的低字节的低4位向高4位有进位或借位时，则AF&#x3D;1，否则AF&#x3D;0 ZF（零标志位）：运算结果为0，则ZF&#x3D;1，否则ZF&#x3D;0 SF（符号标志位）：运算结果最高位（符号位）为1，则SF&#x3D;1 OF（溢出标志位）：表示符号数运算，运算结果有溢出OF&#x3D;1，否则OF&#x3D;0 2. 控制标志（3位） DF（控制标志）：串指令中控制方向 IF（中断标志）：IF&#x3D;1允许中断，IF&#x3D;0关中断 TF（跟踪标志）：用于程序调试时进行单步方式工作","categories":[{"name":"微机原理","slug":"微机原理","permalink":"http://awesomeboy.cn/categories/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"8086微处理器","slug":"8086微处理器","permalink":"http://awesomeboy.cn/tags/8086%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8/"}],"author":"awesomeboy"},{"title":"v-for循环图片无法显示？","slug":"v-for循环图片无法显示？","date":"2023-06-06T12:28:01.000Z","updated":"2023-06-06T13:14:49.646Z","comments":true,"path":"2023/06/06/v-for循环图片无法显示？/","link":"","permalink":"http://awesomeboy.cn/2023/06/06/v-for%E5%BE%AA%E7%8E%AF%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%EF%BC%9F/","excerpt":"","text":"起因：在想利用element ui来实现一个走马灯的轮播效果，利用v-for来遍历渲染图片和文字信息，但当使用自以为的src路径写法时候缺无法正常渲染 一：发现问题： 12345678910111213&lt;el-carousel :interval=&quot;4000&quot; type=&quot;card&quot; height=&quot;500px&quot;&gt; &lt;el-carousel-item v-for=&quot;item in batteryNameArr&quot; :key=&quot;item.index&quot;&gt; &lt;!-- &lt;h3 class=&quot;medium&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/h3&gt; --&gt; &lt;img :src=&quot;item.src&quot; alt=&quot;&quot;&gt; &lt;div class=&quot;btn&quot;&gt; &lt;el-button type=&quot;primary&quot; plain @click=&quot;goto(item.index)&quot;&gt;查看电池信息&lt;/el-button&gt; &lt;el-tag type=&quot;success&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/el-tag&gt; &lt;el-button @click=&quot;other&quot; type=&quot;primary&quot; plain &gt;寿命预测&lt;/el-button&gt; &lt;/div&gt; &lt;/el-carousel-item&gt;&lt;/el-carousel&gt; 1234567891011121314151617181920212223242526272829303132batteryNameArr: [ &#123; index: 0, name: &#x27;CH35&#x27;, src: &#x27;../assets/img/1.png&#x27;, &#125;, &#123; index: 1, name: &#x27;CH23&#x27;, src: &#x27;../assets/img/2.png&#x27;, &#125;, &#123; index: 2, name: &#x27;CH42&#x27;, src: &#x27;../assets/img/3.png&#x27;, &#125;, &#123; index: 3, name: &#x27;CH30&#x27;, src: &#x27;../assets/img/4.png&#x27;, &#125;, &#123; index: 4, name: &#x27;CH7&#x27;, src: &#x27;../assets/img/5.png&#x27;, &#125;, &#123; index: 5, name: &#x27;CH15&#x27;, src: &#x27;../assets/img/6.png&#x27;, &#125;,], 二：解决问题1. 将本地图片上传图床，使用在线链接 一开始始终寻找不到解决问题的办法，无奈下直接将其上传至图床，不再使用本地图片资源，但觉得很笨，肯定有更好地办法 1234567891011121314151617181920212223242526272829303132333435363738batteryNameArr: [ &#123; index: 0, name: &#x27;CH35&#x27;, // src: &#x27;../assets/img/1.png&#x27;, src: &#x27;https://awesomeboy.oss-cn-chengdu.aliyuncs.com/img/202306061953201.png&#x27;, &#125;, &#123; index: 1, name: &#x27;CH23&#x27;, // src: &#x27;../assets/img/2.png&#x27;, src: &#x27;https://awesomeboy.oss-cn-chengdu.aliyuncs.com/img/202306061953201.png&#x27;, &#125;, &#123; index: 2, name: &#x27;CH42&#x27;, // src: &#x27;../assets/img/3.png&#x27;, src: &#x27;https://awesomeboy.oss-cn-chengdu.aliyuncs.com/img/202306061953201.png&#x27;, &#125;, &#123; index: 3, name: &#x27;CH30&#x27;, // src: &#x27;../assets/img/4.png&#x27;, src: &#x27;https://awesomeboy.oss-cn-chengdu.aliyuncs.com/img/202306061953201.png&#x27;, &#125;, &#123; index: 4, name: &#x27;CH7&#x27;, // src: &#x27;../assets/img/5.png&#x27;, src: &#x27;https://awesomeboy.oss-cn-chengdu.aliyuncs.com/img/202306061953201.png&#x27;, &#125;, &#123; index: 5, name: &#x27;CH15&#x27;, // src: &#x27;../assets/img/6.png&#x27;, src: &#x27;https://awesomeboy.oss-cn-chengdu.aliyuncs.com/img/202306061953201.png&#x27;, &#125;,], 2.使用require调用路径 src: require(‘..&#x2F;assets&#x2F;img&#x2F;2.png’) 1234567891011121314151617181920212223242526272829303132batteryNameArr: [ &#123; index: 0, name: &#x27;CH35&#x27;, src: require(&#x27;../assets/img/1.png&#x27;), &#125;, &#123; index: 1, name: &#x27;CH23&#x27;, src: require(&#x27;../assets/img/2.png&#x27;), &#125;, &#123; index: 2, name: &#x27;CH42&#x27;, src: require(&#x27;../assets/img/3.png&#x27;), &#125;, &#123; index: 3, name: &#x27;CH30&#x27;, src: require(&#x27;../assets/img/4.png&#x27;), &#125;, &#123; index: 4, name: &#x27;CH7&#x27;, src: require(&#x27;../assets/img/5.png&#x27;), &#125;, &#123; index: 5, name: &#x27;CH15&#x27;, src: require(&#x27;../assets/img/6.png&#x27;), &#125;,], 三：探究原因: 为什么vue中引入图片需要使用require简单一句话因为动态添加src被当做静态资源处理了，没有进行编译，所以要加上require 1. 什么是静态资源，什么是动态资源？静态资源就是直接存放在项目中的资源，这些资源不需要我们发送专门的请求进行获取。比如assets目录下面的图片，视频，音频，字体文件，css样式表等。 动态资源就是需要发送请求获取到的资源。 2. 为什么动态添加的src会被当做静态资源处理？ 先看这个代码图片被编译成的样子是什么样的 123&lt;el-carousel-item v-for=&quot;item in batteryNameArr&quot; :key=&quot;item.index&quot;&gt; &lt;img :src=&quot;item.src&quot; alt=&quot;&quot;&gt;&lt;/el-carousel-item&gt; 1234567batteryNameArr: [ &#123; index: 0, name: &#x27;CH35&#x27;, src: &#x27;../assets/img/1.png&#x27;, &#125;, ], 该图片无法正常显示 利用require调用资源，编译后会变成这个样子，该图片是正常显示的。 12345678batteryNameArr: [ &#123; index: 1, name: &#x27;CH23&#x27;, src: require(&#x27;../assets/img/2.png&#x27;), &#125;, ], 在vue中动态添加的src最终会编译成一个静态的字符串地址。程序运行的时候，会按照这个地址去项目目录中引入资源。而 去项目目录中引入资源的这种方式，就是将该资源当成了静态资源 正因为动态的添加的src编译过后的地址，与图片资源编译过后的资源地址不一致， 导致无法正确的引入资源 使用静态的地址去引入一张图片，图片的路径和图片的名称已经发生了改变，并且编译后过后的静态地址是可以成功的引入资源的。这是因为，在默认情况下，src目录下面的所有文件都会被打包，src下面的图片也会被打包在新的文件夹下并生成新的文件名。编译过后的静态地址引入的是打包过后的图片地址，从而可以正确的引用资源 3. 为什么调用require就可以正常使用图片？因为动态添加的src，编译过后的文件地址和被编译过后的资源文件地址不一致，从而无法正确引入资源。而使用require，返回的就是资源文件被编译后的文件地址，从而可以正确的引入资源","categories":[{"name":"Vue","slug":"Vue","permalink":"http://awesomeboy.cn/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://awesomeboy.cn/tags/Vue/"}],"author":"awesomeboy"},{"title":"LeetCode-26-删除有序数组中的重复项","slug":"LeetCode-26-删除有序数组中的重复项","date":"2023-05-29T13:10:13.000Z","updated":"2023-05-29T13:22:06.466Z","comments":true,"path":"2023/05/29/LeetCode-26-删除有序数组中的重复项/","link":"","permalink":"http://awesomeboy.cn/2023/05/29/LeetCode-26-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/","excerpt":"","text":"一：题目描述：给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。 考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过： 更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。 返回 k 。 判题标准: 系统会用下面的代码来测试你的题解: 123456789int[] nums = [...]; // 输入数组int[] expectedNums = [...]; // 长度正确的期望答案int k = removeDuplicates(nums); // 调用assert k == expectedNums.length;for (int i = 0; i &lt; k; i++) &#123; assert nums[i] == expectedNums[i];&#125; 如果所有断言都通过，那么您的题解将被 通过。 二：示例与提示示例 1:1234输入：nums = [1,1,2]输出：2, nums = [1,2,_]解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。 示例 2:1234输入：nums = [0,0,1,1,1,2,2,3,3,4]输出：5, nums = [0,1,2,3,4]解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。 提示： 1 &lt;= nums.length &lt;= 3 * 104 -104 &lt;= nums[i] &lt;= 104 nums 已按 升序 排列 三：思路双指针当我们遇到要求原地删除数组中的元素时，并要求不使用额外空间时候就意味着我们可能需要使用到双指针来求解该问题 这道题要求删除相同元素，并返回不同元素的个数 利用快慢指针，快指针指的元素和慢指针指的元素相同（快指针一直遍历的是相同元素）我们不做处理，让快指针向右移动 当快指针指的元素与慢指针元素不同时候（不同的元素正是我们想要的），但是慢指针和快指针之间隔的有很多和慢指针一样的元素，我们直接覆盖掉，慢指针右移一个并将快指针指的元素赋值给它 最终快指针会超出数组范围，此时数组中前一部分已经排序好我们想要的不同的升序元素，慢指针的位置便是不同元素的索引 四：代码 时间复杂度O(n） 空间复杂度O(1) 12345678910111213141516/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var removeDuplicates = function(nums) &#123; //双指针法 if(!nums.length) return 0 let left = 0 for(var right = 1; right &lt; nums.length; right++)&#123; if(nums[right] !== nums[left])&#123; left++ nums[left] = nums[right] &#125; &#125; return left+1&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://awesomeboy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"http://awesomeboy.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"数组","slug":"数组","permalink":"http://awesomeboy.cn/tags/%E6%95%B0%E7%BB%84/"}],"author":"awesomeboy"},{"title":"LeetCode-541-反转字符串2","slug":"LeetCode-541-反转字符串2","date":"2023-05-22T12:58:40.000Z","updated":"2023-05-22T13:02:31.060Z","comments":true,"path":"2023/05/22/LeetCode-541-反转字符串2/","link":"","permalink":"http://awesomeboy.cn/2023/05/22/LeetCode-541-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B22/","excerpt":"","text":"一：题目描述：给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。 如果剩余字符少于 k 个，则将剩余字符全部反转。如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。 二：示例与提示示例 1:12输入：s = &quot;abcdefg&quot;, k = 2输出：&quot;bacdfeg&quot; 示例 2:12输入：s = &quot;abcd&quot;, k = 2输出：&quot;bacd&quot; 提示： 1 &lt;= s.length &lt;= 104 s 仅由小写英文组成 1 &lt;= k &lt;= 104 三：思路按题模拟 按照题目要求去模拟就可以了，重点是需要理解题目的意思，理清界限 实现reverse函数即可 四：代码123456789101112131415161718192021var reverseStr = function(s, k) &#123; let n = s.length //将字符串转换成数组 const arr = Array.from(s) //每次跳跃i+=2*k //重点理清Math.min(i+k, n)的意思 for(let i=0; i&lt;n; i += 2 * k)&#123; reverse(arr, i, Math.min(i+k, n)-1) &#125; return arr.join(&#x27;&#x27;)&#125;;var reverse = function(arr, left, right)&#123; while(left &lt; right)&#123; let temp = arr[left] arr[left] = arr[right] arr[right] = temp left++ right-- &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://awesomeboy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"反转字符串","slug":"反转字符串","permalink":"http://awesomeboy.cn/tags/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"串","slug":"串","permalink":"http://awesomeboy.cn/tags/%E4%B8%B2/"}],"author":"awesomeboy"},{"title":"LeetCode-151-反转字符串中的单词","slug":"LeetCode-151-反转字符串中的单词","date":"2023-05-22T12:51:22.000Z","updated":"2023-05-22T12:59:22.225Z","comments":true,"path":"2023/05/22/LeetCode-151-反转字符串中的单词/","link":"","permalink":"http://awesomeboy.cn/2023/05/22/LeetCode-151-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D/","excerpt":"","text":"一：题目描述：给你一个字符串 s ，请你反转字符串中 单词 的顺序。 单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。 返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。 注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。 二：示例与提示示例 1:12输入：s = &quot;the sky is blue&quot;输出：&quot;blue is sky the&quot; 示例 2:123输入：s = &quot; hello world &quot;输出：&quot;world hello&quot;解释：反转后的字符串中不能存在前导空格和尾随空格。 示例 3:123输入：s = &quot;a good example&quot;输出：&quot;example good a&quot;解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。 提示： 1 &lt;= s.length &lt;= 104 s 包含英文大小写字母、数字和空格 &#39; &#39; s 中 至少存在一个 单词 三：思路正则 先调用trim()方法去除字符串首位空格，再利用正则将单词中的多个空格替换成一个空格，然后再利用split分割成数组，调用reverse()方法反转数组，最终join(‘ ‘)将数组转换成字符串 双端队列 left指针初始在0号位置，right指针初始在s.length - 1位置，遍历字符串，将每个由空格分隔的字符串加入队列，最后在转回字符串就是翻转过后的了 重点是利用到了双端队列的特性 复杂度：时间复杂度O(n)，空间复杂度O(n) 四：代码1：排序 时间复杂度O(nlogn) 123456789101112131415161718/** * @param &#123;string&#125; s * @param &#123;string&#125; t * @return &#123;boolean&#125; */var isAnagram = function(s, t) &#123; //1.排序之后匹配是否相同 const arr = s.split(&#x27;&#x27;).sort() const arr1 = t.split(&#x27;&#x27;).sort() var flag = 1 for(let i=0; i&lt;Math.max(arr.length,arr1.length); i++)&#123; if(arr[i] !== arr1[i])&#123; flag = 0 &#125; &#125; if(flag) return true else return false&#125;; 2：哈希表 时间复杂度O(n) 12345678910111213141516171819202122232425262728293031/** * @param &#123;string&#125; s * @param &#123;string&#125; t * @return &#123;boolean&#125; */var isAnagram = function(s, t) &#123; //2. hashmap // 将s中的每个字符都进map，初始值都设置为1 // 遍历t，利用hashmap，如果s中有t，值-1 // 如果值不大于0，就不是字母异位词 if(s.length !== t.length) return false const map = new Map() for(let n of s)&#123; if(map.has(n))&#123; map.set(n, map.get(n) + 1) &#125;else&#123; map.set(n, 1) &#125; &#125; for(let n of t)&#123; if(map.has(n) &amp;&amp; map.get(n) &gt; 0)&#123; map.set(n, map.get(n) - 1) &#125;else&#123; return false &#125; &#125; return true&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://awesomeboy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"双端队列","slug":"双端队列","permalink":"http://awesomeboy.cn/tags/%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/"},{"name":"反转字符串","slug":"反转字符串","permalink":"http://awesomeboy.cn/tags/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"串","slug":"串","permalink":"http://awesomeboy.cn/tags/%E4%B8%B2/"}],"author":"awesomeboy"},{"title":"LeetCode-454-四数相加 ||","slug":"LeetCode-454-四数相加","date":"2023-05-15T12:11:36.000Z","updated":"2023-05-15T12:24:24.464Z","comments":true,"path":"2023/05/15/LeetCode-454-四数相加/","link":"","permalink":"http://awesomeboy.cn/2023/05/15/LeetCode-454-%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0/","excerpt":"","text":"一：题目描述：给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足： 0 &lt;&#x3D; i, j, k, l &lt; nnums1[i] + nums2[j] + nums3[k] + nums4[l] &#x3D;&#x3D; 0 二：示例与提示示例 1:123456输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]输出：2解释：两个元组如下：1. (0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 02. (1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0 示例 2:12输入：nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]输出：1 提示: n &#x3D;&#x3D; nums1.length n &#x3D;&#x3D; nums2.length n &#x3D;&#x3D; nums3.length n &#x3D;&#x3D; nums4.length 1 &lt;&#x3D; n &lt;&#x3D; 200 -228 &lt;&#x3D; nums1[i], nums2[i], nums3[i], nums4[i] &lt;&#x3D; 228 三：思路分组+哈希表 将四个数组分为A+B,C+D 对于A+B，二重循环进行遍历，求A+B的和，将A[i]+B[j]的和作为哈希表的键存入，值是A[i]+B[j]的和出现的次数 对于C+D，同样用二重循环进行遍历，当-（C[k]+D[l]）出现在哈希映射中，那么将对应的键值累加 四：代码注意：map.get(leftNums)+1 当我们对哈希map的键值自增的时候，是不可以写成，map.get()++，这样会报错。无论改成++map.get()，map.get() +&#x3D; 1都会报出相同的错误。 我们无法自增map.get()的返回值，我们需要将其转换成命名表达式，然后才能进行更改 网上搜索了解到在C++术语中说++需要一个左值，但函数的返回值是一个右值 哈希表12345678910111213141516171819202122232425262728293031/** * @param &#123;number[]&#125; nums1 * @param &#123;number[]&#125; nums2 * @param &#123;number[]&#125; nums3 * @param &#123;number[]&#125; nums4 * @return &#123;number&#125; */var fourSumCount = function(nums1, nums2, nums3, nums4) &#123; //分组求和 A+B C+D 哈希map const map = new Map() let cnt = 0 for(let i of nums1)&#123; for(let j of nums2)&#123; let leftNums = i+j if(map.has(leftNums))&#123; map.set(leftNums, map.get(leftNums)+1) &#125;else&#123; map.set(leftNums, 1) &#125; &#125; &#125; for(let i of nums3)&#123; for(let j of nums4)&#123; let rightNums = i + j if(map.has(-rightNums))&#123; cnt += map.get(-rightNums) &#125; &#125; &#125; return cnt&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://awesomeboy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"哈希表","slug":"哈希表","permalink":"http://awesomeboy.cn/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}],"author":"awesomeboy"},{"title":"LeetCode-383-赎金信","slug":"LeetCode-383-赎金信","date":"2023-05-09T14:15:45.000Z","updated":"2023-05-09T14:56:49.961Z","comments":true,"path":"2023/05/09/LeetCode-383-赎金信/","link":"","permalink":"http://awesomeboy.cn/2023/05/09/LeetCode-383-%E8%B5%8E%E9%87%91%E4%BF%A1/","excerpt":"","text":"一：题目描述：给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。 如果可以，返回 true ；否则返回 false 。 magazine 中的每个字符只能在 ransomNote 中使用一次。 二：示例与提示示例 1:12输入：ransomNote = &quot;a&quot;, magazine = &quot;b&quot;输出：false 示例 2:12输入：ransomNote = &quot;aa&quot;, magazine = &quot;ab&quot;输出：false 示例 3:12输入：ransomNote = &quot;aa&quot;, magazine = &quot;aab&quot;输出：true 提示: 1 &lt;= ransomNote.length, magazine.length &lt;= 105 ransomNote 和 magazine 由小写英文字母组成 三：思路hashmap 在ransomeNote中建立哈希map，遍历字符串，将每个字符都添加到map中，并设置初值为1，若有重复的字符，值自增，即出现几次值为几次 建立之后，遍历magazine字符串，并在map中查找对应字符，若存在，对应字符的value自减，即出现几次减几次。 最终查看map中字符的value值是否为0，若都为0，则magazine中的字符可以组成ransomNote，若存在不为0的value值，即说明未被抵消完全，无法组成 图解 四：代码哈希表1234567891011121314151617181920212223242526272829303132/** * @param &#123;string&#125; ransomNote * @param &#123;string&#125; magazine * @return &#123;boolean&#125; */var canConstruct = function(ransomNote, magazine) &#123; //hashmap const map = new Map() for(let n of ransomNote)&#123; if(map.has(n))&#123; map.set(n, map.get(n) + 1) &#125;else&#123; map.set(n, 1) &#125; &#125; for(let n of magazine)&#123; if(map.has(n) &amp;&amp; map.get(n) &gt; 0)&#123; map.set(n, map.get(n) - 1) &#125; &#125; for(let n of map)&#123; if(n[1] != 0)&#123; return false &#125; &#125; // console.log(map) return true&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://awesomeboy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"哈希表","slug":"哈希表","permalink":"http://awesomeboy.cn/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}],"author":"awesomeboy"},{"title":"哈希表","slug":"哈希表","date":"2023-05-09T13:32:07.000Z","updated":"2023-08-05T07:58:58.977Z","comments":true,"path":"2023/05/09/哈希表/","link":"","permalink":"http://awesomeboy.cn/2023/05/09/%E5%93%88%E5%B8%8C%E8%A1%A8/","excerpt":"","text":"一：什么是哈希表？ 哈希表是一种常见的数据结构，它通过将键映射到值的方式来存储和组织数据。具体来说，哈希表使用哈希函数将每个键映射到一个索引（在数组中的位置），然后将该键值对存储在该索引处。当需要检索某个键的值时，哈希表会再次使用哈希函数将该键转换为相应的索引，并在该索引处查找其关联的值。由于哈希函数通常能够较快地计算出索引，因此哈希表在插入和查找操作上具有很高的效率。 在 JavaScript 中，哈希表通常是通过对象来实现的。对象的属性名就是键，而属性值则是与之关联的值。然而，在某些情况下，如果需要更多的控制权或者需要处理大量的数据，可以使用第三方库或自己实现哈希表数据结构。 二：哈希化 哈希化是将任意长度的消息（例如一个字符串、文件或数据记录）转换为固定长度的值（通常是较小的整数），该值称为哈希值。哈希函数执行哈希化操作，它将输入键映射到唯一的索引值，这个索引值可以用来在哈希表中查找对应的值。 哈希化具有以下特点： 哈希化是单向的：从哈希值无法推断出原始输入值，而且很难找到两个不同的输入值生成相同的哈希值。 哈希化是确定性的：对于给定的输入，哈希函数总是返回相同的哈希值。这个特性使得哈希表能够高效地进行查找和插入等操作。 哈希化是均匀的：好的哈希函数应该将输入数据均匀地分布在哈希空间中，以避免碰撞（即两个不同的输入值生成相同的哈希值）。 总而言之 哈希化：将大数字转化成数组范围内下标的过程，我们就称之为哈希化 哈希函数：通常我们会将单词转成大数字，大数字在进行哈希化的代码实现放在一个函数中，这个函数我们称为哈希函数 哈希表：最终将数据插入到的这个数组，对整个结构的封装，我们就称之为是一个哈希表 三：哈希函数 好的哈希函数应该具备： 快速的计算：哈希表的优势就在于效率，所以快速获取到对应的hashCode非常重要。我们需要通过快速的计算来获取到元素对应的hashCode。 均匀的分布：哈希表中，无论是链地址法还是开放地址法，当多个元素映射到同一个位置的时候，都会影响效率，所以，优秀的哈希函数应该尽可能将元素映射到不同的位置，让元素在哈希表中均匀的分布。 哈希函数设计 将字符串转换成比较大的数字：hashCode 将大的数字hashCode压缩到数组范围之内 传入两个参数：str 字符串；size 数组大小 1234567891011121314function hashFunc(str, size) &#123; //参数1 字符串 参数2 数组大小 //1.定义hashcode let hashCode = 0; //2.霍纳法则，来计算hashCode的值 // 将str转成Unicode编码 for (let i = 0; i &lt;str.length ; i++) &#123; // 哈希表的长度使用质数 43 47 47 31 等等都可，目前最多使用的还是37 hashCode = 37*hashCode + str.charCodeAt(i) &#125; //3.取余操作 let index = hashCode % size return index &#125; 四：实现哈希表（链地址法）1.逻辑 实现的哈希表（基于storage的数组）每个index对应的是一个是数组（bucket）。bucket中存放什么呢？我们最好将key和value都放进去，我们继续使用一个数组最终我们的哈希表的数据格式是这样：[[[k,v],[k,v],[k,v]],[[k,v],[k,v]],[[k,v]]] 2.扩容和扩容时机 将所有的数据项放在长度为7的数组中的，因为我们使用的是链地址法，loadFactor可以大于1，所以这个哈希表可以无限制的插入新数据。但是随着数据量的增多，每一个index对应的bucket会越来越长，也就造成效率的降低。所以，需要在合适的情况对数组进行扩容。比如扩容两倍。 扩容时机 比较常见的情况是填装因子 &gt; 0.75 的时候扩容 3.属性和方法定义属性： storage： 作为我们的数组，数组中存放相关的元素；count：表示当前数组中已经存放了多少数据，用于计算填装因子的值，以便扩容等操作；limit：用于标记数组的长度； 定义方法： put(key,value)：新增和修改方法。哈希表的插入和修改是同一个函数,因为，当使用者传入一个&lt;key,value&gt;时，如果原来不存在该key，那么就是插入操作；如果已经存在该key，那么就是修改操作 根据传入的key获取对应的hashCode，也就是数组的index； 从哈希表的index位置中取出bucket(一个数组)； 查看上一步取出的数组是否为null ，如果为null，则表示之前在该位置没有放置过任何的内容，那么就新建一个数组[]； 查看是否之前已经放置过key对应的value：如果放置过，那么就是依次替换操作，而不是插入新数据；如果不是修改操作，那么插入新的数据 ：在数组中push新的[key,value]即可。注意： 这里需要将count+1，因为数据增加了一项。 最后判断是否需要扩容： loadFactor &gt; 0.75 的时候扩容 是则加一再判断，直到是质数，则跳出返回这个质数 get(key)：获取数据方法 根据传入的key获取对应的hashCode，也就是数组的index； 根据index拿到对应的bucket； 判断bucket是否为null，如果是null则返回null； 如果不是null，则遍历bucket，判断里面是否包含key对应的数据，有则返回； 如果bucket中没有找到，那么返回null； remove(key)：删除方法 根据传入的key获取对应的hashCode，也就是数组的index； 根据index拿到对应的bucket； 判断bucket是否存在，如果不存在则返回null； 如果存在则遍历bucket，找到里面包含key对应的数据，有则删除，并且数量减一，同时需要判断是否需要缩容，返回被删除的数据； 如果不存在则返回null isEmpty()：判断是否为空 返回 count是否等于0 size()：获取哈希表大小 返回count值 resize(newLimit)：扩容和缩容方法 先存储原数组 原属性重置 遍历原数组，把里面每个索引中的每个bucket中的每一个值都取出来重新添加进扩容后的数组中 isPrime(num)：判断是否为质数 将传入的num开平方根，然后遍历2和开平方根之后的值之间的数值，如果传入的num值可以和这中间一个值除尽，那么就跳出返回false不是质数。遍历结束返回true，是质数。 getPrime(num)：获取质数size 循环遍历判断传入的值是否为质数，如果不 4.代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185//哈希表 function HashTable () &#123; //属性 //哈希表的基准数组 this.storage = [] //哈希表中的元素总数，[key,val] this.count = 0 //基准数组的大小 this.limit = 7 //哈希函数： 将str字符串转换成大的数字hashcode，再将大的数字压缩到数组大小(limit)范围以内index HashTable.prototype.hashFunc = function (str, size) &#123; //1.定义hashcode let hashCode = 0 //2.霍纳法则来计算hashcode //将str转换成Unicode编码 for (let i = 0; i &lt; str.length; i++) &#123; //哈希表的长度使用质数43 47 等等， hashCode = 37 * hashCode + str.charCodeAt(i) &#125; //3.取余操作 let index = hashCode % size return index &#125; //put方法，添加&amp;修改：如果storage中原先不存在key即插入添加操作，如果存在即修改操作 HashTable.prototype.put = function (key, value) &#123; //1.根据key调用哈希函数来计算index值 let index = this.hashFunc(key, this.limit) //2.根据索引值index获取在storage中对应的bucket数组 let bucket = this.storage[index] //3.判断bucket是否为null,如果是null，那就创建[] if (bucket === null || bucket === undefined) &#123; bucket = [] //并且storage[index]创建[] this.storage[index] = bucket &#125; //4.bucket不为空，遍历bucket，找到对应key，如果存在key，那就修改，不存在即添加插入 //拉链法中的元素存储结构为，[[[k,v],[k2,v2],[k3,v3]]],即bucket数组，[[k,v],[k2,v2],[k3,v3]] for (let i = 0; i &lt; bucket.length; i++) &#123; let tuple = bucket[i] if (tuple[0] === key) &#123; tuple[1] = value return &#125; &#125; //5.如果没有跳出，那就说明没有找到对应的key,那就添加 bucket.push([key, value]) //6.计数器this.count++ this.count++ //7.判断是否需要扩容 loadFactor(填装因子) &gt; 0.75时候扩容 if (this.count &gt; this.limit * 0.75) &#123; //扩容后新的数组大小为原来的两倍 const newSize = this.limit * 2 //getPrime获取质数方法，目的为了使哈希表的长度为质数 const primeSize = this.getPrime(newSize) //调用resize扩容或缩容的方法 this.resize(primeSize) &#125; &#125; //get方法：通过key来获取哈希table中的value值 HashTable.prototype.get = function (key) &#123; //1.通过key来调用哈希函数获取index let index = this.hashFunc(key, this.limit) //2.通过index来获取到对应的bucket let bucket = this.storage[index] //3.判断bucket是否为空 if (bucket === null || bucket === undefined) &#123; return null &#125; //4.如果存在遍历获取 for (let i = 0; i &lt; bucket.length; i++) &#123; let tuple = bucket[i] if (tuple[0] === key) &#123; return tuple[1] &#125; &#125; //5.如果在bucket中没有找到，那么返回null return null &#125; //remove方法：删除方法 HashTable.prototype.remove = function (key) &#123; //1.通过Key来调用哈希函数获取index let index = this.hashFunc(key, this.limit) //2.通过Index获取对应的bucket let bucket = this.storage[index] //3.判断bucket是否为空 if (bucket === null || bucket === undefined) &#123; return null &#125; //4.如果存在就遍历查抄，删除 for (let i = 0; i &lt; bucket.length; i++) &#123; let tuple = bucket[i] if (tuple[0] === key) &#123; bucket.splice(i, 1) this.count-- //判断是否需要缩容 if (this.count &lt; this.limit * 0.25) &#123; const newSize = Math.floor(this.limit / 2) const primeSize = this.getPrime(newSize) this.resize(primeSize) &#125; return tuple[1] &#125; &#125; //5.如果bucket中不存在返回null return null &#125; //isEmpty 判断是否为空方法 HashTable.prototype.isEmpyt = function () &#123; return this.count === 0 &#125; //size方法 获取size的方法 HashTable.prototype.size = function () &#123; return this.count &#125; //resize方法 扩容或者缩容的方法 HashTable.prototype.resize = function (newLimit) &#123; //存储原数组 const oldStorage = this.storage //原属性重置 this.storage = [] this.limit = newLimit this.count = 0 //遍历原数组，把每个索引的bucket中的每个值都取出来添加到扩容或者缩容的数组中 for (let i = 0; i &lt; oldStorage.length; i++) &#123; //获取到bucket const bucket = oldStorage[i] //判断bucket是否为空 if (bucket === null || bucket === undefined) &#123; continue &#125; //遍历每个bucket的每个值 for (let j = 0; j &lt; bucket.length; j++) &#123; let tuple = bucket[j] this.put(tuple[0], tuple[1]) &#125; &#125; &#125; //isPrime方法 判断是否是质数 HashTable.prototype.isPrime = function (num) &#123; const temp = parseInt(Math.sqrt(num)) for (let i = 2; i &lt; temp; i++) &#123; if (temp % 2 === 0) &#123; return false &#125; &#125; return true &#125; //getPrime 获取到质数size HashTable.prototype.getPrime = function (num) &#123; while (!this.isPrime(num)) &#123; num++ &#125; return num &#125; &#125; const hashTable = new HashTable() hashTable.put(&#x27;abc&#x27;, 18) hashTable.put(&#x27;aaa&#x27;, 20) hashTable.put(&#x27;vvv&#x27;, 1111) console.log(hashTable); console.log(hashTable.get(&#x27;vvv&#x27;)); hashTable.remove(&#x27;aaa&#x27;) console.log(hashTable);","categories":[{"name":"JS","slug":"JS","permalink":"http://awesomeboy.cn/categories/JS/"},{"name":"数据结构","slug":"数据结构","permalink":"http://awesomeboy.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://awesomeboy.cn/tags/JS/"},{"name":"数据结构","slug":"数据结构","permalink":"http://awesomeboy.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"author":"awesomeboy"},{"title":"LeetCode-242-有效的字母异位词","slug":"LeetCode-242-有效的字母异位词","date":"2023-05-08T12:14:26.000Z","updated":"2023-05-22T12:57:26.488Z","comments":true,"path":"2023/05/08/LeetCode-242-有效的字母异位词/","link":"","permalink":"http://awesomeboy.cn/2023/05/08/LeetCode-242-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/","excerpt":"","text":"一：题目描述：给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。 注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。 二：示例与提示示例 1:12输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;输出: true 示例 2:12输入: s = &quot;rat&quot;, t = &quot;car&quot;输出: false 提示: 1 &lt;= s.length, t.length &lt;= 5 * 104 s 和 t 仅包含小写字母 三：思路排序 思路一：利用排序，将两个字符串排序好再一一对比字符是否相同 哈希表 思路二：利用哈希表，创建hashmap，将s中的每个字符都添加到hashmap中，并设置初始值为1，如果有相同的字符，值+1。再到t遍历，判断hashmap中是否有t的字符，如果有，原先的hashmap对应字符的值-1，（理解为相互消掉），如果值不大于（说明词数不匹配），返回false 四：代码1：正则1234var reverseWords = function(s) &#123; return s.trim().split(/\\s+/).reverse().join(&#x27; &#x27;) // console.log(s.trim().split(/\\s+/).reverse().join(&#x27; &#x27;))&#125;; 2：双端队列1234567891011121314151617181920212223var reverseWords = function(s) &#123; //双端队列 //1. 去除字符串前后的空格 let left = 0 let right = s.length-1 let word = &#x27;&#x27; let queue = [] while(s.charAt(left) === &#x27; &#x27;) left++ while(s.charAt(right) === &#x27; &#x27;) right-- //2.遍历字符串 拼接单词 加入队列 while(left &lt;= right)&#123; let char = s.charAt(left) if(char === &#x27; &#x27; &amp;&amp; word)&#123; queue.unshift(word) word = &#x27;&#x27; &#125;else if(char !== &#x27; &#x27;)&#123; word += char //拼串 &#125; left++ &#125; queue.unshift(word) return queue.join(&#x27; &#x27;)&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://awesomeboy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"哈希表","slug":"哈希表","permalink":"http://awesomeboy.cn/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}],"author":"awesomeboy"},{"title":"Vue3知识点总结-学习笔记","slug":"Vue3知识点总结-学习笔记","date":"2023-04-24T11:42:07.000Z","updated":"2023-08-10T13:53:41.814Z","comments":true,"path":"2023/04/24/Vue3知识点总结-学习笔记/","link":"","permalink":"http://awesomeboy.cn/2023/04/24/Vue3%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"这里是对于学习vue3的一些新特性的学习笔记的总结，巩固与复习一下最近学习的知识点吧 Vue3官方中文文档：https://cn.vuejs.org/guide/introduction.html 一：认识Vue31.性能提升 打包大小减少41% 初次渲染快55%, 更新渲染快133% 内存减少54% 使用Proxy代替defineProperty实现数据响应式 重写虚拟DOM的实现和Tree-Shaking 2.新增特性 Composition (组合) API setup ref 和 reactive computed 和 watch 新的生命周期函数 provide与inject 新组件 Fragment - 文档碎片 Teleport - 瞬移组件的位置 Suspense - 异步加载组件的loading界面 其它API更新 全局API的修改 将原来的全局API转移到应用对象 模板语法变化 3.创建vue3项目3.1 使用 vue-cli 创建 文档: https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create 123456## 安装或者升级npm install -g @vue/cli## 保证 vue cli 版本在 4.5.0 以上vue --version## 创建项目vue create my-project 3.2 使用 vite 创建 文档: https://v3.cn.vuejs.org/guide/installation.html vite 是一个由原生 ESM 驱动的 Web 开发构建工具。在开发环境下基于浏览器原生 ES imports 开发， 它做到了本地快速开发启动, 在生产环境下基于 Rollup 打包。 快速的冷启动，不需要等待打包操作； 即时的热模块更新，替换性能和模块数量的解耦让更新飞起； 真正的按需编译，不再等待整个应用编译完成，这是一个巨大的改变。 1234npm init vite-app &lt;project-name&gt;cd &lt;project-name&gt;npm installnpm run dev 二：核心Composition API1. setup 一个组件选项，在组件被创建之前，props 被解析之后执行。 它是组合式 API的入口。 Vue3.0中的一个新的配置项，值为一个函数。组件中所用到的：数据、方法等等，均要配置再setup中。 setup带来的改变 1.解决了vue2的data和methods方法相距太远，无法组件之间复用 2.提供了script标签引入共同业务逻辑的代码块，顺序执行 3.script变成setup函数，默认暴露给模版 4.组件直接挂载，无需注册 5.自定义的指令也可以在模版中自动获得 6.this不再是这个活跃实例的引用 7.带来的大量全新api，比如defineProps，defineEmits，withDefault，toRef，toRefs 1.1 vue3.0 写法 setup是一个新的组件选项，作为组件中使用组合API的起点。 从组件生命周期来看，它的执行在组件实例创建之前vue2.x的beforeCreate执行。 这就意味着在setup函数中this 还不是组件实例，this此时是undefined 在模版中需要使用的数据和函数，需要在setup返回。 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div&gt; &lt;h1&gt;初始setup&lt;/h1&gt; &lt;h2&gt;姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt; &lt;h2&gt;年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;sayHello&quot;&gt;点击&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;App&#x27;, setup()&#123; let name = &#x27;张三&#x27; let age = 19 function sayHello() &#123; alert(&#x27;初始setup函数&#x27;) &#125; return &#123; name, age, sayHello &#125; &#125;&#125;&lt;/script&gt; 1.2 单文件组件&lt;script setup&gt;&lt;/script &gt; 每个 *.vue 文件最多可以包含一个 &lt;script setup&gt;。(不包括一般的 &lt;script&gt;) 这个脚本块将被预处理为组件的 setup() 函数，这意味着它将为每一个组件实例都执行。&lt;script setup&gt; 中的顶层绑定都将自动暴露给模板。 在单文件组件 (SFC) 中使用组合式 API 的编译时语法糖。当同时使用 SFC 与组合式 API 时该语法是默认推荐。相比于普通的 &lt;script&gt; 语法，它具有更多优势： 更少的样板内容，更简洁的代码。 能够使用纯 TypeScript 声明 props 和自定义事件。这个我下面是有说明的 更好的运行时性能 (其模板会被编译成同一作用域内的渲染函数，避免了渲染上下文代理对象)。 更好的 IDE 类型推导性能 (减少了语言服务器从代码中抽取类型的工作)。 基本语法 顶层的绑定会被暴露给模板 当使用 &lt;script setup&gt; 的时候，任何在 &lt;script setup&gt; 声明的顶层的绑定 (包括变量，函数声明，以及 import 导入的内容) 都能在模板中直接使用 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;template&gt; &lt;div&gt; &lt;input type=&quot;text&quot; v-model=&quot;keyWord&quot;&gt; &lt;div&gt;&#123;&#123;keyWord&#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;//实现自定义myRef函数import &#123; ref, customRef &#125; from &#x27;vue&#x27;//使用vue3提供的ref API//现在使用自定义API来实现div延时显示input输入的内容// let keyWord = ref(&#x27;hello&#x27;)//定义myReffunction myRef(value, delayTime) &#123; //封装的自定义函数需要返回值 返回customRef // 两个参数 1.track：追踪 ， 在get函数中需要调用 track()来追踪数据 2.trigger:触发，在set中更改数据后 调用trigger告诉vue3重新渲染模板，这时候再到get函数中渲染新值 return customRef((track, trigger) =&gt; &#123; let timer //这里的返回值是语法需要返回的 return &#123; get() &#123; console.log(`有人读取了数据，返回$&#123;value&#125;`) track() return value &#125;, set(newValue) &#123; //防抖 clearTimeout(timer) console.log(`有人更改了数据，新数据是$&#123;newValue&#125;`) value = newValue timer = setTimeout(() =&gt; &#123; trigger() &#125;, delayTime) &#125;, &#125; &#125;)&#125;let keyWord = myRef(&#x27;hello&#x27;, 1000)&lt;/script&gt; 1.3 setup执行的时机在beforeCreate之前执行一次，this是undefined。 123456789101112131415161718192021222324 &lt;template&gt; &lt;h1&gt;一个人的信息&lt;/h1&gt; &lt;h3&gt;姓名：&#123;&#123; person.name &#125;&#125;&lt;/h3&gt;&lt;/template&gt;&lt;script&gt;import &#123; defineComponent, reactive &#125; from &#x27;vue&#x27;export default defineComponent(&#123; beforeCreate() &#123; console.log(&#x27;-----beforeCreate-----&#x27;) &#125;, setup() &#123; console.log(&#x27;-----setup-----&#x27;, this) let person = reactive(&#123; name: &#x27;张三&#x27;, &#125;) return &#123; person, &#125; &#125;,&#125;)&lt;/script&gt; 1.4 setup的参数参数 参数1. props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性 参数2. context：上下文对象： attrs：值为对象，包含：组件外部传递过来，但没有在 props 配置中声明的属性，相当于Vue2.x的this.$attrs。 slots：收到的插槽内容，相当于Vue2.x的this.$slots。 emit：分发自定义事件的函数，相当于Vue2.x的 this.$emit。 12345678910111213141516export default &#123; setup(props, context) &#123; // Attribute (非响应式对象，等同于 $attrs) console.log(context.attrs) // 插槽 (非响应式对象，等同于 $slots) console.log(context.slots) // 触发事件 (方法，等同于 $emit) console.log(context.emit) // 暴露公共 property (函数) console.log(context.expose) &#125;&#125; 2. ref 作用: 定义一个数据的响应式 语法: const xxx &#x3D; ref(initValue): 创建一个包含响应式数据的引用(reference)对象 js中操作数据: xxx.value 模板中操作数据: 不需要.value 一般用来定义一个基本类型的响应式数据 2.1 ref API实现响应式数据 接收的数据可以是：基本类型、也可以是对象类型 基本类型的数据：响应式依然靠的是Object.defineProperty()的get和set完成的 对象类型的数据： 内部”求助“了Vue3.0中的一个新的函数——reactive函数 12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;div&gt; &lt;h2&gt;姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt; &lt;h2&gt;年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;changeInfo&quot;&gt;点击更改信息&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;//响应式ref函数import &#123; ref &#125; from &quot;vue&quot;;export default &#123; name: &#x27;App&#x27;, setup()&#123; let name = ref(&#x27;张三&#x27;) let age = ref(20) function changeInfo() &#123; // console.log(name) name.value = &#x27;李四&#x27; age.value = 25 &#125; return &#123; name, age, changeInfo, &#125; &#125;&#125;&lt;/script&gt; 2.2 ref属性操作单个Dom 操作单个DOM或者组件的流程 定义一个响应式变量 把变量返回给模板使用 模板中绑定上述返回的数据 可以通过info变量操作DOM或者组件实例 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;h2&gt;ref操作Dom和组件&lt;/h2&gt; &lt;hr&gt; &lt;!-- 3. 模板绑定返回的数据 --&gt; &lt;div ref=&quot;info&quot;&gt;Hello&lt;/div&gt; &lt;button @click=&quot;handleClick&quot;&gt;点击&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import &#123;ref&#125; from &#x27;vue&#x27;export default &#123; setup()&#123; //vue3通过ref操作dom //1. 定义一个响应式变量 const info = ref(null) const handleClick = () =&gt; &#123; //4. 此时可以通过info变量操作dom console.log(info.value) &#125; //2.将变量返回给模板使用 return &#123; info, handleClick &#125; &#125;&#125;&lt;/script&gt; 2.3 ref属性获取v-for遍历的DOM或者组件 ref批量操作元素的流程 定义一个函数 把该函数绑定到ref上（必须动态绑定） 在函数中可以通过参数得到单个元素，这个元素一般可以放到数组中 通过上述数组即可操作批量的元素 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;template&gt; &lt;h2&gt;ref操作Dom和组件&lt;/h2&gt; &lt;hr&gt; &lt;!-- 3. 模板绑定返回的数据 --&gt; &lt;ul&gt; &lt;li :ref=&quot;setFruits&quot; v-for=&quot;item in fruits&quot; :key=&quot;item.id&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;button @click=&quot;handleClick&quot;&gt;点击&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import &#123; ref &#125; from &#x27;vue&#x27;export default &#123; setup() &#123; //1. 定义一个响应式变量 const fruits = ref([ &#123; id: 1, name: &#x27;apple&#x27;, &#125;, &#123; id: 2, name: &#x27;orange&#x27;, &#125;, &#123; id: 3, name: &#x27;pear&#x27;, &#125;, ]) //定义操作dom函数 const arr = [] const setFruits = (el) =&gt; &#123; //el表示单个dom元素 arr.push(el) &#125; const handleClick = () =&gt; &#123; //4.此时可以通过arr数组操作dom console.log(arr) &#125; //2.将变量返回给模板使用 return &#123; fruits, handleClick, setFruits &#125; &#125;,&#125;&lt;/script&gt; 3. reactive 作用: 定义多个数据的响应式 const proxy &#x3D; reactive(obj): 接收一个普通对象然后返回该普通对象的响应式代理器对象 响应式转换是“深层的”：会影响对象内部所有嵌套的属性 内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据都是响应式的 3.1 reactive和ref的区别 从定义数据角度对比 ref用来定义：基本类型数据。 reactive用来定义：对象（或数组）类型数据。 备注：ref也可以用来定义对象（或数组）类型数据。它内部会自动通过reactive转为代理对象。 ref也能用于定义引用数据类型，如下述代码，不过做响应式时对数据进行修改需要.value进行更改，否则响应式效果将失效。ref定义对象时，底层会通过reactive转换成具有深层次的响应式对象，所以ref本质上是reactive的再封装 从使用角度对比 ref定义的数据：操作数据需要.value，读取数据时模版中直接读取不需要.value。 reactive定义的数据：操作数据与读取数据均不需要.value。 从原理角度对比 ref通过Object.defineProperty()的get与set来实现响应式（数据劫持）。 reactive通过使用Proxy来实现响应式（数据劫持），并通过Reflect操作源对象内部的数据。 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;template&gt; &lt;h3&gt;ref和reactive的区别&lt;/h3&gt; &lt;hr&gt; &lt;div&gt;student: &#123;&#123;student.name&#125;&#125; -- &#123;&#123;student.age&#125;&#125; -- &#123;&#123;student.school&#125;&#125;&lt;/div&gt; &lt;button @click=&quot;changeStudent&quot;&gt;点击改变信息&lt;/button&gt; &lt;hr&gt; &lt;div&gt;student: &#123;&#123;student2.name&#125;&#125; -- &#123;&#123;student2.age&#125;&#125; -- &#123;&#123;student2.school&#125;&#125;&lt;/div&gt; &lt;button @click=&quot;changeStudent2&quot;&gt;点击改变信息2&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import &#123; ref, reactive &#125; from &quot;vue&quot;;export default &#123; setup()&#123; const student = ref(&#123; name: &#x27;小李&#x27;, age: 19, school: &#x27;xupt&#x27; &#125;) const student2 = reactive(&#123; name: &#x27;Bob&#x27;, age: 20, school: &#x27;xupt&#x27; &#125;) const changeStudent = () =&gt; &#123; student.value.name = &#x27;xxx&#x27; student.value.age = 100 &#125; const changeStudent2 = () =&gt; &#123; student2.name = &#x27;张三&#x27;, student2.age = 30 &#125; return &#123; student, student2, changeStudent, changeStudent2 &#125; &#125;&#125;&lt;/script&gt; 3.2 reactive无法对基本数据类型做出响应式reactive只能用于定义引用数据类型的原因在于内部是通过ES6的Proxy实现响应式的，而Proxy不适用于基本数据类型 返回对象的响应式副本，只能代理对象，不能代理普通值 123456789101112131415&lt;template&gt; &lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; ref, reactive &#125; from &quot;vue&quot;;export default &#123; setup()&#123; const name = reactive(&#x27;张三&#x27;) return &#123; name &#125; &#125;&#125;&lt;/script&gt; 3.3 reactive响应式原理-Proxy 通过 Proxy(代理) 拦截对象中任意属性的变化，包括：属性值的读写、属性的添加、属性的删除等。 通过 Reflect(反射)对源对象的属性进行操作。 1234567891011121314151617181920212223242526272829303132//数据源let student = &#123; name: &#x27;张三&#x27;, age: 18, shcool: &#x27;xupt&#x27;&#125;let proxy = new Proxy(data, &#123; // 拦截读取属性值 get (target, prop) &#123; // target:原对象； prop:读取的属性 console.log(`监听到了属性值$&#123;prop&#125;被读取`) return Reflect.get(target, prop) &#125;, // 拦截设置属性值或添加新属性 set (target, prop, value) &#123; // target:原对象； prop:要修改/增加的属性 value：值 //target[prop] = value console.log(`监听到了属性值$&#123;prop&#125;发生变化`) return Reflect.set(target, prop, value) &#125;, // 拦截删除属性 deleteProperty (target, prop) &#123; //return delete target[prop] console.log(`监听到了属性值$&#123;prop&#125;被删除`) return Reflect.deleteProperty(target, prop) &#125;&#125;)// proxy 就是源数据 data 的响应式代理对象proxy.name // 触发监听proxy.name = &#x27;李四&#x27; // 触发监听delete proxy.name // 触发监听 4. 计算属性Computed computed和watch都是vue框架中的用于监听数据变化的属性，都能在数据改变时，针对改变的相关数据做成相应的变化。 4.1 computed的使用 作为组合式API之一，大体用法与vue2用法一致，只不过不再是作为配置函数使用了 12345678910111213141516171819202122&lt;template&gt; &lt;div&gt;&#123;&#123;sumName&#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; computed, reactive&#125; from &quot;vue&quot;;export default &#123; setup()&#123; const allName = reactive(&#123; userName1: &#x27;张三&#x27;, userName2: &#x27;李四&#x27; &#125;) const sumName = computed(() =&gt; &#123; return allName.userName1 + &#x27;---&#x27; + allName.userName2 &#125;) return &#123; sumName &#125; &#125;&#125;&lt;/script&gt; 4.2 计算属性的缓存特点上方代码是利用computed计算属性完成将两者姓名拼串在一起，当然这种利用方法也能完成，那为什么不用方法去代替计算属性去解决所有类似问题呢？ 原因是计算属性是基于缓存来实现的，无论你后端调用十次还是几百次，只要计算属性依赖的相关值没有发生变化，那计算属性就可以通过缓存读取。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;template&gt; &lt;!-- 利用计算属性完成拼串 --&gt; &lt;div&gt;&#123;&#123;sumName&#125;&#125;&lt;/div&gt; &lt;div&gt;&#123;&#123;sumName&#125;&#125;&lt;/div&gt; &lt;div&gt;&#123;&#123;sumName&#125;&#125;&lt;/div&gt; &lt;div&gt;&#123;&#123;sumName&#125;&#125;&lt;/div&gt; &lt;div&gt;&#123;&#123;sumName&#125;&#125;&lt;/div&gt; &lt;div&gt;&#123;&#123;sumName&#125;&#125;&lt;/div&gt; &lt;div&gt;&#123;&#123;sumName&#125;&#125;&lt;/div&gt; &lt;div&gt;&#123;&#123;sumName&#125;&#125;&lt;/div&gt;&lt;!-- 利用方法完成拼串 --&gt; &lt;div&gt;&#123;&#123;sumAllName()&#125;&#125;&lt;/div&gt; &lt;div&gt;&#123;&#123;sumAllName()&#125;&#125;&lt;/div&gt; &lt;div&gt;&#123;&#123;sumAllName()&#125;&#125;&lt;/div&gt; &lt;div&gt;&#123;&#123;sumAllName()&#125;&#125;&lt;/div&gt; &lt;div&gt;&#123;&#123;sumAllName()&#125;&#125;&lt;/div&gt; &lt;div&gt;&#123;&#123;sumAllName()&#125;&#125;&lt;/div&gt; &lt;div&gt;&#123;&#123;sumAllName()&#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; computed, reactive&#125; from &quot;vue&quot;;export default &#123; setup()&#123; const allName = reactive(&#123; userName1: &#x27;张三&#x27;, userName2: &#x27;李四&#x27; &#125;) const sumName = computed(() =&gt; &#123; console.log(&#x27;计算属性调用&#x27;) return allName.userName1 + &#x27;---&#x27; + allName.userName2 &#125;) const sumAllName = () =&gt; &#123; console.log(&#x27;方法调用&#x27;) return allName.userName1 + &#x27;111&#x27; + allName.userName2 &#125; return &#123; sumName, sumAllName &#125; &#125;&#125;&lt;/script&gt; 上述代码，利用计算属性和方法完成相同的拼串功能，并在模板中各展示了数边，并让其调用一次就在控制台打印输出一次是计算属性调用还是方法调用，那么结果便是，计算属性调用只在控制台输出了一次，而方法调用则是在调几次打印几次。这就是计算属性的缓存，只要其依赖的值不发生相关的变化，那么无论你计算属性调用了好多次，但最终就只是执行一次。 5. 监视属性watch 当被监视的属性变化时，回调函数自动调用，进行相关操作，所谓监视属性，就是监测指定的属性是否发生变化，如果发生了，则进行一系列操作，如果没发生变化，则监视属性也不会被触发。 Vue3中的watch属性和Vue2的基本一致，作用一致。Vue2中watch属性时作为一个配置项来使用，在Vue3中watch作为函数来使用。 虽然在Vue3中可以使用Vue2的语法，但是watch属性在Vue3中不推荐写成配置项的方式，因为在Vue3中提倡的就是组合式API的思想。 第一个参数是侦听器的源。这个来源可以是以下几种： 一个函数, 一个返回值一个ref一个响应式对象(reactive定义的)…或是由以上类型的值组成的数组第二个参数是一个回调函数, 这个回调函数可接收三个参数: 新值(newValue)、旧值(oldValue)、以及一个副作用清理的回调函数 第三个参数是一个可选的参数是一个对象构成, 如:deep(深度监视)、immediate(创建时立即监听一次)等等… 5.1 watch监视ref定义的一个响应式数据 watch的第一个参数即监视的该数据 123456789101112131415161718192021222324252627282930313233&lt;template&gt; &lt;div&gt;&#123;&#123;userAge&#125;&#125;&lt;/div&gt; &lt;button @click=&quot;userAge++&quot;&gt;点击年龄++&lt;/button&gt; &lt;hr&gt; &lt;div&gt;&#123;&#123;userName&#125;&#125;&lt;/div&gt; &lt;button @click=&quot;userName = &#x27;李四&#x27;&quot;&gt;点击更改姓名&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import &#123; ref, reactive, watch &#125; from &#x27;vue&#x27;export default &#123; setup() &#123; const userAge = ref(18) const userName = ref(&#x27;张三&#x27;) //1.监视ref定义的一个响应式数据 watch(userAge, (newValue, oldValue) =&gt; &#123; console.log( &#x27;修改了年龄 &#x27; + &#x27;newValue: &#x27; + newValue + &#x27; oldValue: &#x27; + oldValue ) &#125;) watch(userName, (newValue, oldValue) =&gt; &#123; console.log( &#x27;修改了姓名 &#x27; + &#x27;newValue: &#x27; + newValue + &#x27; oldValue:&#x27; + oldValue ) &#125;) return &#123; userAge, userName &#125; &#125;,&#125;&lt;/script&gt; 5.2 watch监视ref定义的多个响应式数据 watch第一个数据源参数作为数组传入 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div&gt;&#123;&#123;userAge&#125;&#125;&lt;/div&gt; &lt;button @click=&quot;userAge++&quot;&gt;点击年龄++&lt;/button&gt; &lt;hr&gt; &lt;div&gt;&#123;&#123;userName&#125;&#125;&lt;/div&gt; &lt;button @click=&quot;userName = &#x27;李四&#x27;&quot;&gt;点击更改姓名&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import &#123; ref, reactive, watch &#125; from &#x27;vue&#x27;export default &#123; setup() &#123; const userAge = ref(18) const userName = ref(&#x27;张三&#x27;) //2.监视ref定义的多个响应式数据 watch([userAge, userName], (newValue, oldValue) =&gt; &#123; console.log( &#x27;数据被修改了 &#x27; + &#x27;newValue: &#x27; + newValue + &#x27; oldValue: &#x27; + oldValue ) &#125;) return &#123; userAge, userName &#125; &#125;,&#125;&lt;/script&gt; 5.3 watch监视reactive定义的一个响应式数据的全部属性这里会出现问题 1. 可以捕获newValue新值，但无法捕获oldValue旧的值 2. 强制开启深度监视，即使手动将深度监视关闭也无效 打印的结果发现oldValue和newValue一致 123456789101112131415161718192021222324252627282930313233343536373839&lt;template&gt; &lt;div&gt;&#123;&#123;userInfo.userAge&#125;&#125;&lt;/div&gt; &lt;button @click=&quot;userInfo.userAge++&quot;&gt;点击年龄++&lt;/button&gt; &lt;hr&gt; &lt;div&gt;&#123;&#123;userInfo.userName&#125;&#125;&lt;/div&gt; &lt;button @click=&quot;userInfo.userName = &#x27;李四&#x27;&quot;&gt;点击更改姓名&lt;/button&gt; &lt;hr&gt; &lt;!-- 深度监视是否关闭 --&gt; &lt;div&gt;&#123;&#123;userInfo.userSchool.school&#125;&#125;&lt;/div&gt; &lt;button @click=&quot;userInfo.userSchool.school = &#x27;西柚&#x27;&quot;&gt;点击更改学校,看深度监视是否关闭&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import &#123; ref, reactive, watch &#125; from &#x27;vue&#x27;export default &#123; setup() &#123; let userInfo = reactive(&#123; userAge: 19, userName: &#x27;张三&#x27;, userSchool: &#123; area: &#x27;陕西&#x27;, school: &#x27;xupt&#x27;, &#125;, &#125;) //3.监视reactive定义的一个响应式数据的全部属性 watch( userInfo, (newValue, oldValue) =&gt; &#123; console.log(&#x27;数据被修改了 &#x27;, newValue, oldValue) &#125;, &#123; deep: false &#125; ) return &#123; userInfo, &#125; &#125;,&#125;&lt;/script&gt; 5.4 watch监视reactive定义的一个相应式数据的某个数据 这里借助5.3的代码监视userInfo的年龄属性 不能使用userInfo.userAge对其进行监视会报warning 12345678//4.监视reactive定义的一个响应式数据的某个属性watch( userInfo.userAge, (newValue, oldValue) =&gt; &#123; console.log(&#x27;数据被修改了 &#x27;, newValue, oldValue) &#125;, &#123; deep: false &#125;) 正确写法 将被监视的数据作为函数的返回值使用 12345678//4.监视reactive定义的一个响应式数据的某个属性watch( () =&gt; &#123;return userInfo.userAge&#125;, (newValue, oldValue) =&gt; &#123; console.log(&#x27;数据被修改了 &#x27;, newValue, oldValue) &#125;, &#123; deep: false &#125;) 5.5 watch监视reactive定义的一个相应式数据的多个数据 用一个数组包裹, 数组里面写多个函数来返回所响应的数据 12345678//5.监视reactive定义的一个响应式数据的多个属性watch( [() =&gt; userInfo.userAge, () =&gt; userInfo.userName], (newValue, oldValue) =&gt; &#123; console.log(&#x27;数据被修改了 &#x27;, newValue, oldValue) &#125;, &#123; deep: false &#125;) 6. watchEffect函数 传入的一个函数，当依赖项变化的时候，重新执行改函数。 6.1 watchEffect函数的特性 与watch相似都可以监听一个数据源。但是watchEffect会在初始化的时候调用一次，与watch的immediate类似。 1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;div&gt;&#123;&#123;userInfo.userAge&#125;&#125;&lt;/div&gt; &lt;button @click=&quot;userInfo.userAge++&quot;&gt;点击年龄++&lt;/button&gt; &lt;hr&gt;&lt;/template&gt;&lt;script&gt;import &#123; ref, reactive, watch, watchEffect &#125; from &#x27;vue&#x27;export default &#123; setup() &#123; let userInfo = reactive(&#123; userAge: 19, userName: &#x27;张三&#x27;, userSchool: &#123; area: &#x27;陕西&#x27;, school: &#x27;xupt&#x27;, &#125;, &#125;) //5.监视reactive定义的一个响应式数据的多个属性 watchEffect(() =&gt; &#123; console.log(`$&#123;userInfo.userAge&#125;值修改了`) &#125;) return &#123; userInfo, &#125; &#125;,&#125;&lt;/script&gt; 当我为触发点击事件时候，watchEffect函数已经被调用了，初始化会执行一次 6.2 watch与watchEffect的区别 watch的套路是：既要指明监视的属性，也要指明监视的回调 watchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，就监视哪个属性 watchEffect有点像computed： 但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。 7. Vue3生命周期 vue3声明周期钩子 setup() :开始创建组件之前，在beforeCreate和created之前执行。创建的是data和method onBeforeMount() : 组件挂载到节点上之前执行的函数。 onMounted() : 组件挂载完成后执行的函数。 onBeforeUpdate(): 组件更新之前执行的函数。 onUpdated(): 组件更新完成之后执行的函数。 onBeforeUnmount(): 组件卸载之前执行的函数。 onUnmounted(): 组件卸载完成后执行的函数 onActivated(): 被包含在中的组件，会多出两个生命周期钩子函数。被激活时执行。 onDeactivated(): 比如从 A 组件，切换到 B 组件，A 组件消失时执行。 onErrorCaptured(): 当捕获一个来自子孙组件的异常时激活钩子函数 8. 自定义hook函数8.1 什么是hook? vue3 借鉴 react hooks 开发出了 Composition API ，所以也就意味着 Composition API 也能进行自定义封装 hooks。 vue3 中的 hooks 就是函数的一种写法，就是将文件的一些单独功能的js代码进行抽离出来，放到单独的js文件中，或者说是一些可以复用的公共方法&#x2F;功能。其实 hooks 和 vue2 中的 mixin 有点类似，但是相对 mixins 而言， hooks 更清楚复用功能代码的来源, 更清晰易懂。 在学习es6我们学到了class类与对象进行模块化管理，在vue2中我们可以用mixin混合进行模块化管理，那么在Vue3中我们可以用到hook函数 8.2 为什么使用hook函数？ 当我们写项目的时候，或多或少都会遇到多个地方用到同一模块的功能，那么我们是不会选择复制粘贴过去，后续当对应功能数据接口发生改变，我们是需要花费很大精力去一一修改，这就需要将其封装抽离出来作为模块暴露出来，哪需要就引入使用即可。 8.3 hook函数的使用 创建hooks文件夹，将需要抽离出来的功能模块全部放入hooks文件中统一管理 2.创建对应的js文件，并将其内容暴露。在这个js中，我们也将需要用到的组合式api引入，例如reactive, 生命周期钩子等等。封装抽离，这就更体现了了组合式api 下方代码实现的是点击屏幕将鼠标的当前坐标渲染到模板上 12345678910111213141516171819202122232425import &#123; reactive , onMounted, onBeforeUnmount &#125; from &quot;vue&quot;;export default function usePoint()&#123; const point = reactive(&#123; x: 0, y: 0, &#125;) function savePoint(event) &#123; // console.log(event.pageX) point.x = event.pageX point.y = event.pageY &#125; //挂载时候 onMounted(() =&gt; &#123; window.addEventListener(&#x27;click&#x27;, savePoint) &#125;) //卸载时候 onBeforeUnmount(() =&gt; &#123; window.removeEventListener(&#x27;click&#x27;, savePoint) &#125;) return point&#125; 引入hook文件，接受暴露的数据 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;div&gt; &lt;h1&gt;年龄：&#123;&#123;number&#125;&#125;&lt;/h1&gt; &lt;button @click=&quot;number++&quot;&gt;自增&lt;/button&gt; &lt;hr&gt; &lt;!-- 获取鼠标当前的坐标 --&gt; &lt;button @click=&quot;isShow = !isShow&quot;&gt;隐藏/显示坐标&lt;/button&gt; &lt;h1 v-if=&quot;isShow&quot;&gt;点击显示鼠标当前的坐标: x:&#123;&#123;point.x&#125;&#125;, y:&#123;&#123;point.y&#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; ref, watch&#125; from &#x27;vue&#x27;//引入usePoint文件import usePoint from &#x27;./hook/usePoint&#x27;export default &#123; name: &#x27;App&#x27;, setup() &#123; let number = ref(0) //接受对外暴露的数据 let isShow = ref(false) const point = usePoint() return &#123; number, point, isShow, usePoint &#125; &#125;,&#125;&lt;/script&gt; 三：其余Composition API1. customRefcustomRef 是 Vue 3 中的一个新特性，它允许你创建自定义的响应式引用。 在 Vue 3 中，我们可以使用 ref 函数来创建一个响应式数据。但是有些情况下，我们可能需要创建一些更加复杂的响应式数据，这时候就可以使用 customRef 来实现。 customRef 函数接受一个包含 get 和 set 方法的对象作为参数，并返回一个具有 value 属性的对象。当 customRef 创建的对象中的 value 发生变化时，会触发更新视图的操作。 使用 customRef 可以实现一些高级的响应式逻辑，比如： 缓存计算结果，只在依赖项变化时重新计算 实现惰性更新，只在需要时才更新值 自定义 setter 行为，比如对值进行校验或转换 需要注意的是，由于 customRef 提供了更高度的自定义能力，如果不小心使用不当，可能会导致性能问题。因此，在使用 customRef 时需要谨慎考虑其是否真正必要。 12345678910111213141516171819202122232425262728293031323334353637383940&lt;template&gt; &lt;div&gt; &lt;input type=&quot;text&quot; v-model=&quot;keyWord&quot;&gt; &lt;div&gt;&#123;&#123;keyWord&#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;//实现自定义myRef函数import &#123; ref, customRef &#125; from &#x27;vue&#x27;//使用vue3提供的ref API//现在使用自定义API来实现div延时显示input输入的内容// let keyWord = ref(&#x27;hello&#x27;)//定义myReffunction myRef(value, delayTime) &#123; //封装的自定义函数需要返回值 返回customRef // 两个参数 1.track：追踪 ， 在get函数中需要调用 track()来追踪数据 2.trigger:触发，在set中更改数据后 调用trigger告诉vue3重新渲染模板，这时候再到get函数中渲染新值 return customRef((track, trigger) =&gt; &#123; let timer //这里的返回值是语法需要返回的 return &#123; get() &#123; console.log(`有人读取了数据，返回$&#123;value&#125;`) track() return value &#125;, set(newValue) &#123; //防抖 clearTimeout(timer) console.log(`有人更改了数据，新数据是$&#123;newValue&#125;`) value = newValue timer = setTimeout(() =&gt; &#123; trigger() &#125;, delayTime) &#125;, &#125; &#125;)&#125;let keyWord = myRef(&#x27;hello&#x27;, 1000)&lt;/script&gt; 上述代码，是实现自定义在文本框中输入数据，下方文本延迟1秒钟显示。 2. provide和inject 通常，当我们需要从父组件向子组件传递数据时，我们使用 props。想象一下这样的结构：有一些深度嵌套的组件，而深层的子组件只需要父组件的部分内容。在这种情况下，如果仍然将 prop 沿着组件链逐级传递下去，可能会很麻烦。 对于这种情况，我们可以使用一对 provide 和 inject。无论组件层次结构有多深，父组件都可以作为其所有子组件的依赖提供者。这个特性有两个部分：父组件有一个 provide 选项来提供数据，子组件有一个 inject 选项来开始使用这些数据。 祖先组件 123456789101112131415161718192021222324252627282930313233&lt;template&gt; &lt;div class=&quot;App&quot;&gt; &lt;h3&gt;祖组件 &#123;&#123;age&#125;&#125; -- &#123;&#123;school&#125;&#125;&lt;/h3&gt; &lt;Child/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; provide, reactive, toRefs &#125; from &quot;vue&quot;;import Child from &#x27;./component/Child.vue&#x27;export default &#123; name: &#x27;App&#x27;, components: &#123; Child &#125;, setup()&#123; let student = reactive(&#123; age: 18, school: &#x27;xupt&#x27; &#125;) //提供数据 provide(&#x27;student&#x27;, student) return &#123; ...toRefs(student) &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt; .App &#123; background-color: gray; padding: 10px; &#125;&lt;/style&gt; 父组件 123456789101112131415161718192021&lt;template&gt; &lt;div class=&quot;child&quot;&gt; &lt;h3&gt;父组件&lt;/h3&gt; &lt;GrandSon/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import GrandSon from &#x27;../component/GrandSon.vue&#x27;export default &#123; name: &#x27;Child&#x27;, components: &#123; GrandSon &#125;,&#125;&lt;/script&gt;&lt;style&gt; .child &#123; background-color: aqua; padding: 10px; &#125;&lt;/style&gt; 孙组件 123456789101112131415161718192021222324252627&lt;template&gt; &lt;div class=&quot;GrandSon&quot;&gt; &lt;h3&gt;孙组件 &#123;&#123;age&#125;&#125; -- &#123;&#123;school&#125;&#125;&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; inject, toRefs &#125; from &quot;vue&quot;;export default &#123; name: &#x27;GrandSon&#x27;, setup()&#123; //注射数据，祖孙传递数据 //父子组件传递用props传递数据 let info = inject(&#x27;student&#x27;) return &#123; ...toRefs(info) &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt; .GrandSon &#123; background-color: red; padding: 10px; &#125;&lt;/style&gt; 完结！ 这是vue3知识点的整理，之后等完成项目实际中遇到某些问题，学习到新的vue3知识再进行新的整理吧！","categories":[{"name":"Vue","slug":"Vue","permalink":"http://awesomeboy.cn/categories/Vue/"}],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"http://awesomeboy.cn/tags/Vue3/"},{"name":"Vue","slug":"Vue","permalink":"http://awesomeboy.cn/tags/Vue/"}],"author":"awesomeboy"},{"title":"栈","slug":"栈","date":"2023-03-28T10:59:25.000Z","updated":"2023-08-05T07:58:44.327Z","comments":true,"path":"2023/03/28/栈/","link":"","permalink":"http://awesomeboy.cn/2023/03/28/%E6%A0%88/","excerpt":"","text":"一：栈数据结构 栈是一种遵从后进先出（LIFO）原则的有序集合。新添加或待删除的元素都保存在栈的同 一端，称作栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。 二：基于数组的栈2.1：创建基于数组的栈创建一个类来表示数组 12345class Stack &#123; constructor()&#123; //构造函数 this.items = [] &#125;&#125; 数组允许我们在任何位置进行添加和删除元素，但由于栈遵循先进后出原则，要对元素的删除和插入进行限制 声明一些方法 push(element(s))：添加一个（或几个）新元素到栈顶。 pop()：移除栈顶的元素，同时返回被移除的元素。 peek()：返回栈顶的元素，不对栈做任何修改（该方法不会移除栈顶的元素，仅仅返回它）。 isEmpty()：如果栈里没有任何元素就返回 true，否则返回 false。 clear()：移除栈里的所有元素。 size()：返回栈里的元素个数。该方法和数组的 length 属性很类似。 2.2：向栈添加元素 添加元素到栈顶，即栈的末尾 由于是基于数组实现栈数据结构，所以我们可以使用数组的push方法 123push(element)&#123; this.items.push(element)&#125; 2.3：从栈中移除元素 由于遵循后进先出的原则，因此移除的是最后加入的元素，所以可以使用数组的pop方法来实现 并且返回删除的元素 123pop()&#123; return this.items.pop()&#125; 2.4：查看栈顶元素 由于类的元素是由数组进行保存的，所以访问数组的最后一个元素可以用length - 1 123peek()&#123; return this.items[this.items.length - 1]&#125; 2.5：检查栈是否为空 如果栈为空返回true , 不为空返回false 123isEmpty()&#123; return this.items.length === 0&#125; 2.6：清空栈元素123clear() &#123; this.items = []&#125; 2.7：Stack类1234567891011121314151617181920class Stack &#123; constructor()&#123; //构造函数 this.items = [] &#125; push(element)&#123; //添加 this.items.push(element) &#125; pop()&#123; //删除 return this.items.pop() &#125; peek()&#123; //返回栈顶元素 return this.items[this.items.length - 1] &#125; isEmpty()&#123; //检查是否为空 return this.items.length === 0 &#125; clear() &#123; //清空栈元素 this.items = [] &#125;&#125; 三：基于JS对象的栈创建一个 Stack 类最简单的方式是使用一个数组来存储其元素。在使用数组时，大部分方法的时间复杂度是 O(n)。O(n)的意思是，我们需要迭代整个数组直到找到要找的那个元素，在最坏的情况下需要迭代数组的所有位置，其中的 n 代表数组的长度。如果数组有更多元素的话，所需的时间会更长。另外，数组是元素的一个有序集合，为了保证元素排列有序，它会占用更多的内存空间。 如果我们能直接获取元素，占用较少的内存空间，并且仍然保证所有元素按照我们的需要排列，那不是更好吗？对于使用 JavaScript 语言实现栈数据结构的场景，我们也可以使用一个JavaScript 对象来存储所有的栈元素，保证它们的顺序并且遵循 LIFO 原则。 3.1：创建基于对象的栈 使用一个count属性来帮助我们记录栈的大小小（也能帮助我们从数据结构中添加和删除元素）。 123456class Stack&#123; constructor() &#123; //构造 this.count = 0; this.items = &#123;&#125;; &#125; &#125; 3.2：向栈中插入元素 JavaScript 中，对象是一系列键值对的集合。要向栈中添加元素，我们将使用 count 变量，作为 items 对象的键名，插入的元素则是它的值。在向栈插入元素后，我们递增 count 变量。 1234push(element)&#123; this.items[this.count] = element this.count++&#125; 3.3：检查栈是否为空和它的大小 count 属性也表示栈的大小。因此，我们可以简单地返回 count 属性的值来实现 size 方法。 123size() &#123; return this.count&#125; 要验证栈是否为空，可以像下面这样判断 count 的值是否为 0。 123isEmpty() &#123; return this.count === 0&#125; 3.4：从栈中弹出元素123456789pop() &#123; if(this.isEmpty()) &#123; // 检查栈是否为空，为空返回undefined return undefined; &#125; this.count--; const result = this.items[this.count]; // 保存栈顶元素值，以便返回 delete this.items[this.count]; //delete关键字，从对象中删除特定的值 return result; // &#125; 3.5：查看栈顶元素和清空栈查看栈顶元素 123456peek()&#123; if(this.isEmpty())&#123; return undefined &#125; return this.items[this.count - 1]&#125; 清空栈 1234clear() &#123; this.items = &#123;&#125; this.count = 0&#125; 3.6：创建toString方法 如果栈是空的，我们只需返回一个空字符串即可。如果它不是空的，就需要用它底部的第一个元素作为字符串的初始值，然后迭代整个栈的键，一直到栈顶，添加一个逗号（,）以及下一个元素。 12345678910toString() &#123; if (this.isEmpty()) &#123; return &#x27;&#x27;; &#125; let objString = `$&#123;this.items[0]&#125;` for (let i = 1; i &lt; this.count; i++) &#123; objString = `$&#123;objString&#125;,$&#123;this.items[i]&#125;` &#125; return objString; &#125;","categories":[{"name":"JS","slug":"JS","permalink":"http://awesomeboy.cn/categories/JS/"},{"name":"数据结构","slug":"数据结构","permalink":"http://awesomeboy.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://awesomeboy.cn/tags/JS/"},{"name":"数据结构","slug":"数据结构","permalink":"http://awesomeboy.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"author":"awesomeboy"},{"title":"剑指 Offer 35. 复杂链表的复制","slug":"剑指-Offer-35-复杂链表的复制","date":"2023-03-22T10:28:05.000Z","updated":"2023-05-08T12:22:47.408Z","comments":true,"path":"2023/03/22/剑指-Offer-35-复杂链表的复制/","link":"","permalink":"http://awesomeboy.cn/2023/03/22/%E5%89%91%E6%8C%87-Offer-35-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/","excerpt":"","text":"一：题目描述：请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。 二：示例示例1： 输入：head &#x3D; [[7,null],[13,0],[11,4],[10,2],[1,0]]输出：[[7,null],[13,0],[11,4],[10,2],[1,0]] 示例2： 输入：head &#x3D; [[1,1],[2,1]]输出：[[1,1],[2,1]] 示例3： 输入：head &#x3D; [[3,null],[3,0],[3,null]]输出：[[3,null],[3,0],[3,null]] 示例4： 输入：head &#x3D; []输出：[]解释：给定的链表为空（空指针），因此返回 null。 提示： -10000 &lt;= Node.val &lt;= 10000 Node.random 为空（null）或指向链表中的节点。 节点数目不超过 1000 。 三： 思路哈希表 定义一个哈希表，用于存储每个节点的拷贝节点，键为原始节点，值为拷贝节点。 定义一个指针 cur，从头节点开始遍历原始链表。 在遍历原始链表时，对于一个原始节点 cur，创建一个与其值相同的新节点 copy，并将 cur 和 copy 存入哈希表中。 将 cur 的 next 指针指向 cur.next 的拷贝节点，如果 cur.random 不为空，则将 cur.random 指针指向 cur.random 的拷贝节点。 将 cur 指针向后移动一位，重复步骤 4 直到遍历结束。 最后返回哈希表中存储的头节点的拷贝即可。 图解 四： 代码12345678910111213141516171819202122232425262728293031323334353637383940414243/** * // Definition for a Node. * function Node(val, next, random) &#123; * this.val = val; * this.next = next; * this.random = random; * &#125;; *//** * @param &#123;Node&#125; head * @return &#123;Node&#125; */var copyRandomList = function(head) &#123; //map()方法 //1.先复制结点 //2.next //3.random if(head === null)&#123; return head &#125; var cur = head var map = new Map() //复制结点 while(cur)&#123; //构建哈希表 map.set(cur , new Node(cur.val)) cur = cur.next &#125; cur = head //2.3步 构建next,random指针指向 while(cur)&#123; //next指针构建 map.get(cur).next = map.get(cur.next) === undefined ? null : map.get(cur.next) //random指针构建 map.get(cur).random = map.get(cur.random) === undefined ? null : map.get(cur.random) cur = cur.next &#125; return map.get(head)&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://awesomeboy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"哈希表","slug":"哈希表","permalink":"http://awesomeboy.cn/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"链表","slug":"链表","permalink":"http://awesomeboy.cn/tags/%E9%93%BE%E8%A1%A8/"}],"author":"awesomeboy"},{"title":"单链表","slug":"单链表","date":"2023-03-21T13:39:16.000Z","updated":"2023-08-05T07:58:31.290Z","comments":true,"path":"2023/03/21/单链表/","link":"","permalink":"http://awesomeboy.cn/2023/03/21/%E5%8D%95%E9%93%BE%E8%A1%A8/","excerpt":"","text":"一：单链表介绍为什么需要链表？ 我们在使用数组存放数据是非常方便，但是由于数组的长度是固定的，所以当存储不同的元素数量时，就很容易出现问题。如果向数组中添加的数量大于数组大小时候，信息无法完全被保存。所以我们需要另一种存储方式来存储数据，其中存储的元素的个数不受限制。这种存储方式就是链表。 链表结构示意 链表的基础知识： 每一个结点包含数据域和指针域：数据域：存放用户需要的数据信息指针域：指向下一个结点的地址 头指针：head就是头指针变量，我们把指向第一个结点的指针成为头指针（无论链表是不是空，头指针是必不可少的）头结点：第一个结点前可以虚加一个头结点，头指针指向头结点，头结点的指针域（head-&gt;next）指向第一个实际有效的结点（即首元结点），头结点的数据域可以不使用，在单链表中可以不添加头结点首元结点：第一个实际有效的结点 链表是环环相扣的，head头指针指向头结点，头结点指向首元结点，首元结点指向第二个结点……直到最后的结点。 二：单链表的建立 单链表的建立即从无到有创建一个链表，一个一个的分配结点的储存空间，然后输出每一个结点的数据域，然后建立结点之间的关系。单链表的建立可以分为两种方法，（1）头插法，（2）尾插法(更易理解) 头插法即在单链表的头部插入新的结点的方法成为头插法。数据读入顺序和链表的结点顺序正好相反。&#x3D;&#x3D;图解：&#x3D;&#x3D;结点的结构体类型定义如下： 123456struct Student&#123; char name[100]; //学生姓名 int number; //学号 struct Student *next; //指向下一个结点的指针 &#125;; 头插法创建链表的函数代码如下： 123456789101112131415161718192021222324252627282930struct Student* Create()&#123; struct Student *Head; Head = (struct Student *)malloc(sizeof(struct Student)); //头指针 Head-&gt;next = NULL; //头指针指向空 struct Student *s; int num; char a[20]; while(1) //当 学号&gt;0时 &#123; printf(&quot;please input the name:\\n&quot;); scanf(&quot;%s&quot;,&amp;a); printf(&quot;please input the number:\\n&quot;); scanf(&quot;%d&quot;,&amp;num); if(num &lt;= 0) &#123; break; &#125; s = (struct Stduent *)malloc(sizeof(struct Student)); s-&gt;number = num; strcpy(s-&gt;name,a); //用头插法创建链表 s-&gt;next = Head-&gt;next; //新结点指向原来的首元结点 Head-&gt;next = s; //链表的头结点指向新结点 &#125; return Head;&#125; &#x3D;&#x3D;运行结果&#x3D;&#x3D;：倒序输出 &#x3D;&#x3D;步骤&#x3D;&#x3D;： 1.对头指针进行初始化，对其开辟动态空间，并且将头结点的指针域置空(顺序不要弄反)2.定义指针变量s,用来指向新创建的结点3.循环，在循环中开辟s（新结点）的动态空间，并赋予新结点数据域的信息4.头插法关键的两行代码，新结点指向原来的首结点，链表的头结点指向新结点，结合上面的图解去了解（不可写反，写反之后，链表的头结点无法与新结点相连，无法创建链表，输出时只会循环输出该结点的信息） 尾插法&#x3D;&#x3D;图解&#x3D;&#x3D;：&#x3D;&#x3D;代码实现&#x3D;&#x3D;： 12345678910111213141516171819202122232425262728293031struct Student *Creat() //初始化链表 &#123; struct Student *Head; Head = (struct Student *)malloc(sizeof(struct Student)); Head-&gt;next = NULL; struct Student *r,*s; //定义指针变量r,s,r指向当前单链表的表尾结点 //s用来指向新创建的结点 r = Head; //r指向头结点 int num; char a[20]; while(1) &#123; printf(&quot;please input the name:\\n&quot;); scanf(&quot;%s&quot;,&amp;a); printf(&quot;please input the number:\\n&quot;); scanf(&quot;%d&quot;,&amp;num); if(num &lt;= 0) &#123; break; &#125; s = (struct Student *)malloc(sizeof(struct Student)); strcpy(s-&gt;name ,a); s-&gt;number = num; //尾插法创立链表 r-&gt;next = s; //原来的结点指向新结点 r = s; //r指向新的结点 &#125; s-&gt;next = NULL; //链表的尾结点指针为空 return Head; &#125; 正序输出&#x3D;&#x3D;运行结果&#x3D;&#x3D;： 相较于头插法创立链表，尾插法更易于结合图解理解 &#x3D;&#x3D;步骤注意点&#x3D;&#x3D;： 1.在空链表时候，r指针指向头结点2.尾插法的关键两行代码也不可以互相调换顺序，调换顺序的结果并不会循环输出，而是无法读取存储的信息，即输入了5个姓名，输出0个信息3.注意的是，在循环结束时，新结点的指针域一定要指向空 三：单链表的遍历&#x3D;&#x3D;代码实现&#x3D;&#x3D;： 12345678910111213void print(struct Student *Head) //输出链表 &#123; struct Student *Temp = Head-&gt;next ; //临时指针指向首元结点 printf(&quot;****学生信息如下*****\\n&quot;); while(Temp!=NULL) &#123; printf(&quot;姓名: %s\\n&quot;,Temp-&gt;name ); printf(&quot;学号: %d\\n&quot;,Temp-&gt;number ); printf(&quot;\\n&quot;); Temp = Temp-&gt;next ; //移动临时指针到下一个结点 &#125; &#125; &#x3D;&#x3D;步骤注意点&#x3D;&#x3D;： 1.定义临时指针变量Temp指向首元结点2.循环输出3.关键：每输出一个结点的内容，就移动Temp指针到下一个结点的地址，如果是最后一个结点，指针指向NULL，循环结束 四：单链表结点数目判断&#x3D;&#x3D;代码实现&#x3D;&#x3D;: 123456789101112int length(struct Student *Head) //链表长度计数 &#123; struct Student *p = Head-&gt;next ; //p指针指向首元结点 int iCount = 0; //计数器 while(p!=NULL) &#123; iCount++; p = p-&gt;next ; //移动p指针到下一个结点的地址 &#125; return iCount;&#125; &#x3D;&#x3D;运行结果&#x3D;&#x3D;：&#x3D;&#x3D;步骤注意点&#x3D;&#x3D;: 定义iCount计数器，每移动一次p指针且p指向不为空，iCount++; 五：单链表的插入 链表的插入，有三种方式，可以从链表的头部插入，可以从链表的尾部插入，也可以在指定位置进行插入。 链表头插入&#x3D;&#x3D;图解&#x3D;&#x3D;：&#x3D;&#x3D;代码实现&#x3D;&#x3D;： 12345678910111213void insert(struct Student *Head) //在链表头部插入 &#123; struct Student *s; s = (struct Student *)malloc(sizeof(struct Student)); //定义s指向新分配的空间 printf(&quot;please input the insert name:\\n&quot;); scanf(&quot;%s&quot;,&amp;s-&gt;name ); printf(&quot;please input the insert number:\\n&quot;); scanf(&quot;%d&quot;,&amp;s-&gt;number ); // s-&gt;next = Head-&gt;next ; //新结点的指针指向首元结点 Head-&gt;next = s; //头结点的指针指向新结点 &#125; &#x3D;&#x3D;步骤注意点&#x3D;&#x3D;： 1.首先为插入的新结点分配内存2.首先将新结点的指针指向链表的首元结点(s-&gt;next = Head-&gt;next)3.将头结点的指针指向新结点(Head-&gt;next = s) 任意结点插入&#x3D;&#x3D;图解&#x3D;&#x3D;：&#x3D;&#x3D;代码实现&#x3D;&#x3D;： 123456789101112131415161718192021222324void insert(struct Student *Head,int i) //在第i个位置上插入新结点 &#123; struct Student *p = Head; struct Student *s; int j = 0; while(j&lt;i-1 &amp;&amp; p != NULL) //找到第i-1个地址 &#123; p = p-&gt;next ; j++; &#125; if(p != NULL) &#123; s = (struct Student *)malloc(sizeof(struct Student)); //定义s指向新分配的空间 printf(&quot;please input the insert name:\\n&quot;); scanf(&quot;%s&quot;,&amp;s-&gt;name ); printf(&quot;please input the insert number:\\n&quot;); scanf(&quot;%d&quot;,&amp;s-&gt;number ); // s-&gt;next = p-&gt;next ; //新结点指向原来第i个结点 p-&gt;next = s; //新结点成为新链表第i个结点 &#125;&#125; &#x3D;&#x3D;步骤注意点&#x3D;&#x3D;: 1.首先找到链表第i-1个结点的地址p，如果存在，则在i-1后面插入第i个结点2.为插入的新结点分配空间3.注意插入的两行代码联系图解理解 链表尾部插入&#x3D;&#x3D;图解&#x3D;&#x3D;：&#x3D;&#x3D;代码实现&#x3D;&#x3D;： 1234567891011121314151617181920void insert(struct Student *Head) //在链表尾部插入 &#123; struct Student *p,*s; //s是需要插入的结点 p = Head; while(p &amp;&amp; p-&gt;next ) //找到最后一个结点p &#123; p = p-&gt;next ; &#125; s = (struct Student *)malloc(sizeof(struct Student)); printf(&quot;please input the insert name:\\n&quot;); scanf(&quot;%s&quot;,&amp;s-&gt;name ); printf(&quot;please input the insert number:\\n&quot;); scanf(&quot;%d&quot;,&amp;s-&gt;number ); // p-&gt;next = s; //尾结点指针指向新结点 s-&gt;next = NULL; //新结点指针指向空 &#125; （尾部插入较好理解）&#x3D;&#x3D;步骤注意点&#x3D;&#x3D;： 1.首先找到尾结点，即循环中的条件，每一次p指针移动到下一个结点的地址2.插入时为新插入的结点分配空间3.尾部插入的两行代码联系图解理解，新结点指针指向空 六：单链表的删除&#x3D;&#x3D;图解&#x3D;&#x3D;：&#x3D;&#x3D;代码实现&#x3D;&#x3D;： 12345678910111213141516171819202122void Delete(struct Student *Head,int pos) //删除函数 &#123; int j = 1; //定义循环变量去寻找p结点 struct Student *p,*q; //q是要删除的结点 p = Head; while(j &lt; pos &amp;&amp; p) //p是q的前一个结点 &#123; j++; p = p-&gt;next ; &#125; if(p== NULL || p-&gt;next == NULL) //如果没有，就报错 &#123; printf(&quot;ERROR!\\n&quot;); &#125; else &#123; q = p-&gt;next ; //q指针指向需要删除的结点 p-&gt;next = q-&gt;next ; //跨过删除的结点连接q的前一个结点和后一个结点 free(q); //删除q结点 &#125;&#125; &#x3D;&#x3D;运行结果&#x3D;&#x3D;:&#x3D;&#x3D;步骤注意点&#x3D;&#x3D;： 1.pos表示的是需要删除结点的位置，定义j用来控制循环次数2.定义指针q和p，利用循环找到要删除结点之前的结点p，然后让q指向准备删除的结点即(q = p-&gt;next)3.连接删除结点两边的结点(p-&gt;next = q-&gt;next)4.用free(q)释放q指向的内存空间达到删除的目的 七 ：单链表的查询&#x3D;&#x3D;代码实现&#x3D;&#x3D;：相当于遍历查找 123456789101112131415161718192021struct Student *search(struct Student *Head,char name[]) //查询函数 &#123; struct Student *p = Head-&gt;next ; //p指针指向首元结点 while(p!=NULL) &#123; if(strcmp(p-&gt;name ,name) != 0) //利用字符串函数查询 &#123; p = p-&gt;next ; //如果没有，移动p指针到下一个结点地址 &#125; else &#123; break; //查到了跳出循环 &#125; &#125; if(p == NULL) &#123; printf(&quot;没有查到该学生的信息\\n&quot;); &#125; return p; //返回指针p的地址 &#125; &#x3D;&#x3D;步骤注意点&#x3D;&#x3D;： 1.定义指针变量p，使其从首元结点开始到链表结束2.利用字符串函数strcmp来查询 增删改查完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;struct Student &#123; int number; char name[20]; struct Student *next;&#125;;struct Student *Creat() //初始化链表 &#123; struct Student *Head; Head = (struct Student *)malloc(sizeof(struct Student)); Head-&gt;next = NULL; struct Student *r,*s; r = Head; int num; char a[20]; while(1) &#123; printf(&quot;please input the name:\\n&quot;); scanf(&quot;%s&quot;,&amp;a); printf(&quot;please input the number:\\n&quot;); scanf(&quot;%d&quot;,&amp;num); if(num &lt;= 0) &#123; break; &#125; s = (struct Student *)malloc(sizeof(struct Student)); strcpy(s-&gt;name ,a); s-&gt;number = num; //尾插法创立链表 r-&gt;next = s; //原来的结点指向新结点 r = s; //r指向新的结点 &#125; s-&gt;next = NULL; //链表的尾结点指针为空 return Head; &#125;int length(struct Student *Head) //链表长度计数 &#123; struct Student *p = Head-&gt;next ; //p指针指向首元结点 int iCount = 0; //计数器 while(p!=NULL) &#123; iCount++; p = p-&gt;next ; //移动p指针到下一个结点的地址 &#125; return iCount;&#125;//void insert(struct Student *Head) //在链表头部插入 //&#123;// struct Student *s;// s = (struct Student *)malloc(sizeof(struct Student)); //定义s指向新分配的空间 // printf(&quot;please input the insert name:\\n&quot;);// scanf(&quot;%s&quot;,&amp;s-&gt;name );// printf(&quot;please input the insert number:\\n&quot;);// scanf(&quot;%d&quot;,&amp;s-&gt;number );// //// s-&gt;next = Head-&gt;next ; //新结点的指针指向首元结点 // Head-&gt;next = s; //头结点的指针指向新结点 //&#125;void insert(struct Student *Head) //在链表尾部插入 &#123; struct Student *p,*s; //s是需要插入的结点 p = Head; while(p &amp;&amp; p-&gt;next ) //找到最后一个结点p &#123; p = p-&gt;next ; &#125; s = (struct Student *)malloc(sizeof(struct Student)); printf(&quot;please input the insert name:\\n&quot;); scanf(&quot;%s&quot;,&amp;s-&gt;name ); printf(&quot;please input the insert number:\\n&quot;); scanf(&quot;%d&quot;,&amp;s-&gt;number ); // p-&gt;next = s; //尾结点指针指向新结点 s-&gt;next = NULL; //新结点指针指向空 &#125;//void insert(struct Student *Head,int i) //在第i个位置上插入新结点 //&#123;// struct Student *p = Head;// struct Student *s;// int j = 0;// while(j&lt;i-1 &amp;&amp; p != NULL) //找到第i-1个地址 // &#123;// p = p-&gt;next ;// j++;// &#125;// if(p != NULL)// &#123;// s = (struct Student *)malloc(sizeof(struct Student)); //定义s指向新分配的空间 // printf(&quot;please input the insert name:\\n&quot;);// scanf(&quot;%s&quot;,&amp;s-&gt;name );// printf(&quot;please input the insert number:\\n&quot;);// scanf(&quot;%d&quot;,&amp;s-&gt;number );// //// s-&gt;next = p-&gt;next ; //新结点指向原来第i个结点 // p-&gt;next = s; //新结点成为新链表第i个结点 // &#125;//&#125;void Delete(struct Student *Head,int pos) //删除函数 &#123; int j = 1; //定义循环变量去寻找p结点 struct Student *p,*q; //q是要删除的结点 p = Head; while(j &lt; pos &amp;&amp; p) //p是q的前一个结点 &#123; j++; p = p-&gt;next ; &#125; if(p== NULL || p-&gt;next == NULL) //如果没有，就报错 &#123; printf(&quot;ERROR!\\n&quot;); &#125; else &#123; q = p-&gt;next ; //q指针指向需要删除的结点 p-&gt;next = q-&gt;next ; //跨过删除的结点连接q的前一个结点和后一个结点 free(q); //删除q结点 &#125;&#125;void print(struct Student *Head) //输出链表 &#123; struct Student *Temp = Head-&gt;next ; //临时指针指向首元结点 printf(&quot;****学生信息如下*****\\n&quot;); while(Temp!=NULL) &#123; printf(&quot;姓名: %s\\n&quot;,Temp-&gt;name ); printf(&quot;学号: %d\\n&quot;,Temp-&gt;number ); printf(&quot;\\n&quot;); Temp = Temp-&gt;next ; //移动临时指针到下一个节点 &#125; &#125;struct Student *search(struct Student *Head,char name[]) //查询函数 &#123; struct Student *p = Head-&gt;next ; while(p!=NULL) &#123; if(strcmp(p-&gt;name ,name) != 0) &#123; p = p-&gt;next ; &#125; else &#123; break; &#125; &#125; if(p == NULL) &#123; printf(&quot;没有查到该学生的信息\\n&quot;); &#125; return p;&#125;int main()&#123; int n; struct Student *Head; //创建头指针 Head = Creat(); //返回头指针 print(Head); //输出链表函数 printf(&quot;一共有%d个学生信息\\n&quot;,length(Head)); insert(Head); //插入链表 print(Head); printf(&quot;please input the delete the number:\\n&quot;); scanf(&quot;%d&quot;,&amp;n); Delete(Head,n); //删除结点函数 print(Head); char name[20]; printf(&quot;please input the search name:\\n&quot;); scanf(&quot;%s&quot;,&amp;name); struct Student *p = search(Head,name); //查询函数 printf(&quot;***查询信息如下:****\\n&quot;); printf(&quot;姓名:%s\\n&quot;,p-&gt;name ); printf(&quot;学号:%d\\n&quot;,p-&gt;number );&#125;","categories":[{"name":"JS","slug":"JS","permalink":"http://awesomeboy.cn/categories/JS/"},{"name":"数据结构","slug":"数据结构","permalink":"http://awesomeboy.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://awesomeboy.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"C","slug":"C","permalink":"http://awesomeboy.cn/tags/C/"}],"author":"awesomeboy"},{"title":"排序-快排","slug":"排序-快排","date":"2023-03-21T13:32:20.000Z","updated":"2023-09-13T06:54:01.297Z","comments":true,"path":"2023/03/21/排序-快排/","link":"","permalink":"http://awesomeboy.cn/2023/03/21/%E6%8E%92%E5%BA%8F-%E5%BF%AB%E6%8E%92/","excerpt":"","text":"一：快排的简单介绍 快速排序之所以快，是相对于冒泡排序，不再是只有相邻的数之间交换，它是可以跳跃式的交换，交换的距离会变得大的多，所以速度就提高了，当然也会存在最坏的结果，仍然是跟冒泡一样是相邻的两数之间进行了交换，所以它最差的时间复杂度和冒泡排序是一样的，都是O(N²),它的平均复杂度是O(NlogN)。 二：快排的实现逻辑（图解） 画图举例来解释把： 随意列出10个无序的数字，需要用到i，j两个变量，i在这列数的最左边，j在这列数的最右边，在这列数中随意找到一个数设置基准值（这里为了方便将第一个数设置为基准），首先让j向左移动，让i向右移动。 j找到一个比基准值小的数2停下来，然后i向右移动找到比基准值大的数6停下来，然后将i，j所指向的数进行交换。 交换后，j继续向左移动找到比基准值小的数4停下来，然后i向右移动找到比基准值大的数7停下来，然后将i，j所指向的数进行交换。 接下来j继续向左移动找到比基准值小的数3，i向右移动和j碰面，此时i和j在同一个位置上停下来，此时将i和j所指向的数和基准值进行交换，即将3和5进行交换。 即基准值归位后，基准值左边的都是小于基准值5的数，在基准值右边的都是大于基准值5的数。 这里需要提一点的是，为什么每次都需要j先移动，因为当最后i和j相碰时，此时所指向的是j寻找到比基准值小的数字，然后和基准值交换能确保基准值左边的都是小于基准值的数字，但是如果i先右边移动的话，最后i和j相碰时，i和j所指向的是i寻找得比基准值大的数，此时和基准值相交换，基准值左边是有一个比基准值大的数，没有达到我们需要的排序效果。 之后我们将5左边的拉出来再进行排序，此时选的基准值是3，根据原先的流程再来一遍。 这就是快速排序的逻辑。 最后总结下快排的步骤和注意点： 1.选取基准点2.永远是j先向左移动，i再向右移动3.当i，j碰面时候，将i和j所指向的数和基准值交换4.然后处理左半边和右半边（递归） 三：代码实现快排（递归）代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;stdio.h&gt;int n,i,j,a[100]; //定义全局变量 void quicksort(int left, int right) &#123; int temp,t; //temp变量是基准，t变量是用来交换的第三变量 if(left &gt; right) //跳出循环的第一个条件 &#123; return; &#125; temp = a[left]; //此时选用的是第一个数当做基准 i = left; //i是1 j = right; //j是n while(i != j) //当i,j没有走到一块的时候 &#123; while(a[j] &gt;= temp &amp;&amp; i&lt;j) //j一步一步左移，查找比基准值小的数 &#123; j--; &#125; while(a[i] &lt;= temp &amp;&amp; i&lt;j) //i一步一步右移，查找比基准值大的数 &#123; i++; &#125; if(i &lt; j) &#123; t = a[i]; //将j查到的比基准值的数与i查到的比基准值小的数交换 a[i] = a[j]; //即将小的数放在基准值左边 a[j] = t; //将大的数放在基准值右边 &#125; &#125; //将基准值归位 a[left] = a[i]; //当循环结束时，i=j，在中间某一位置 a[i] = temp; //将那一位置的数与基准值交换 //递归 ，将基准值左边分为一部分 //将基准值右边分为一部分 quicksort(left,i-1); //继续处理左半部分的数 quicksort(i+1,right); //继续处理右半部分的数 return ;&#125;int main() //主函数 &#123; scanf(&quot;%d&quot;,&amp;n); //用来限制输入的个数 for(i=1; i&lt;=n; i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); //读入数据 &#125; quicksort(1,n); //调用快排函数 for(i=1; i&lt;=n; i++) &#123; printf(&quot;%d\\t&quot;,a[i]); //循环输出 &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://awesomeboy.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://awesomeboy.cn/tags/%E6%8E%92%E5%BA%8F/"},{"name":"C","slug":"C","permalink":"http://awesomeboy.cn/tags/C/"}],"author":"awesomeboy"},{"title":"Typora+PicGo+阿里云OSS图床","slug":"Typora-PicGo-阿里云OSS图床","date":"2023-03-21T12:58:50.000Z","updated":"2023-03-21T13:28:35.215Z","comments":true,"path":"2023/03/21/Typora-PicGo-阿里云OSS图床/","link":"","permalink":"http://awesomeboy.cn/2023/03/21/Typora-PicGo-%E9%98%BF%E9%87%8C%E4%BA%91OSS%E5%9B%BE%E5%BA%8A/","excerpt":"","text":"搭建图床的原因 hexo搭建的博客，生成的博客都是.md文件，是markdown语法的文件，大多用的都是Typora软件去写。而我们写博客时候截屏，插入图片是一个必不可少的操作，如若想要将本地的照片截图放在博客网站上，那么本地照片必须在Blog本地资源之下，这样子我们的博客项目一定会非常大。所以我们需要导入图片的地址链接，这个时候就要用到的图床了。 把图片存在网站上，对应的图片生成一个链接，然后利用markdown语法插入到文本中就可以调用图片了，这样子配置之后，我们的博客网站就可以显示对应的截图和图片了。 一：安装PicGo1.1：介绍 一款功能非常强大的图床的工具，支持SM.MS、腾讯COS、GitHub图床、七牛云图床、Imgur图床、阿里云OSS、gitee等多种图床平台。 PicGo最大的特点是，可以和Typora结合使用，配置好关联之后，Typora写文章时，如果需要穿插图片，只需要将图片复制粘贴到Typora的编辑区域，就自动通过PicGo上传到指定图床，得到外网能访问的URL并展示。 1.2：下载PicGo下载地址：https://github.com/Molunerfinn/PicGo/releases 根据自己的需求下载对应的安装包下载 二：配置Typora 三：阿里云OSS搭建图床3.1：开通阿里云对象存储阿里云对象存储：https://www.aliyun.com/product/oss 注册阿里云账号后,开通对象储存，进入对象存储OSS的控制台 3.2：创建bucket创建新的bucket 跟着流程一步步走 Bucket名字不能有大写字母、地域就近选择、存储类型选择标准存储，读写权限公共读 3.3：创建AccessKey 继续使用 创建AccessKey 在弹出的界面里，记住你的accessKeyId和accessKeySecret。 3.4：收费标准阿里云对象存储OSS的收费是独立的，有两种收费形式 以充值的方式使用储存容量以及流量(默认状态) 按年&#x2F;月收费，购买一定存储包，流量额外收费 这里直接往账户充5块够用一两年了 四：配置PicGo 我们打开打开PicGo的主界面,在图床设置里面选择阿里云OSS，依照下面注意事项填写信息。 设定Keyld：填写我们在第三步中获得的AccessKeyID 设定KeySecret：填写我们在第三步中获得的AccessKeyIDSecret 设定储存空间名：填写我们在第二步中填写的bucket名称 确认存储区域：填写我们在第二步中查看的地域节点，注意复制的格式：只需要复制oss-cn-Xxxx即可，不需要后面的.aliyuncs.com 指定存储路径：其实就是自定义一个文件夹的名字，以&#x2F;结尾，它会自动在你的bucket里面创建一个文件夹，并把图片上传进去。 最后就大功告成了，直接使用即可。","categories":[{"name":"Volantis","slug":"Volantis","permalink":"http://awesomeboy.cn/categories/Volantis/"}],"tags":[{"name":"Volantis","slug":"Volantis","permalink":"http://awesomeboy.cn/tags/Volantis/"},{"name":"图床","slug":"图床","permalink":"http://awesomeboy.cn/tags/%E5%9B%BE%E5%BA%8A/"}],"author":"awesomeboy"},{"title":"Volantis主题的安装与配置","slug":"Volantis主题的安装与配置","date":"2023-03-21T12:08:43.000Z","updated":"2023-03-21T12:54:19.986Z","comments":true,"path":"2023/03/21/Volantis主题的安装与配置/","link":"","permalink":"http://awesomeboy.cn/2023/03/21/Volantis%E4%B8%BB%E9%A2%98%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/","excerpt":"","text":"Volantis官方文档： https://volantis.js.org/ 一：Volantis主题安装1.1：主题安装 在 blog/_config.yml 文件中找到并修改： 1theme: volantis 在终端(在blog目录下，右击选中Git Bash Here)输入： 1npm i hexo-theme-volantis 检查 1hexo --version 部署 在控制台输入，hexo g , hexo s 再次打开localhost:4000 就出现volantis主题样式了 12hexo ghexo s 二：Volantis主题配置2.1：站点配置blog/_config.yml title：网站标题 subtitle：网站副标题 favicon：网站图标，建议去阿里图标库选择对应图标下载，导入或者下载png图标上传到图床再生成链接使用 avatar：作者头像 language：多语言设置 123456789101112131415# Sitetitle: My Blogsubtitle: &#x27;www.awesomeboy.cn&#x27;description: &#x27;Cai&#x27;keywords:# 网站图标，更多尺寸等图标请使用import方式批量导入favicon: https://awesomeboy.oss-cn-chengdu.aliyuncs.com/img/202303211900507.png# 作者头像，会出现在文章标题下方，不同于侧边栏的大头像avatar: https://awesomeboy.oss-cn-chengdu.aliyuncs.com/img/202303071729440.jpgauthor: Cailanguage: - zh-CN - en - zh-TWtimezone: &#x27;&#x27; 2.2：主题配置 照着官方文档走就可以对应配置了，这里我直接把自己的_config.volantis.yml文件配置放这里 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549############################### Navigation Bar ############################### &gt; start# 注意事项：建议规范全站路径 URL 最后带一个 &quot;/&quot; 例如 &quot;about/&quot;navbar: visiable: auto # always, auto logo: # choose [img] or [icon + title] img: https://awesomeboy.oss-cn-chengdu.aliyuncs.com/img/202303071729440.jpg icon: title: menu: - name: 主页 icon: fa-solid fa-house url: / - name: 博客 icon: fa-solid fa-book rows: - name: 分类 icon: fa-solid fa-folder-open url: categories/ - name: 标签 icon: fa-solid fa-tags url: tags/ - name: 归档 icon: fa-solid fa-archive url: archives/ - name: 关于 icon: fa-solid fa-info-circle url: about/ - name: 直达 icon: fa-solid fa-bus rows: - name: github icon: fa-brands fa-github url: https://github.com/1357618897 - name: csdn icon: fa-solid fa-c url: https://blog.csdn.net/Czc1357618897 - name: Gitee icon: fa-solid fa-code-branch url: https://gitee.com/czc1357618897 - name: 更多 icon: fa-solid fa-list rows: - name: 友链 icon: fa-solid fa-link url: friends/ - name: 暗黑模式 icon: fas fa-moon toggle: darkmode search: Search... # Search bar placeholder############################### Navigation Bar ############################### &gt; endpages: # 友链页面配置 friends: layout_scheme: simple # simple: 简单布局, traditional: 传统布局site_footer: # layout of footer: [aplayer, social, license, info, copyright] layout: [aplayer, social, license, info, copyright] social: - icon: fas fa-envelope url: mailto:1357618897@qq.com - icon: fab fa-github url: https://github.com/1357618897 copyright: &#x27;[Copyright © 2022-2023](/)&#x27; # You can add your own property here. (Support markdown, for example: br: &#x27;&lt;br&gt;&#x27;) br: &#x27;&lt;br&gt;&#x27; ############################### Cover ############################### &gt; start copyright: class: copyright display: [desktop, mobile] # [desktop, mobile] blockquote: true permalink: &#x27;🔗 本文链接：&#x27; content: - &#x27;🧾 博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议&#x27;cover: height_scheme: full # full, half layout_scheme: search # blank (留白), search (搜索), dock (坞), featured (精选), focus (焦点) display: home: true archive: true others: false # can be written in front-matter &#x27;cover: true&#x27; background: https://awesomeboy.oss-cn-chengdu.aliyuncs.com/img/202303071720336.png # background: https://bing.ioliu.cn/v1/rand?w=1920&amp;h=1200 logo: # https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-Cover@3x.png title: &quot;Awesomeboy&#x27;s blog&quot; subtitle: &lt;div id=&quot;binft&quot;&gt;&lt;/div&gt; search: Search... # search bar placeholder features: - name: 主页 icon: # url: / - name: 分类 icon: fa-solid fa-folder-open url: categories/ - name: 标签 icon: fa-solid fa-tags url: tags/ - name: 归档 icon: fa-solid fa-archive url: archives/############################### Cover ############################### &gt; end ############################### Sidebar ############################### &gt; startsidebar: position: left # left right # 主页、分类、归档等独立页面 for_page: [blogger , category, tagcloud, webinfo , lastupdate] # layout: docs/post 这类文章页面 for_post: [toc] # 侧边栏组件库 widget_library: # --------------------------------------- # blogger info widget blogger: class: blogger display: [desktop, mobile] # [desktop, mobile] avatar: https://awesomeboy.oss-cn-chengdu.aliyuncs.com/img/202303071729440.jpg # https://gcore.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-NavBar@3x.png shape: circle # circle, rectangle url: /about/ title: Cai. subtitle: Talk is cheap.Show me your code. jinrishici: true # Poetry Today. You can set a string, and it will be displayed when loading fails. social: - icon: fa-solid fa-rss url: /atom.xml - icon: fa-solid fa-envelope url: mailto:1357618897@qq.com - icon: fab fa-github url: https://github.com/1357618897/ # --------------------------------------- # toc widget (valid only in articles) toc: class: toc display: [desktop, mobile] # [desktop, mobile] sticky: true header: icon: fa-solid fa-list title: 本文目录 list_number: false min_depth: 2 max_depth: 5 # --------------------------------------- # category widget category: class: category display: [desktop] # [desktop, mobile] header: icon: fa-solid fa-folder-open title: 文章分类 url: /blog/categories/ # --------------------------------------- # tagcloud widget # tagcloud: class: tagcloud display: [desktop, mobile] # [desktop, mobile] header: icon: fa-solid fa-tags title: 热门标签 url: /blog/tags/ min_font: 14 max_font: 24 color: true start_color: &#x27;#999&#x27; end_color: &#x27;#555&#x27; # --------------------------------------- # webinfo widget webinfo: class: webinfo display: [desktop] header: icon: fa-solid fa-award title: 站点信息 type: article: enable: true text: &#x27;文章数目：&#x27; unit: &#x27;篇&#x27; runtime: enable: true data: &#x27;2023/03/06&#x27; # 填写建站日期 text: &#x27;已运行时间：&#x27; unit: &#x27;天&#x27; wordcount: enable: true text: &#x27;本站总字数：&#x27; # 需要启用 wordcount unit: &#x27;字&#x27; visitcounter: siteuv: enable: true text: &#x27;本站访客数：&#x27; unit: &#x27;人&#x27; sitepv: enable: true text: &#x27;本站总访问量：&#x27; unit: &#x27;次&#x27; lastupd: enable: true friendlyShow: true # 更友好的时间显示 text: &#x27;最后活动时间：&#x27; unit: &#x27;日&#x27; # qrcode widget qrcode: class: qrcode display: [desktop, mobile] # [desktop, mobile] height: 64px # Automatic height if not set images: - volantis-static/media/org.volantis/blog/qrcode/github@volantis.png # https://gcore.jsdelivr.net/gh/volantis-x/cdn-org/blog/qrcode/github@volantis.png - volantis-static/media/org.volantis/blog/qrcode/github@volantis.png # https://gcore.jsdelivr.net/gh/volantis-x/cdn-org/blog/qrcode/github@volantis.png # --------------------------------------- # --------------------------------------- # lastupdate widget lastupdate: class: lastupdate display: [desktop, mobile] header: icon: fa-solid fa-clock WISTERIA title: 最近更新 ############################### Sidebar ############################### &gt; endtest: class: page display: [desktop, mobile] pid: haha content: excerpt # excerpt, more, content#自定义颜色color_scheme: # ------------ # 通用颜色 common: # 主题色 theme: &#x27;#44D7B6&#x27; # 链接色 link: &#x27;#2196f3&#x27; # 按钮色 button: &#x27;#44D7B6&#x27; # 鼠标放到交互元素上时的色 hover: &#x27;#ff5722&#x27; # 主题色块内部的文字颜色 inner: &#x27;#fff&#x27; # 选中区域文字的背景颜色 selection: &#x27;alpha(#2196f3, 0.2)&#x27; # ------------ # 亮色主题（默认） light: # 网站背景色 site_bg: &#x27;#f4f4f4&#x27; # 网站背景上的文字 site_inner: &#x27;#fff&#x27; # 网站页脚文字 site_footer: &#x27;#666&#x27; # 卡片背景色 card: &#x27;#fff&#x27; # 卡片上的普通文字 text: &#x27;#444&#x27; # 区块和代码块背景色 block: &#x27;#f6f6f6&#x27; # 代码块高亮时的背景色 codeblock: &#x27;#FFF7EA&#x27; # 行内代码颜色 inlinecode: &#x27;#D56D28&#x27; # 文章部分 h1: &#x27;#444&#x27; h2: &#x27;#ad2121&#x27; h3: &#x27;#0028bb&#x27; h4: &#x27;#ad9521&#x27; h5: &#x27;#444&#x27; h6: &#x27;#444&#x27; p: &#x27;#444&#x27; # 列表文字 list: &#x27;#666&#x27; # 列表 hover 时的文字 list_hl: &#x27;mix($color-theme, #000, 80)&#x27; # 辅助性文字 meta: &#x27;#888&#x27; # ------------ # 暗色主题 dark: # 网站背景色 site_bg: &#x27;#222&#x27; # 网站背景上的文字 site_inner: &#x27;#eee&#x27; # 网站页脚文字 site_footer: &#x27;#aaa&#x27; # 卡片背景色 card: &#x27;#444&#x27; # 卡片上的普通文字 text: &#x27;#eee&#x27; # 区块和代码块背景色 block: &#x27;#3a3a3a&#x27; # 代码块高亮时的背景色 codeblock: &#x27;#343a3c&#x27; # 行内代码颜色 inlinecode: &#x27;#D56D28&#x27; # 文章部分 h1: &#x27;#eee&#x27; h2: &#x27;#eee&#x27; h3: &#x27;#ddd&#x27; h4: &#x27;#ddd&#x27; h5: &#x27;#ddd&#x27; h6: &#x27;#ddd&#x27; p: &#x27;#bbb&#x27; # 列表文字 list: &#x27;#aaa&#x27; # 列表 hover 时的文字 list_hl: &#x27;mix($color-theme, #fff, 80)&#x27; # 辅助性文字 meta: &#x27;#888&#x27; # 夜间图片亮度 brightness: 70%search: enable: true service: hexo plugins: wordcount: enable: true busuanzi: enable: true darkmode: enable: true # APlayer is only available in mainland China. # APlayer config: https://github.com/metowolf/MetingJS parallax: enable: true position: fixed # cover: sticky on the cover. fixed: Fixed as background for the site. shuffle: true # shuffle playlist duration: 60000 # Duration (ms) fade: 1500 # fade duration (ms) (Not more than 1500) images: # For personal use only. At your own risk if used for commercial purposes !!! - https://awesomeboy.oss-cn-chengdu.aliyuncs.com/img/202303142306793.jpg aplayer: enable: true # Required server: netease # netease, tencent, kugou, xiami, baidu type: playlist # song, playlist, album, search, artist id: 5386948708 # song id / playlist id / album id / search keyword # Optional fixed: true # enable fixed mode theme: &#x27;#1BCDFC&#x27; # main color autoplay: false # audio autoplay order: list # player play order, values: &#x27;list&#x27;, &#x27;random&#x27; loop: all # player loop play, values: &#x27;all&#x27;, &#x27;one&#x27;, &#x27;none&#x27; volume: 0.7 # default volume, notice that player will remember user setting, default volume will not work after user set volume themselves list_max_height: 320px # list max height list_folded: true autoHide: true # hide automaticalycomments: service: giscus # giscus # https://giscus.app # https://github.com/laymonage/giscus giscus: # 以下配置按照 yml 格式增删填写即可 repo: 1357618897/comment repo-id: R_kgDOJGWc4Q category: Announcements category-id: DIC_kwDOJGWc4c4CUtH- mapping: &quot;pathname&quot; reactions-enabled: &quot;1&quot; emit-metadata: &quot;0&quot; lang: &quot;zh-CN&quot; # 以上配置按照 yml 格式增删填写即可 theme: light: &quot;light&quot; # https://gcore.jsdelivr.net/gh/volantis-x/cdn-volantis@master/css/giscus/light.css dark: &quot;dark&quot; # https://gcore.jsdelivr.net/gh/volantis-x/cdn-volantis@master/css/giscus/dark.css #自定义光标custom_css: max_width: 1080px # Sum of body width and sidebar width font_smoothing: true # font-smoothing for webkit gap: h2: 48px # Spacing above H2 (only px unit) h3: 24px # Spacing above H3 (only px unit) h4: 16px # Spacing above H4 (only px unit) p: 1em # Paragraph spacing between paragraphs line_height: 1.6 # normal, 1.5, 1.75, 2 ... body: effect: [shadow] # [shadow, floatable, blur] highlight: language: true # show language of codeblock copy_btn: true text_align: # left, right, justify, center h1: left h2: left h3: left h4: left p: justify sidebar: effect: [shadow] # [shadow, floatable, blur] scrollbar: size: 4px border: 2px color: &#x27;#2196f3&#x27; hover: &#x27;#ff5722&#x27; navbar: height: 64px width: auto # auto, max effect: [shadow, blur] # [shadow, floatable, blur] cursor: enable: true text: volantis-static/media/cursor/text.png # https://gcore.jsdelivr.net/gh/inkss/common@1/cursor/text.png pointer: volantis-static/media/cursor/pointer.png # https://gcore.jsdelivr.net/gh/inkss/common@1/cursor/pointer.png default: volantis-static/media/cursor/left_ptr.png # https://gcore.jsdelivr.net/gh/inkss/common@1/cursor/left_ptr.png not-allowed: volantis-static/media/cursor/circle.png # https://gcore.jsdelivr.net/gh/inkss/common@1/cursor/circle.png zoom-out: volantis-static/media/cursor/zoom-out.png # https://gcore.jsdelivr.net/gh/inkss/common@1/cursor/zoom-out.png zoom-in: volantis-static/media/cursor/zoom-in.png # https://gcore.jsdelivr.net/gh/inkss/common@1/cursor/zoom-in.png grab: volantis-static/media/cursor/openhand.png # https://gcore.jsdelivr.net/gh/inkss/common@1/cursor/openhand.png## 文章布局article: # 文章列表页面的文章卡片布局方案 preview: scheme: landscape # landscape # pin icon for post pin_icon: https://gcore.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f4cc.svg # auto generate title if not exist auto_title: true # false, true # auto generate excerpt if not exist auto_excerpt: true # false, true # show split line or not line_style: solid # hidden, solid, dashed, dotted # show readmore button readmore: auto # auto, always # 文章详情页面的文章卡片本体布局方案 body: # 文章顶部信息 # 从 meta_library 中取 top_meta: [author, category, date, counter] # ---------------- # 文章页脚组件 footer_widget: # ---------------- # 参考资料、相关资料等 (for layout: post/docs) references: title: 参考资料 icon: fas fa-quote-left # 在 front-matter 中: # references: # - title: 某篇文章 # url: https:// # 即可显示此组件。 # ---------------- # 相关文章，需要安装插件 (for layout: post) # npm i hexo-related-popular-posts related_posts: enable: false title: 相关文章 icon: fas fa-bookmark max_count: 5 # 设为空则不使用文章头图 placeholder_img: https://gcore.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/046.jpg # ---------------- # 版权声明组件 (for layout: post/docs) copyright: enable: true permalink: &#x27;本文永久链接是：&#x27; content: - &#x27;博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议&#x27; - permalink # ---------------- # 打赏组件 (for layout: post/docs) donate: enable: false images: - https://gcore.jsdelivr.net/gh/volantis-x/cdn-org/blog/qrcode/github@volantis.png - https://gcore.jsdelivr.net/gh/volantis-x/cdn-org/blog/qrcode/github@volantis.png # 文章底部信息 # 从 meta_library 中取 bottom_meta: [updated, tags, share] # meta library meta_library: # 默认文章作者（可在 front-matter 中覆盖） author: avatar: name: 请设置文章作者 url: / # 文章创建日期 date: icon: fas fa-calendar-alt title: &#x27;发布于：&#x27; format: &#x27;ll&#x27; # 日期格式 http://momentjs.com/docs/ # 文章更新日期 updated: icon: fas fa-edit title: &#x27;更新于：&#x27; format: &#x27;ll&#x27; # 日期格式 http://momentjs.com/docs/ # 文章分类 category: icon: fas fa-folder-open # 文章浏览计数 counter: icon: fas fa-eye unit: &#x27;次浏览&#x27; # 文章字数和阅读时长 wordcount: icon_wordcount: fas fa-keyboard icon_duration: fas fa-hourglass-half # 文章标签 tags: icon: fas fa-hashtag # 分享 share: - id: qq img: https://gcore.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qq.png - id: qzone img: https://gcore.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qzone.png - id: weibo img: https://gcore.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/weibo.png - id: # qrcode # 当id为qrcode时需要安装插件 npm i hexo-helper-qrcode img: # https://gcore.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/wechat.png - id: # telegram img: # https://gcore.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/telegram.pngrightmenus: order: menus.groupName plugins: defaultGroupItem menus: groupName: - &#123;menu&#125; - &#123;menu&#125; groupName1: &#123;menu&#125;#不蒜子网站访问############################# Analytics ############################# &gt; startanalytics: busuanzi: https://npm.elemecdn.com/penndu@1.0.0/bsz.js # 修改这里即可############################# Analytics ############################# &gt; end","categories":[{"name":"Volantis","slug":"Volantis","permalink":"http://awesomeboy.cn/categories/Volantis/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://awesomeboy.cn/tags/Hexo/"},{"name":"Volantis","slug":"Volantis","permalink":"http://awesomeboy.cn/tags/Volantis/"}],"author":"awesomeboy"},{"title":"Hexo博客搭建","slug":"Hexo博客搭建","date":"2023-03-21T11:11:35.000Z","updated":"2023-03-21T12:15:00.088Z","comments":true,"path":"2023/03/21/Hexo博客搭建/","link":"","permalink":"http://awesomeboy.cn/2023/03/21/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","excerpt":"","text":"前言 思前想后，不知是选用hexo搭建博客还是vuepress搭建博客，但最后还是选择hexo来搭建博客。我是更想拥有一个属于自己的博客网站的，无论是记录下自己一步一个脚印的成长还是复习之前学过的知识。 一：环境部署1.1：安装Node.js 进入Node.js官网安装，选择对应系统下载 官网链接：https://nodejs.org/en/download/ 检查 打开cmd或powershell输入。 如若显示版本号则安装成功 12node -vnpm -v 1.2：安装Git 进入Git官网安装，选择对应系统下载 官网链接：https://git-scm.com/downloads 检查 打开cmd或powershell输入。 如若显示版本号则安装成功 1git --version 1.3：注册Github账号 到Github官网注册即可 如果已有github账号直接登录 新建项目 项目名字格式是 你的昵称.github.io， 例如我的昵称是：1357618897 1.4：安装Hexo 在合适的文件夹中右击，选择Git Bash here，输入以下指令，安装hexo-cli 12cd /e/hexo/npm install hexo-cli -g 安装hexo 12npm install hexo --save 检查 12hexo -v 初始化文件夹 123cd /e/hexo/hexo initnpm install 生成hexo页面 12hexo g 启动服务 12hexo s 本地的端口一般开的是4000，打开浏览器输入查看即可 默认是localhost:4000 出现这个页面就大功告成了 1.5：将Hexo部署到Github上 配置个人信息 12git config --global user.name &quot;XXXX&quot;git config --global user.email &quot;XXXXXXXXX@XXX.com&quot; 生成密钥 12ssh-keygen -t rsa -C &quot;XXXXXXXXX@XXX.com&quot; 查看C盘用户 .ssh文件中的id_rsa.pub文件，并打开将其全部内容复制 在github中添加ssh key 修改hexo根目录下的文件_config.yml中的deploy，添加之前保存的ssh： 注意：branch：master。github版本更新将main分支改为了master分支，这里也要改 123456deploy: type: git repository: github: git@github.com:1357618897/1357618897.github.io.git branch: master 部署到Github上 12hexo d -g","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://awesomeboy.cn/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://awesomeboy.cn/tags/Hexo/"}],"author":"awesomeboy"},{"title":"Vue2项目总结-电商后台管理系统","slug":"电商后台管理系统","date":"2023-03-20T10:13:33.000Z","updated":"2023-09-04T01:51:35.049Z","comments":true,"path":"2023/03/20/电商后台管理系统/","link":"","permalink":"http://awesomeboy.cn/2023/03/20/%E7%94%B5%E5%95%86%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"去年做的项目，拖了很久，总算是打起精力去做这个项目的总结，并对Vue2的相关知识进行回顾与复习 各个功能模块如果有过多重复冗杂的部分，将会抽取部分值得记录复习的地方进行记录 一：项目简介前端技术栈 Vue2 vue-router Element-ui Axios Echarts 项目构架 功能模块 用户登录&#x2F;退出模块 用户管理模块 权限管理模块 角色列表模块 权限列表模块 商品管理模块 商品列表模块 分类管理模块 参数管理模块 订单管理模块 数据统计模块 二：各个功能模块1：项目初始化 通过vue-cli脚手架进行配置安装 vue2配置 配置vue-router 配置axios 后端接口：http://43.143.0.76:8889/api/private/v1/ 在main.js文件配置根路径： axios.defaults.baseURL &#x3D; ‘http://43.143.0.76:8889/api/private/v1/‘ 1.1：路由器的配置 配置路由器，通过login登录之后会优先跳转到home父组件（Element-ui的布局模式），redirect重定向路由到welcome欢迎组件 123456789101112131415161718192021const router = new Router(&#123; routes:[ &#123;path: &#x27;/&#x27; , redirect: &#x27;/login&#x27;&#125;, &#123;path: &#x27;/login&#x27; , component:() =&gt; import(&#x27;@/components/Login.vue&#x27;)&#125;, &#123; path: &#x27;/home&#x27; , component:() =&gt; import(&#x27;@/components/Home.vue&#x27;), redirect: &#x27;/welcome&#x27;, children: [ &#123; path: &#x27;/welcome&#x27; , component:() =&gt; import(&#x27;@/components/Welcome.vue&#x27;) &#125;, &#123; path: &#x27;/users&#x27; , component:() =&gt; import(&#x27;@/components/user/Users.vue&#x27;)&#125;, &#123; path: &#x27;/rights&#x27; , component:() =&gt; import(&#x27;@/components/power/Rights.vue&#x27;)&#125;, &#123; path: &#x27;/roles&#x27; , component:() =&gt; import(&#x27;@/components/power/Roles.vue&#x27;)&#125;, &#123; path: &#x27;/categories&#x27; , component:() =&gt; import(&#x27;@/components/goods/Cate.vue&#x27;)&#125;, &#123; path: &#x27;/params&#x27; , component:() =&gt; import(&#x27;@/components/goods/Params.vue&#x27;)&#125;, &#123; path: &#x27;/goods&#x27; , component:() =&gt; import(&#x27;@/components/goods/List.vue&#x27;)&#125;, &#123; path: &#x27;/goods/add&#x27; , component: () =&gt; import(&#x27;@/components/goods/Add.vue&#x27;)&#125;, &#123; path: &#x27;/orders&#x27; , component: () =&gt; import(&#x27;@/components/order/Order.vue&#x27;)&#125;, &#123; path: &#x27;/reports&#x27; , component: () =&gt; import(&#x27;@/components/report/Report.vue&#x27;)&#125; ] &#125; ]&#125;) 2：用户登录&#x2F;退出模块&#x3D;&#x3D;相关技术点&#x3D;&#x3D; http是无状态的 通过cookie在客户端记录状态 通过session在服务器端记录状态 通过token方式维持状态 如果前端和后台不存在跨域问题，可以通过cookie和session来记录登录状态，如果存在跨域问题，通过token方式来维持登录状态 2.1：登录token原理分析 如果不通过登录来获取服务器的token值，直接通过路由跳转对应页面，服务器无法验证token通过，有些接口功能将无法实现，由此还需要配置路由守卫来防止用户直接通过路由跳转对应页面 2.2：登录login函数逻辑代码 这里是使用了 async 和 await 来解析对应的promise对象。async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再接着执行函数体内后面的语句。 如果登录成功，将服务器的token值保存到客户端的sessionStorage中，利用seiItem属性键值对的方法存储，以便之后的后续请求都携带token认证 1234567891011121314151617181920login() &#123; this.$refs.loginFormRef.validate(async (valid) =&gt; &#123; // console.log(valid) if (!valid) &#123; return &#125; else &#123; const &#123; data: res &#125; = await this.$http.post(&#x27;login&#x27;, this.loginForm) // console.log(data) if (res.meta.status != 200) &#123; this.$message.error(&#x27;登录失败！&#x27;) &#125; else &#123; this.$message.success(&#x27;登录成功！&#x27;) //将token值保存到客户端中 window.sessionStorage.setItem(&#x27;token&#x27;, res.data.token) //并且跳转路由 this.$router.push(&#x27;/home&#x27;) &#125; &#125; &#125;)&#125;, 2.3：路由守卫 在router.js中配置路由守卫，目的是为了防止用户未通过登录，而是选择更改路由跳转到对应页面。 123456789101112131415161718192021//挂载路由守卫router.beforeEach((to , from , next) =&gt; &#123;//to 表示将要跳转的页面//from 表示从哪个页面来的//next() 表示放行 next(&#x27;/login&#x27;)表示强制跳转到登录页面 if(to.path === &#x27;/login&#x27;)&#123; // console.log(to) next() &#125;else&#123; //获取用户当前客户端的token值 const tokenStr = window.sessionStorage.getItem(&#x27;token&#x27;) //如果没有token值，强制跳转到登录页面 //如果存在token，就放行 if(!tokenStr)&#123; next(&#x27;/login&#x27;) &#125;else&#123; next() &#125; &#125;&#125;) 2.4：Element-ui的表单验证和表单重置表单验证 :rules属性绑定，data中的表单验证对象 12345678910111213141516&lt;!-- 表单部分 --&gt; &lt;el-form ref=&quot;loginFormRef&quot; :model=&quot;loginForm&quot; label-width=&quot;0px&quot; :rules=&quot;loginFormRules&quot; class=&quot;login_form&quot;&gt; &lt;!-- 用户名 --&gt; &lt;el-form-item prop=&quot;username&quot;&gt; &lt;el-input v-model=&quot;loginForm.username&quot; prefix-icon=&quot;el-icon-user&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;!-- 密码 --&gt; &lt;el-form-item prop=&quot;password&quot;&gt; &lt;el-input v-model=&quot;loginForm.password&quot; type=&quot;password&quot; prefix-icon=&quot;el-icon-lock&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;!-- 按钮 --&gt; &lt;el-form-item class=&quot;login_form_login&quot;&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;login&quot;&gt;登录&lt;/el-button&gt; &lt;el-button type=&quot;info&quot; @click=&quot;reset&quot;&gt;重置&lt;/el-button&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; 123456789101112131415161718192021//登录时的校验对象loginFormRules: &#123; username: [ &#123; required: true, message: &#x27;请输入登录账户&#x27;, trigger: &#x27;blur&#x27; &#125;, &#123; min: 3, max: 10, message: &#x27;长度在 3 到 10 个字符&#x27;, trigger: &#x27;blur&#x27;, &#125;, ], password: [ &#123; required: true, message: &#x27;请输入登录密码&#x27;, trigger: &#x27;blur&#x27; &#125;, &#123; min: 3, max: 15, message: &#x27;长度在 3 到 15 个字符&#x27;, trigger: &#x27;blur&#x27;, &#125;, ],&#125;, 表单重置 this指向vue的原型对象，通过原型对象绑定对应的resetFields函数 12345reset() &#123; // console.log(this) //实现表单的重置功能 this.$refs.loginFormRef.resetFields()&#125;, 2.5：退出登录 直接调用sessionStorage.clear()函数清空存储的token即可，同时跳转到&#x2F;login页面即可 1234exit() &#123; window.sessionStorage.clear() this.$router.push(&#x27;/login&#x27;)&#125;, 3：用户管理模块3.1：Element-ui侧边栏 在回顾具体功能模块前提不得不提一下element-ui的侧边栏组件 12345678910111213141516171819&lt;!-- 修改折叠展开的宽度样式 --&gt; &lt;el-aside :width=&quot;closeValue ? &#x27;64px&#x27; : &#x27;200px&#x27; &quot;&gt; &lt;!-- 左侧菜单导航栏 --&gt; &lt;el-menu :default-active=&quot;activePath&quot; class=&quot;el-menu-vertical-demo&quot; unique-opened :collapse=&quot;closeValue&quot; :collapse-transition=&quot;false&quot; router&gt; &lt;div class=&quot;size&quot; @click=&quot;menuClose&quot;&gt;| | |&lt;/div&gt; &lt;!-- 一级菜单导航 --&gt; &lt;el-submenu :index=&quot;item.id + &#x27;&#x27;&quot; v-for=&quot;item in menuList&quot; :key=&quot;item.id&quot;&gt; &lt;template slot=&quot;title&quot;&gt; &lt;i :class=&quot;iconList[item.id]&quot;&gt;&lt;/i&gt; &lt;span&gt;&#123;&#123;item.authName&#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;!-- 二级菜单导航 --&gt; &lt;el-menu-item :index=&quot;&#x27;/&#x27; + subitem.path&quot; v-for=&quot;subitem in item.children&quot; :key=&quot;subitem.id&quot; @click=&quot;saveNavState(&#x27;/&#x27; + subitem.path)&quot;&gt; &lt;i class=&quot;el-icon-menu&quot;&gt;&lt;/i&gt; &lt;span&gt;&#123;&#123;subitem.authName&#125;&#125;&lt;/span&gt; &lt;/el-menu-item&gt; &lt;/el-submenu&gt; &lt;/el-menu&gt; &lt;/el-aside&gt; 在el-menu标签中，:default-active&#x3D;””属性值是激活菜单的值，并没有设死，我们数据绑定到data中的activePath中 在el-submenu标签中，:index值是通过父级的v-for属性将menuList的所有item通过l插值语法（两个花括号）显示到模板上，需要注意的一点是，v-for属性同时需要，key属性的同时存在，否则会报错 1234567891011121314151617181920212223data() &#123; return &#123; menuList: [], iconList: &#123; 125: &#x27;el-icon-s-custom&#x27;, 103: &#x27;el-icon-lock&#x27;, 101: &#x27;el-icon-shopping-cart-1&#x27;, 102: &#x27;el-icon-s-order&#x27;, 145: &#x27;el-icon-s-data&#x27;, &#125;, closeValue: false, activePath: &#x27;&#x27;, &#125; &#125;， created() &#123; this.getMenuList() this.activePath = window.sessionStorage.getItem(&#x27;activePath&#x27;) &#125;, //保存链接的激活状态 saveNavState(activePath) &#123; window.sessionStorage.setItem(&#x27;activePath&#x27;, activePath) this.activePath = activePath &#125;, savNavState函数，解决了图标在当前选项高亮，但当重进还是会选择上一高亮位置，但内容则是welcome组件内容 通过sessionStorage存储当前的activePath，在created()组件被创建的时候再从sessionStorage中取出 12345//保存链接的激活状态 saveNavState(activePath) &#123; window.sessionStorage.setItem(&#x27;activePath&#x27;, activePath) this.activePath = activePath &#125;, 3.2：作用域插槽 其余的element-ui界面布局组件没什么难度，跟着文档走就可以了，需要回顾的就是slot-scope作用域插槽 这里是想实现一个按钮来切换状态的效果，element-ui提供了这个组件，但是我们同时还要实现，点击切换状态还要修改数据库中的数据 作用域插槽可以理解为：父传子，传结构，根据子组件的中的数据传结构。 12345&lt;!-- 使用插槽来实现切换效果 --&gt;&lt;template slot-scope=&quot;scope&quot;&gt; &lt;el-switch v-model=&quot;scope.row.mg_state&quot; @change=&quot;userStateChange(scope.row)&quot;&gt; &lt;/el-switch&gt;&lt;/template&gt; 123456789101112//监听用户状态修改的事件 async userStateChange(userInfo) &#123; // console.log(userInfo) const &#123; data: res &#125; = await this.$http.put( `users/$&#123;userInfo.id&#125;/state/$&#123;userInfo.mg_state&#125;` ) if (res.meta.status !== 200) &#123; userInfo.mg_state = !userInfo.mg_state this.$message.error(&#x27;更新用户状态失败！&#x27;) &#125; this.$message.success(&#x27;更新用户状态成功！&#x27;) &#125;, 3.3：Pagination 分页 还是利用element-ui组件实现 123&lt;!-- 分页区域 --&gt;&lt;el-pagination @size-change=&quot;handleSizeChange&quot; @current-change=&quot;handleCurrentChange&quot; :current-page=&quot;queryInfo.pagenum&quot; :page-sizes=&quot;[1, 2, 5, 10]&quot; :page-size=&quot;queryInfo.pagesize&quot; layout=&quot;total, sizes, prev, pager, next, jumper&quot; :total=&quot;total&quot;&gt;&lt;/el-pagination&gt; 分页功能不仅仅这里需要，以后的项目一些业务都是需要分页功能的。 首先需要创建分页数据对象，pagenum(当前页数)，pagesize(每页显示数据条数)，total(总条数)。将其返回给后端，后端返回对应数据。 123456789queryInfo: &#123; query: &#x27;&#x27;, //当前的页数 pagenum: 1, //当前每页显示多少条数据 pagesize: 2, &#125;, // 页码总数数据 total: 0, 3.4：dialog对话框 点击编辑按钮会弹出一个对话框来实现我们的编辑功能 逻辑如下： 点击编辑按钮，触发点击事件。展示dialog同时通过id搜索该用户的个人信息，将其展现。 用户通过更改本文内容，双向数据绑定到editform表单对象中 点击取消，修改visible属性（布尔值）来隐藏该对话框 点击确定，通过请求修改对应数据库中信息，同时列表需要刷新，再次调用获取用户数据函数，也修改visible属性隐藏对话框 html结构 123456789101112131415161718192021&lt;!-- 修改用户信息区域 --&gt;&lt;el-dialog title=&quot;修改用户信息&quot; :visible.sync=&quot;editDialogVisible&quot; width=&quot;50%&quot; @close=&quot;editFormClose&quot;&gt; &lt;el-form :model=&quot;editForm&quot; :rules=&quot;editFormRules&quot; ref=&quot;editFormRef&quot; label-width=&quot;100px&quot;&gt; &lt;!-- 1.用户名 --&gt; &lt;el-form-item label=&quot;用户名&quot;&gt; &lt;el-input v-model=&quot;editForm.username&quot; disabled&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;!-- 2.邮箱 --&gt; &lt;el-form-item label=&quot;邮箱&quot; prop=&quot;email&quot;&gt; &lt;el-input v-model=&quot;editForm.email&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;!-- 3. 手机号码 --&gt; &lt;el-form-item label=&quot;手机号&quot; prop=&quot;mobile&quot;&gt; &lt;el-input v-model=&quot;editForm.mobile&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;span slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button @click=&quot;editDialogVisible = false&quot;&gt;取 消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;editUser&quot;&gt;确 定&lt;/el-button&gt; &lt;/span&gt;&lt;/el-dialog&gt; 编辑按钮结构 12&lt;!-- 修改按钮 --&gt;&lt;el-button type=&quot;primary&quot; icon=&quot;el-icon-edit&quot; circle @click=&quot;showEditDialog(scope.row.id)&quot;&gt;&lt;/el-button&gt; 点击确定修改信息逻辑 12345678910111213141516171819202122232425//修改用户 editUser() &#123; //预校验 this.$refs.editFormRef.validate(async (valid) =&gt; &#123; if (!valid) return //发起修改用户信息请求 const &#123; data: res &#125; = await this.$http.put( &#x27;users/&#x27; + this.editForm.id, &#123; email: this.editForm.email, mobile: this.editForm.mobile, &#125; ) if (res.meta.status != 200) &#123; return this.$message.error(&#x27;更新用户信息失败！&#x27;) &#125; //关闭对话框 this.editDialogVisible = false //刷新数据列表 this.getUserList() //提示修改成功 this.$message.success(&#x27;更新用户信息成功！&#x27;) &#125;) &#125;, 4：权限管理模块4.1：展开表格列 主要还是通过作用域插槽和v-for，还有嵌套的权限属性实现，当然还有tag标签 el-row标签中利用v-for渲染出父级元素，蓝色标签，通过作用域插槽传数据，同时el-tag将该值渲染成蓝色标签 叉叉移除函数,removeRightById，由于每个权限都有对应的id，所以通过id来删除数据库中数据 嵌套 html结构 123456789101112131415161718192021222324252627&lt;!-- 展开列 --&gt;&lt;el-table-column type=&quot;expand&quot;&gt; &lt;!-- 使用作用域插槽 --&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;el-row :class=&quot;[&#x27;bottom&#x27; , i1 === 0 ? &#x27;top&#x27; : &#x27;&#x27;,&#x27;vcenter&#x27;]&quot; v-for=&quot;(item1 ,i1) in scope.row.children&quot; :key=&quot;item1.id&quot;&gt; &lt;!-- 一级权限渲染 --&gt; &lt;el-col :span=&quot;5&quot;&gt; &lt;el-tag closable @close=&quot;removeRightById(scope.row , item1.id)&quot;&gt;&#123;&#123;item1.authName&#125;&#125;&lt;/el-tag&gt; &lt;i class=&quot;el-icon-caret-right&quot;&gt;&lt;/i&gt; &lt;/el-col&gt; &lt;!-- 渲染二级和三级权限 --&gt; &lt;el-col :span=&quot;19&quot;&gt; &lt;!-- 通过for循环 嵌套渲染二级权限 --&gt; &lt;el-row :class=&quot;[i2 === 0 ? &#x27;&#x27; : &#x27;top&#x27;,&#x27;vcenter&#x27;]&quot; v-for=&quot;(item2 , i2) in item1.children&quot; :key=&quot;item2.id&quot;&gt; &lt;el-col :span=&quot;6&quot;&gt; &lt;el-tag type=&quot;success&quot; closable @close=&quot;removeRightById(scope.row , item2.id)&quot;&gt;&#123;&#123;item2.authName&#125;&#125;&lt;/el-tag&gt; &lt;i class=&quot;el-icon-caret-right&quot;&gt;&lt;/i&gt; &lt;/el-col&gt; &lt;el-col :span=&quot;18&quot;&gt; &lt;el-tag type=&quot;warning&quot; v-for=&quot;(item3) in item2.children&quot; :key=&quot;item3.id &quot; closable @close=&quot;removeRightById(scope.row , item3.id)&quot;&gt;&#123;&#123;item3.authName&#125;&#125;&lt;/el-tag&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;el-row :span=&quot;19&quot;&gt;&lt;/el-row&gt; &lt;/template&gt;&lt;/el-table-column&gt; removeRightById()函数 利用了confirm弹窗组件，全局挂载，promise对象，需要.then().catch()来解析 发送delete请求的参数，利用到了es6模板字符串用法 12345678910111213141516171819202122232425262728//删除权限 async removeRightById(role, roleId) &#123; //弹框提示用户是否要删除 const confirmResult = await this.$confirm( &#x27;此操作将永久删除该文件, 是否继续?&#x27;, &#x27;提示&#x27;, &#123; confirmButtonText: &#x27;确定&#x27;, cancelButtonText: &#x27;取消&#x27;, type: &#x27;warning&#x27;, &#125; ).catch((err) =&gt; err) if (confirmResult !== &#x27;confirm&#x27;) &#123; return this.$message.info(&#x27;取消了删除！&#x27;) &#125; else &#123; //向服务器发送请求删除 const &#123; data: res &#125; = await this.$http.delete( `roles/$&#123;role.id&#125;/rights/$&#123;roleId&#125;` ) if (res.meta.status !== 200) &#123; return this.$message.error(&#x27;删除权限失败！&#x27;) &#125; else &#123; role.children = res.data &#125; &#125; &#125;, 5：商品管理模块5.1：级联选择器 element-ui提供的级联选择器，有时候会出现bug，element-ui的版本不断地更新也在修正 v-model &#x3D; “selectedCateKeys”数据双向绑定数组 @change事件，当选中节点变化时触发 :options绑定商品列表 :props绑定对象的某个值，实现多级级联选择器 html结构 12345&lt;el-col&gt; &lt;span&gt;选择商品分类：&lt;/span&gt; &lt;!-- 选择分类的级联选择框 --&gt; &lt;el-cascader v-model=&quot;selectedCateKeys&quot; :options=&quot;cateList&quot; @change=&quot;handleChange&quot; :props=&quot;cateProps&quot;&gt;&lt;/el-cascader&gt;&lt;/el-col&gt; @change事件函数 1234//监听级联选择器选中框变换async handleChange() &#123; this.getParamsData()&#125;, 123456//指定级联选择器的配置对象cateProps: &#123; value: &#x27;cat_id&#x27;, label: &#x27;cat_name&#x27;, chidren: &#x27;children&#x27;,&#125;, 5.2：tabs标签页 tabs标签页 v-model双向数据绑定对应active选中的数据，这里是many和only @tab-click事件监听标签页改变触发 实现选择级联选择器的商品时候，展示对应的动态参数逻辑如下 通过级联选择器的handleChange和tabs标签页的handleTabClick两个事件，都调用getParamsData()获取商品参数函数 通过每个商品的特定id获取对应的参数信息 结构 12&lt;!-- Tabs标签页部分 --&gt;&lt;el-tabs v-model=&quot;activeName&quot; @tab-click=&quot;handleTabClick&quot;&gt; 1234data()&#123; //Tabs标签页的双向绑定数据 activeName: &#x27;many&#x27;,&#125; 首先级联选择器的长度如果不是3，即选中的只是一二级菜单就清空，不展示 第三级菜单，根据所选分类的ID，和当前所处的面板，获取对应的参数 getParamsData（）函数 123456789101112131415161718192021222324252627282930313233343536373839404142//获取参数列表数据 async getParamsData() &#123; //如果选中的不是三级菜单，数组长度就为1或2，就清空数组 if (this.selectedCateKeys.length !== 3) &#123; this.selectedCateKeys = [] this.manyTableData = [] this.onlyTableData = [] return &#125; else &#123; //根据所选分类的ID，和当前所处的面板，获取对应的参数 const &#123; data: res &#125; = await this.$http.get( `categories/$&#123;this.cateId&#125;/attributes`, &#123; params: &#123; sel: this.activeName, &#125;, &#125; ) if (res.meta.status !== 200) &#123; this.$message.error(&#x27;获取参数列表失败！&#x27;) &#125; else &#123; //成功 // console.log(res.data) //存储动态参数数据和静态属性数据 res.data.forEach((item) =&gt; &#123; item.attr_vals = item.attr_vals item.attr_vals = item.attr_vals ? item.attr_vals.split(&#x27;,&#x27;) : [] //控制文本框的显示与隐藏 // item.inputVisible = false this.$set(item, &#x27;inputVisible&#x27;, false) //文本框中输入的值 item.inputValue = &#x27;&#x27; &#125;) // console.log(res.data) if (this.activeName === &#x27;many&#x27;) &#123; this.manyTableData = res.data &#125; else &#123; this.onlyTableData = res.data &#125; &#125; &#125; &#125;, 将后台返回的数据，进行forEach遍历存储，还利用了split()分割函数 12345678910//存储动态参数数据和静态属性数据 res.data.forEach((item) =&gt; &#123; item.attr_vals = item.attr_vals item.attr_vals = item.attr_vals ? item.attr_vals.split(&#x27;,&#x27;) : [] //控制文本框的显示与隐藏 // item.inputVisible = false this.$set(item, &#x27;inputVisible&#x27;, false) //文本框中输入的值 item.inputValue = &#x27;&#x27; &#125;) 5.3： Tree 树形控件 在商品分类模块中，对于分类名称利用到了tree树形控件，用清晰的层级结构展示信息，可展开或折叠。 :data数据绑定刀catelist，商品分类列表。 :columns属性columns纵列分布 依旧使用作用域插槽，同时利用了v-if来控制对应的显示与隐藏，利用表达式的值 结构 1234567891011121314151617181920&lt;tree-table style=&quot;margin-top: 15px&quot; :data=&quot;catelist&quot; :columns=&quot;columns&quot; :selection-type=&quot;false&quot; :expand-type=&quot;false&quot; show-index index-text=&quot;#&quot; border&gt; &lt;!-- 是否有效插槽 --&gt; &lt;template slot=&quot;isok&quot; slot-scope=&quot;scope&quot;&gt; &lt;i class=&quot;el-icon-circle-check&quot; v-if=&quot;scope.row.cat_deleted === false&quot; style=&quot;color: lightgreen&quot;&gt;&lt;/i&gt; &lt;i class=&quot;el-icon-circle-close&quot; v-else style=&quot;color:red&quot;&gt;&lt;/i&gt; &lt;/template&gt; &lt;!-- 排序插槽 --&gt; &lt;template slot=&quot;order&quot; slot-scope=&quot;scope&quot;&gt; &lt;el-tag v-if=&quot;scope.row.cat_level === 0&quot;&gt;一级&lt;/el-tag&gt; &lt;el-tag type=&quot;success&quot; v-else-if=&quot;scope.row.cat_level === 1&quot;&gt;二级&lt;/el-tag&gt; &lt;el-tag type=&quot;warning&quot; v-else&gt;三级&lt;/el-tag&gt; &lt;/template&gt; &lt;!-- 操作插槽 --&gt; &lt;template slot=&quot;opt&quot; slot-scope=&quot;scope&quot;&gt; &lt;!-- 编辑 --&gt; &lt;el-button type=&quot;primary&quot; icon=&quot;el-icon-edit&quot; size=&quot;mini&quot; @click=&quot;showEditDialog(scope.row.cat_id)&quot;&gt;编辑&lt;/el-button&gt; &lt;!-- 删除 --&gt; &lt;el-button type=&quot;danger&quot; icon=&quot;el-icon-delete&quot; size=&quot;mini&quot; @click=&quot;removeUserById(scope.row.cat_id)&quot;&gt;删除&lt;/el-button&gt; &lt;/template&gt;&lt;/tree-table&gt; 5.4：添加商品信息模块 5.4.1：el-steps步骤展示信息 123456789&lt;!-- 要将string转换为number , -0 --&gt;&lt;el-steps :space=&quot;200&quot; :active=&quot;activeIndex - 0&quot; finish-status=&quot;success&quot; align-center&gt; &lt;el-step title=&quot;基本信息&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;商品参数&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;商品属性&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;商品图片&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;商品内容&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;完成&quot;&gt;&lt;/el-step&gt;&lt;/el-steps&gt; 5.4.2：el-tabs左侧标签页 @tab-click，当tab标签页被选中时触发事件 结构 1&lt;el-tabs v-model=&quot;activeIndex&quot; :tab-position=&quot;&#x27;left&#x27;&quot; :before-leave=&quot;beforeTabLeave&quot; @tab-click=&quot;tabClicked&quot;&gt; @tab-click函数 123456789101112131415161718192021222324252627282930313233343536373839//当tab标签页被选中时触发事件async tabClicked() &#123; // console.log(this.activeIndex) //访问的是商品参数面板 if (this.activeIndex === &#x27;1&#x27;) &#123; //发起请求获取参数 const &#123; data: res &#125; = await this.$http.get( `categories/$&#123;this.cateId&#125;/attributes`, &#123; params: &#123; sel: &#x27;many&#x27; &#125;, &#125; ) if (res.meta.status !== 200) &#123; this.$message.error(&#x27;获取商品参数失败！&#x27;) &#125; else &#123; res.data.forEach((item) =&gt; &#123; item.attr_vals = item.attr_vals.length === 0 ? [] : item.attr_vals.split(&#x27;,&#x27;) &#125;) // this.$message.success(&#x27;成功！&#x27;) this.manyTableData = res.data // console.log(this.manyTableDate) &#125; &#125; else if (this.activeIndex === &#x27;2&#x27;) &#123; //发起请求获取参数 const &#123; data: res &#125; = await this.$http.get( `categories/$&#123;this.cateId&#125;/attributes`, &#123; params: &#123; sel: &#x27;only&#x27; &#125;, &#125; ) if (res.meta.status !== 200) &#123; this.$message.error(&#x27;获取商品参数失败！&#x27;) &#125; else &#123; this.onlyTableData = res.data // console.log(this.onlyTableData) &#125; &#125;&#125;, 5.4.3：upload上传图片 :preview：”handlePreview“，处理图片预览函数 :on-preview&#x3D;”handlePreview”，处理图片移除函数 1234567&lt;el-tab-pane label=&quot;商品图片&quot; name=&quot;3&quot;&gt; &lt;!-- 上传图片 --&gt; &lt;!-- action表示图片要上传到的后台API地址 --&gt; &lt;el-upload class=&quot;upload-demo&quot; action=&quot;http://43.143.0.76:8889/api/private/v1/upload&quot; :on-preview=&quot;handlePreview&quot; :on-remove=&quot;handleRemove&quot; list-type=&quot;picture&quot; :headers=&quot;headerObj&quot; :on-success=&quot;handleSuccess&quot;&gt; &lt;el-button size=&quot;small&quot; type=&quot;primary&quot;&gt;点击上传&lt;/el-button&gt; &lt;/el-upload&gt; &lt;/el-tab-pane&gt; handlePreview（）图片预览函数 123456//处理图片预览handlePreview(file) &#123; // console.log(file) this.previewPath = file.response.data.url this.previewVisible = true&#125;, handlePreview()图片移除函数 1234567891011//处理图片移除handleRemove(file) &#123; //1.获取将要删除的图片的临时路径 const filePath = file.response.data.tmp_path //2.从pics数组中，找到该图片的索引值 const i = this.addForm.pics.findIndex((x) =&gt; &#123; x.pic === filePath &#125;) //3.调用数组的splice方法，从pics数组中移除 this.addForm.pics.splice(i, 1)&#125;, 6：数据统计模块6.1：echarts数据报表 12345678// 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(this.$refs.main) const &#123; data: res &#125; = await this.$http.get(&#x27;reports/type/1&#x27;) if (res.meta.status !== 200) return this.$message.error(&#x27;初始化折线图失败！&#x27;) const data = _.merge(res.data, this.options) // 绘制图表 myChart.setOption(data) 6.2：NProgress的使用 NProgress 是前端轻量级 web 进度条插件 导入NProgress包 配合axios请求拦截器使用 1234567891011121314151617//导入NProgress包import NProgress from &#x27;nprogress&#x27;import &#x27;nprogress/nprogress.css&#x27;//配置axios请求拦截器//在requst 拦截器中，展示进度条，NProgress.start()axios.interceptors.request.use(config =&gt; &#123; NProgress.start() //为请求头对象，添加token验证的Authorization字段 config.headers.Authorization = window.sessionStorage.getItem(&#x27;token&#x27;) return config&#125;)//在response中 隐藏进度条NProgress.done()axios.interceptors.response.use(config =&gt; &#123; NProgress.done() return config&#125;) 三：总结 总算把一直拖着的项目知识点整理整理完了，ohYeah！！！ 回想看完成这个项目，用自己学的vue的知识一步一步的完成，其中有许多相同的部分，但还是自己一步一步的完成了，期间遇到许许多多的error报错但还是上网不断的搜索搜索，debug。 对于路由的掌握更加得心应手了，包括登录的token认证，路由守卫，请求拦截器等等。 但也看过别人的大型项目，是将请求同一封装到一个request,js文件中，这样的好处更多是避免一个请求的方式出错减少更多的修改，以后要还有项目一定尝试尝试。 回想看最头疼的也是最有收获的部分就是分类参数模块的级联选择器配合tabs标签页的使用，添加参数等等。 通过这次的整理也算是对vue2的一个整体复习，要开始步入vue3和ts的学习了。 加油吧！","categories":[{"name":"Vue项目开发","slug":"Vue项目开发","permalink":"http://awesomeboy.cn/categories/Vue%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://awesomeboy.cn/tags/Vue/"}],"author":"awesomeboy"},{"title":"剑指-Offer-06-从尾到头打印链表","slug":"剑指-Offer-06-从尾到头打印链表","date":"2023-03-14T13:01:59.000Z","updated":"2023-08-04T04:20:10.951Z","comments":true,"path":"2023/03/14/剑指-Offer-06-从尾到头打印链表/","link":"","permalink":"http://awesomeboy.cn/2023/03/14/%E5%89%91%E6%8C%87-Offer-06-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/","excerpt":"","text":"题目描述：输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 示例： 12&gt;输入：head = [1,3,2]&gt;输出：[2,3,1] 限制： 0 &lt;&#x3D; 链表长度 &lt;&#x3D; 10000 法一：reverse()反转数组思路 迭代链表，将对应结点的val值存入数组中，最终利用数组的reverse方法反转，返回数组 代码 1234567891011var reversePrint = function(head) &#123; const arr = [] if(head === null)&#123; return [] &#125; while(head)&#123; arr.push(head.val) head = head.next &#125; return arr.reverse()&#125;; 法二：栈思路 利用栈的特性，从尾到头打印链表，利用unshift方法 代码 1234567891011var reversePrint = function(head) &#123; const arr = [] if(head === null)&#123; return [] &#125; while(head)&#123; arr.unshift(head.val) head = head.next &#125; return arr&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://awesomeboy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://awesomeboy.cn/tags/%E9%93%BE%E8%A1%A8/"}],"author":"awesomeboy"},{"title":"剑指-Offer-24-反转链表","slug":"剑指-Offer-24-反转链表","date":"2023-03-14T12:54:05.000Z","updated":"2023-03-21T12:15:21.004Z","comments":true,"path":"2023/03/14/剑指-Offer-24-反转链表/","link":"","permalink":"http://awesomeboy.cn/2023/03/14/%E5%89%91%E6%8C%87-Offer-24-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/","excerpt":"","text":"题目描述：定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。 示例： 12&gt;输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL&gt;输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 限制： 0 &lt;&#x3D; 节点个数 &lt;&#x3D; 5000 思路 利用双指针来反转链表 定义两个指针 prev 和 curr，初始时 prev 指向 null，curr 指向链表头节点。然后遍历链表，每次将 curr 的下一个节点指向 prev，然后将 prev 和 curr 分别向后移动一个节点，直到 curr 为 null。 其中，head 是链表头节点。在 while 循环中，先用 next 保存 curr 的下一个节点，然后将 curr 的下一个节点指向 prev，再将 prev 和 curr 向后移动一个节点。最后返回 prev，即为反转后的链表头节点。 代码12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */var reverseList = function(head) &#123; //双指针 cur pre if(head === null)&#123; return null &#125; let cur,pre,temp cur = head pre = null temp = null while(cur)&#123; temp = cur.next cur.next = pre pre = cur cur = temp &#125; return pre&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://awesomeboy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://awesomeboy.cn/tags/%E9%93%BE%E8%A1%A8/"}],"author":"awesomeboy"},{"title":"剑指 Offer 09. 用两个栈实现队列","slug":"剑指-Offer-09-用两个栈实现队列","date":"2023-03-07T12:35:05.000Z","updated":"2023-03-21T12:15:15.750Z","comments":true,"path":"2023/03/07/剑指-Offer-09-用两个栈实现队列/","link":"","permalink":"http://awesomeboy.cn/2023/03/07/%E5%89%91%E6%8C%87-Offer-09-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/","excerpt":"","text":"题目描述：用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 ) 示例1： 输入：[“CQueue”,”appendTail”,”deleteHead”,”deleteHead”,”deleteHead”][[],[3],[],[],[]]输出：[null,null,3,-1,-1] 示例2： 输入：[“CQueue”,”deleteHead”,”appendTail”,”appendTail”,”deleteHead”,”deleteHead”][[],[],[5],[2],[],[]]输出：[null,-1,null,null,5,2] 提示： 1 &lt;= values &lt;= 10000 最多会对appendTail、deleteHead进行 10000 次调用 思路 两个栈实现队列，栈A存储数据，栈B用于将栈A中的元素倒序，再出栈，即将队首删除 例如：栈A：[1,2,3] 想要删队首删A，那么将栈A依次出栈，栈B依次入栈，栈B：[3,2,1] ，这时候再将栈B栈顶元素出栈，即元素为1，删除了队首元素 算法思想有了，那么就需要讨论特定的不同情况了 （1）如果栈B元素为空，则需要将栈A的元素依次出栈，压入栈B，这时候再将栈B的栈顶元素出栈 （2）当栈B元素为空的同时，栈A元素也为空（后续没有压入栈A的操作即没有入队的操作），这时候队列为空返回-1 （3）当栈B有元素，栈B的栈顶元素直接出栈 代码12345678910111213141516171819202122232425262728293031323334353637383940414243var CQueue = function() &#123; //初始化两个栈 this.stackA = [] this.stackB = []&#125;;/** * @param &#123;number&#125; value * @return &#123;void&#125; */CQueue.prototype.appendTail = function(value) &#123; //栈A入栈 this.stackA.push(value)&#125;;/** * @return &#123;number&#125; */CQueue.prototype.deleteHead = function() &#123; //判断栈A和栈B是否同时为空 同时为空返回-1 if(this.stackA.length === 0 &amp;&amp; this.stackB.length === 0)&#123; return -1 &#125; //如果B为空 将A中的元素依次出栈 在B中依次入栈 if(this.stackB.length === 0)&#123; while(this.stackA.length)&#123; //A出栈 B入栈 this.stackB.push(this.stackA.pop()) &#125; //栈B栈顶元素出栈 return this.stackB.pop() &#125;else&#123; //栈B不为空 直接栈B的栈顶元素直接出栈 return this.stackB.pop() &#125;&#125;;/** * Your CQueue object will be instantiated and called as such: * var obj = new CQueue() * obj.appendTail(value) * var param_2 = obj.deleteHead() */","categories":[{"name":"算法","slug":"算法","permalink":"http://awesomeboy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"栈","slug":"栈","permalink":"http://awesomeboy.cn/tags/%E6%A0%88/"}],"author":"awesomeboy"},{"title":"剑指 Offer 30.包含min函数的栈","slug":"剑指-Offer-30-包含min函数的栈","date":"2023-03-06T14:00:47.000Z","updated":"2023-03-21T12:15:34.529Z","comments":true,"path":"2023/03/06/剑指-Offer-30-包含min函数的栈/","link":"","permalink":"http://awesomeboy.cn/2023/03/06/%E5%89%91%E6%8C%87-Offer-30-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/","excerpt":"","text":"题目描述：定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。 示例： MinStack minStack &#x3D; new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.min(); –&gt; 返回 -3.minStack.pop();minStack.top(); –&gt; 返回 0.minStack.min(); –&gt; 返回 -2. 提示： 各函数的调用总次数不超过 20000 次 思路 如果仅仅是一个栈来得到最小元素的话必须就需要遍历这个栈，那么时间复杂度就会是O(n)，因此我们需要一个辅助栈来存储数据栈中的最小元素 一个数据栈用于实现基本的栈的入栈，出栈等基本操作，一个辅助栈用于存储数据栈的最小元素 使用辅助栈来存储最小值，每次 push() 时，如果新元素比当前最小值小，则将新元素入辅助栈；每次 pop() 时，如果弹出的元素是当前最小值，则将辅助栈栈顶元素弹出。top() 方法直接返回栈顶元素，min() 方法返回辅助栈的栈顶元素即可。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * initialize your data structure here. */var MinStack = function() &#123; //数据栈 保证完整的栈的基本操作 this.Stack = [] //辅助栈 记录数据栈中最小值 this.MinStack = [Infinity] //要保证两栈的一致性&#125;;/** * @param &#123;number&#125; x * @return &#123;void&#125; */MinStack.prototype.push = function(x) &#123; //数据栈正常压栈 this.Stack.push(x) //辅助栈判断 辅助栈为空直接压栈 不为空 与辅助栈栈顶元素判断大小 如果小或者相等压入 if(this.MinStack.length == 0 || x &lt;= this.MinStack[this.MinStack.length-1])&#123; this.MinStack.push(x) &#125;&#125;;/** * @return &#123;void&#125; */MinStack.prototype.pop = function() &#123; //出栈 //数据栈正常出栈 //如果辅助栈栈顶元素和出栈元素相等 辅助栈栈顶元素也出栈 var number = this.Stack.pop() if(number == this.MinStack[this.MinStack.length-1])&#123; this.MinStack.pop() &#125;&#125;;/** * @return &#123;number&#125; */MinStack.prototype.top = function() &#123; //返回数据栈栈顶元素 return this.Stack[this.Stack.length-1]&#125;;/** * @return &#123;number&#125; */MinStack.prototype.min = function() &#123; //返回辅助栈栈顶元素 return this.MinStack[this.MinStack.length-1]&#125;;/** * Your MinStack object will be instantiated and called as such: * var obj = new MinStack() * obj.push(x) * obj.pop() * var param_3 = obj.top() * var param_4 = obj.min() */","categories":[{"name":"算法","slug":"算法","permalink":"http://awesomeboy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"栈","slug":"栈","permalink":"http://awesomeboy.cn/tags/%E6%A0%88/"}],"author":"awesomeboy"},{"title":"Hello World","slug":"hello-world","date":"2023-03-06T06:47:35.285Z","updated":"2023-03-21T11:16:25.015Z","comments":true,"path":"2023/03/06/hello-world/","link":"","permalink":"http://awesomeboy.cn/2023/03/06/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"算法","slug":"算法","permalink":"http://awesomeboy.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"JS","slug":"JS","permalink":"http://awesomeboy.cn/categories/JS/"},{"name":"Vue","slug":"Vue","permalink":"http://awesomeboy.cn/categories/Vue/"},{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://awesomeboy.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"},{"name":"Vue项目开发","slug":"Vue项目开发","permalink":"http://awesomeboy.cn/categories/Vue%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"},{"name":"数据结构","slug":"数据结构","permalink":"http://awesomeboy.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"微机原理","slug":"微机原理","permalink":"http://awesomeboy.cn/categories/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/"},{"name":"Volantis","slug":"Volantis","permalink":"http://awesomeboy.cn/categories/Volantis/"},{"name":"Hexo","slug":"Hexo","permalink":"http://awesomeboy.cn/categories/Hexo/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://awesomeboy.cn/tags/%E6%95%B0%E7%BB%84/"},{"name":"排序","slug":"排序","permalink":"http://awesomeboy.cn/tags/%E6%8E%92%E5%BA%8F/"},{"name":"JS","slug":"JS","permalink":"http://awesomeboy.cn/tags/JS/"},{"name":"双指针","slug":"双指针","permalink":"http://awesomeboy.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"回溯","slug":"回溯","permalink":"http://awesomeboy.cn/tags/%E5%9B%9E%E6%BA%AF/"},{"name":"Vue3","slug":"Vue3","permalink":"http://awesomeboy.cn/tags/Vue3/"},{"name":"TS","slug":"TS","permalink":"http://awesomeboy.cn/tags/TS/"},{"name":"组件封装","slug":"组件封装","permalink":"http://awesomeboy.cn/tags/%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85/"},{"name":"TCP","slug":"TCP","permalink":"http://awesomeboy.cn/tags/TCP/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"http://awesomeboy.cn/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"name":"HTTP","slug":"HTTP","permalink":"http://awesomeboy.cn/tags/HTTP/"},{"name":"axios","slug":"axios","permalink":"http://awesomeboy.cn/tags/axios/"},{"name":"二叉树","slug":"二叉树","permalink":"http://awesomeboy.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"广度优先搜索","slug":"广度优先搜索","permalink":"http://awesomeboy.cn/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"name":"Promise","slug":"Promise","permalink":"http://awesomeboy.cn/tags/Promise/"},{"name":"深度优先搜索","slug":"深度优先搜索","permalink":"http://awesomeboy.cn/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"name":"HTTPS","slug":"HTTPS","permalink":"http://awesomeboy.cn/tags/HTTPS/"},{"name":"Vue","slug":"Vue","permalink":"http://awesomeboy.cn/tags/Vue/"},{"name":"数据结构","slug":"数据结构","permalink":"http://awesomeboy.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Eslint","slug":"Eslint","permalink":"http://awesomeboy.cn/tags/Eslint/"},{"name":"cz-git","slug":"cz-git","permalink":"http://awesomeboy.cn/tags/cz-git/"},{"name":"prettier","slug":"prettier","permalink":"http://awesomeboy.cn/tags/prettier/"},{"name":"计算机网络物理层","slug":"计算机网络物理层","permalink":"http://awesomeboy.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%89%A9%E7%90%86%E5%B1%82/"},{"name":"计算机网络概述","slug":"计算机网络概述","permalink":"http://awesomeboy.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"},{"name":"计算机网络体系结构","slug":"计算机网络体系结构","permalink":"http://awesomeboy.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"},{"name":"微机原理","slug":"微机原理","permalink":"http://awesomeboy.cn/tags/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/"},{"name":"8086微处理器","slug":"8086微处理器","permalink":"http://awesomeboy.cn/tags/8086%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8/"},{"name":"反转字符串","slug":"反转字符串","permalink":"http://awesomeboy.cn/tags/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"串","slug":"串","permalink":"http://awesomeboy.cn/tags/%E4%B8%B2/"},{"name":"双端队列","slug":"双端队列","permalink":"http://awesomeboy.cn/tags/%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/"},{"name":"哈希表","slug":"哈希表","permalink":"http://awesomeboy.cn/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"链表","slug":"链表","permalink":"http://awesomeboy.cn/tags/%E9%93%BE%E8%A1%A8/"},{"name":"C","slug":"C","permalink":"http://awesomeboy.cn/tags/C/"},{"name":"Volantis","slug":"Volantis","permalink":"http://awesomeboy.cn/tags/Volantis/"},{"name":"图床","slug":"图床","permalink":"http://awesomeboy.cn/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"Hexo","slug":"Hexo","permalink":"http://awesomeboy.cn/tags/Hexo/"},{"name":"栈","slug":"栈","permalink":"http://awesomeboy.cn/tags/%E6%A0%88/"}]}